"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toCommonJS = /* @__PURE__ */ ((cache) => {
    return (module, temp) => {
      return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

  // node_modules/monaco-editor/esm/vs/base/common/errors.js
  function onUnexpectedError(e) {
    if (!isCancellationError(e)) {
      errorHandler.onUnexpectedError(e);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      const { name, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name,
        message,
        stack,
        noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
      };
    }
    return error;
  }
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var ErrorHandler, errorHandler, canceledName, CancellationError, ErrorNoTelemetry, BugIndicatingError;
  var init_errors = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/errors.js"() {
      ErrorHandler = class {
        constructor() {
          this.listeners = [];
          this.unexpectedErrorHandler = function(e) {
            setTimeout(() => {
              if (e.stack) {
                if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
                  throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
                }
                throw new Error(e.message + "\n\n" + e.stack);
              }
              throw e;
            }, 0);
          };
        }
        emit(e) {
          this.listeners.forEach((listener) => {
            listener(e);
          });
        }
        onUnexpectedError(e) {
          this.unexpectedErrorHandler(e);
          this.emit(e);
        }
        onUnexpectedExternalError(e) {
          this.unexpectedErrorHandler(e);
        }
      };
      errorHandler = new ErrorHandler();
      canceledName = "Canceled";
      CancellationError = class extends Error {
        constructor() {
          super(canceledName);
          this.name = this.message;
        }
      };
      ErrorNoTelemetry = class extends Error {
        constructor(msg) {
          super(msg);
          this.name = "CodeExpectedError";
        }
        static fromError(err) {
          if (err instanceof ErrorNoTelemetry) {
            return err;
          }
          const result = new ErrorNoTelemetry();
          result.message = err.message;
          result.stack = err.stack;
          return result;
        }
        static isErrorNoTelemetry(err) {
          return err.name === "CodeExpectedError";
        }
      };
      BugIndicatingError = class extends Error {
        constructor(message) {
          super(message || "An unexpected bug occurred.");
          Object.setPrototypeOf(this, BugIndicatingError.prototype);
          debugger;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/functional.js
  function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      result = fn.apply(_this, arguments);
      return result;
    };
  }
  var init_functional = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/functional.js"() {
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  var init_iterator = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/iterator.js"() {
      (function(Iterable2) {
        function is(thing) {
          return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
        }
        Iterable2.is = is;
        const _empty2 = Object.freeze([]);
        function empty() {
          return _empty2;
        }
        Iterable2.empty = empty;
        function* single(element) {
          yield element;
        }
        Iterable2.single = single;
        function wrap(iterableOrElement) {
          if (is(iterableOrElement)) {
            return iterableOrElement;
          } else {
            return single(iterableOrElement);
          }
        }
        Iterable2.wrap = wrap;
        function from(iterable) {
          return iterable || _empty2;
        }
        Iterable2.from = from;
        function isEmpty(iterable) {
          return !iterable || iterable[Symbol.iterator]().next().done === true;
        }
        Iterable2.isEmpty = isEmpty;
        function first(iterable) {
          return iterable[Symbol.iterator]().next().value;
        }
        Iterable2.first = first;
        function some(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return true;
            }
          }
          return false;
        }
        Iterable2.some = some;
        function find(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return element;
            }
          }
          return void 0;
        }
        Iterable2.find = find;
        function* filter(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              yield element;
            }
          }
        }
        Iterable2.filter = filter;
        function* map(iterable, fn) {
          let index = 0;
          for (const element of iterable) {
            yield fn(element, index++);
          }
        }
        Iterable2.map = map;
        function* concat(...iterables) {
          for (const iterable of iterables) {
            for (const element of iterable) {
              yield element;
            }
          }
        }
        Iterable2.concat = concat;
        function reduce(iterable, reducer, initialValue) {
          let value = initialValue;
          for (const element of iterable) {
            value = reducer(value, element);
          }
          return value;
        }
        Iterable2.reduce = reduce;
        function* slice(arr, from2, to = arr.length) {
          if (from2 < 0) {
            from2 += arr.length;
          }
          if (to < 0) {
            to += arr.length;
          } else if (to > arr.length) {
            to = arr.length;
          }
          for (; from2 < to; from2++) {
            yield arr[from2];
          }
        }
        Iterable2.slice = slice;
        function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
          const consumed = [];
          if (atMost === 0) {
            return [consumed, iterable];
          }
          const iterator = iterable[Symbol.iterator]();
          for (let i = 0; i < atMost; i++) {
            const next = iterator.next();
            if (next.done) {
              return [consumed, Iterable2.empty()];
            }
            consumed.push(next.value);
          }
          return [consumed, { [Symbol.iterator]() {
            return iterator;
          } }];
        }
        Iterable2.consume = consume;
      })(Iterable || (Iterable = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      const errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self2 = trackDisposable({
      dispose: once(() => {
        markAsDisposed(self2);
        fn();
      })
    });
    return self2;
  }
  var TRACK_DISPOSABLES, disposableTracker, DisposableStore, Disposable, SafeDisposable, DisposableMap;
  var init_lifecycle = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"() {
      init_functional();
      init_iterator();
      TRACK_DISPOSABLES = false;
      disposableTracker = null;
      if (TRACK_DISPOSABLES) {
        const __is_disposable_tracked__ = "__is_disposable_tracked__";
        setDisposableTracker(new class {
          trackDisposable(x) {
            const stack = new Error("Potentially leaked disposable").stack;
            setTimeout(() => {
              if (!x[__is_disposable_tracked__]) {
                console.log(stack);
              }
            }, 3e3);
          }
          setParent(child, parent) {
            if (child && child !== Disposable.None) {
              try {
                child[__is_disposable_tracked__] = true;
              } catch (_a3) {
              }
            }
          }
          markAsDisposed(disposable) {
            if (disposable && disposable !== Disposable.None) {
              try {
                disposable[__is_disposable_tracked__] = true;
              } catch (_a3) {
              }
            }
          }
          markAsSingleton(disposable) {
          }
        }());
      }
      DisposableStore = class {
        constructor() {
          this._toDispose = /* @__PURE__ */ new Set();
          this._isDisposed = false;
          trackDisposable(this);
        }
        dispose() {
          if (this._isDisposed) {
            return;
          }
          markAsDisposed(this);
          this._isDisposed = true;
          this.clear();
        }
        get isDisposed() {
          return this._isDisposed;
        }
        clear() {
          if (this._toDispose.size === 0) {
            return;
          }
          try {
            dispose(this._toDispose);
          } finally {
            this._toDispose.clear();
          }
        }
        add(o) {
          if (!o) {
            return o;
          }
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          setParentOfDisposable(o, this);
          if (this._isDisposed) {
            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
              console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
            }
          } else {
            this._toDispose.add(o);
          }
          return o;
        }
      };
      DisposableStore.DISABLE_DISPOSED_WARNING = false;
      Disposable = class {
        constructor() {
          this._store = new DisposableStore();
          trackDisposable(this);
          setParentOfDisposable(this._store, this);
        }
        dispose() {
          markAsDisposed(this);
          this._store.dispose();
        }
        _register(o) {
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          return this._store.add(o);
        }
      };
      Disposable.None = Object.freeze({ dispose() {
      } });
      SafeDisposable = class {
        constructor() {
          this.dispose = () => {
          };
          this.unset = () => {
          };
          this.isset = () => false;
          trackDisposable(this);
        }
        set(fn) {
          let callback = fn;
          this.unset = () => callback = void 0;
          this.isset = () => callback !== void 0;
          this.dispose = () => {
            if (callback) {
              callback();
              callback = void 0;
              markAsDisposed(this);
            }
          };
          return this;
        }
      };
      DisposableMap = class {
        constructor() {
          this._store = /* @__PURE__ */ new Map();
          this._isDisposed = false;
          trackDisposable(this);
        }
        dispose() {
          markAsDisposed(this);
          this._isDisposed = true;
          this.clearAndDisposeAll();
        }
        clearAndDisposeAll() {
          if (!this._store.size) {
            return;
          }
          try {
            dispose(this._store.values());
          } finally {
            this._store.clear();
          }
        }
        get(key) {
          return this._store.get(key);
        }
        set(key, value, skipDisposeOnOverwrite = false) {
          var _a3;
          if (this._isDisposed) {
            console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
          }
          if (!skipDisposeOnOverwrite) {
            (_a3 = this._store.get(key)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
          }
          this._store.set(key, value);
        }
        [Symbol.iterator]() {
          return this._store[Symbol.iterator]();
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node, LinkedList;
  var init_linkedList = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/linkedList.js"() {
      Node = class {
        constructor(element) {
          this.element = element;
          this.next = Node.Undefined;
          this.prev = Node.Undefined;
        }
      };
      Node.Undefined = new Node(void 0);
      LinkedList = class {
        constructor() {
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        get size() {
          return this._size;
        }
        isEmpty() {
          return this._first === Node.Undefined;
        }
        clear() {
          let node = this._first;
          while (node !== Node.Undefined) {
            const next = node.next;
            node.prev = Node.Undefined;
            node.next = Node.Undefined;
            node = next;
          }
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        unshift(element) {
          return this._insert(element, false);
        }
        push(element) {
          return this._insert(element, true);
        }
        _insert(element, atTheEnd) {
          const newNode = new Node(element);
          if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
          } else if (atTheEnd) {
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
          } else {
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
          }
          this._size += 1;
          let didRemove = false;
          return () => {
            if (!didRemove) {
              didRemove = true;
              this._remove(newNode);
            }
          };
        }
        shift() {
          if (this._first === Node.Undefined) {
            return void 0;
          } else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
          }
        }
        pop() {
          if (this._last === Node.Undefined) {
            return void 0;
          } else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
          }
        }
        _remove(node) {
          if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
          } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            this._first = Node.Undefined;
            this._last = Node.Undefined;
          } else if (node.next === Node.Undefined) {
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
          } else if (node.prev === Node.Undefined) {
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
          }
          this._size -= 1;
        }
        *[Symbol.iterator]() {
          let node = this._first;
          while (node !== Node.Undefined) {
            yield node.element;
            node = node.next;
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/nls.js
  function _format(message, args) {
    let result;
    if (args.length === 0) {
      result = message;
    } else {
      result = message.replace(/\{(\d+)\}/g, (match, rest) => {
        const index = rest[0];
        const arg = args[index];
        let result2 = match;
        if (typeof arg === "string") {
          result2 = arg;
        } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
          result2 = String(arg);
        }
        return result2;
      });
    }
    if (isPseudo) {
      result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
    }
    return result;
  }
  function localize(data, message, ...args) {
    return _format(message, args);
  }
  function getConfiguredDefaultLocale(_) {
    return void 0;
  }
  var isPseudo;
  var init_nls = __esm({
    "node_modules/monaco-editor/esm/vs/nls.js"() {
      isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/platform.js
  var _a, LANGUAGE_DEFAULT, _isWindows, _isMacintosh, _isLinux, _isLinuxSnap, _isNative, _isWeb, _isElectron, _isIOS, _isCI, _isMobile, _locale, _language, _translationsConfigFile, _userAgent, globals, nodeProcess, isElectronProcess, isElectronRenderer, _platform, isWindows, isMacintosh, isWebWorker, userAgent, setTimeout0IsFaster, setTimeout0, isChrome, isFirefox, isSafari, isEdge, isAndroid;
  var init_platform = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/platform.js"() {
      init_nls();
      LANGUAGE_DEFAULT = "en";
      _isWindows = false;
      _isMacintosh = false;
      _isLinux = false;
      _isLinuxSnap = false;
      _isNative = false;
      _isWeb = false;
      _isElectron = false;
      _isIOS = false;
      _isCI = false;
      _isMobile = false;
      _locale = void 0;
      _language = LANGUAGE_DEFAULT;
      _translationsConfigFile = void 0;
      _userAgent = void 0;
      globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
      nodeProcess = void 0;
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        nodeProcess = globals.vscode.process;
      } else if (typeof process !== "undefined") {
        nodeProcess = process;
      }
      isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string";
      isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
      if (typeof navigator === "object" && !isElectronRenderer) {
        _userAgent = navigator.userAgent;
        _isWindows = _userAgent.indexOf("Windows") >= 0;
        _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
        _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
        _isLinux = _userAgent.indexOf("Linux") >= 0;
        _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
        _isWeb = true;
        const configuredLocale = getConfiguredDefaultLocale(localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_"));
        _locale = configuredLocale || LANGUAGE_DEFAULT;
        _language = _locale;
      } else if (typeof nodeProcess === "object") {
        _isWindows = nodeProcess.platform === "win32";
        _isMacintosh = nodeProcess.platform === "darwin";
        _isLinux = nodeProcess.platform === "linux";
        _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
        _isElectron = isElectronProcess;
        _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
        _locale = LANGUAGE_DEFAULT;
        _language = LANGUAGE_DEFAULT;
        const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
        if (rawNlsConfig) {
          try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages["*"];
            _locale = nlsConfig.locale;
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig._translationsConfigFile;
          } catch (e) {
          }
        }
        _isNative = true;
      } else {
        console.error("Unable to resolve platform.");
      }
      _platform = 0;
      if (_isMacintosh) {
        _platform = 1;
      } else if (_isWindows) {
        _platform = 3;
      } else if (_isLinux) {
        _platform = 2;
      }
      isWindows = _isWindows;
      isMacintosh = _isMacintosh;
      isWebWorker = _isWeb && typeof globals.importScripts === "function";
      userAgent = _userAgent;
      setTimeout0IsFaster = typeof globals.postMessage === "function" && !globals.importScripts;
      setTimeout0 = (() => {
        if (setTimeout0IsFaster) {
          const pending = [];
          globals.addEventListener("message", (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
              for (let i = 0, len = pending.length; i < len; i++) {
                const candidate = pending[i];
                if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                  pending.splice(i, 1);
                  candidate.callback();
                  return;
                }
              }
            }
          });
          let lastId = 0;
          return (callback) => {
            const myId = ++lastId;
            pending.push({
              id: myId,
              callback
            });
            globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
          };
        }
        return (callback) => setTimeout(callback);
      })();
      isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
      isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
      isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
      isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
      isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow, StopWatch;
  var init_stopwatch = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/stopwatch.js"() {
      init_platform();
      hasPerformanceNow = globals.performance && typeof globals.performance.now === "function";
      StopWatch = class {
        static create(highResolution = true) {
          return new StopWatch(highResolution);
        }
        constructor(highResolution) {
          this._highResolution = hasPerformanceNow && highResolution;
          this._startTime = this._now();
          this._stopTime = -1;
        }
        stop() {
          this._stopTime = this._now();
        }
        elapsed() {
          if (this._stopTime !== -1) {
            return this._stopTime - this._startTime;
          }
          return this._now() - this._startTime;
        }
        _now() {
          return this._highResolution ? globals.performance.now() : Date.now();
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableDisposeWithListenerWarning, _enableSnapshotPotentialLeakWarning, Event, EventProfiling, _globalLeakWarningThreshold, LeakageMonitor, Stacktrace, Listener, Emitter, EventDeliveryQueue, PrivateEventDeliveryQueue, EventDeliveryQueueElement;
  var init_event = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/event.js"() {
      init_errors();
      init_functional();
      init_lifecycle();
      init_linkedList();
      init_stopwatch();
      _enableDisposeWithListenerWarning = false;
      _enableSnapshotPotentialLeakWarning = false;
      (function(Event2) {
        Event2.None = () => Disposable.None;
        function _addLeakageTraceLogic(options) {
          if (_enableSnapshotPotentialLeakWarning) {
            const { onDidAddListener: origListenerDidAdd } = options;
            const stack = Stacktrace.create();
            let count = 0;
            options.onDidAddListener = () => {
              if (++count === 2) {
                console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
                stack.print();
              }
              origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
            };
          }
        }
        function defer(event, disposable) {
          return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
        }
        Event2.defer = defer;
        function once3(event) {
          return (listener, thisArgs = null, disposables) => {
            let didFire = false;
            let result = void 0;
            result = event((e) => {
              if (didFire) {
                return;
              } else if (result) {
                result.dispose();
              } else {
                didFire = true;
              }
              return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
              result.dispose();
            }
            return result;
          };
        }
        Event2.once = once3;
        function map(event, map2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
        }
        Event2.map = map;
        function forEach(event, each, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => {
            each(i);
            listener.call(thisArgs, i);
          }, null, disposables), disposable);
        }
        Event2.forEach = forEach;
        function filter(event, filter2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
        }
        Event2.filter = filter;
        function signal(event) {
          return event;
        }
        Event2.signal = signal;
        function any(...events) {
          return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
        }
        Event2.any = any;
        function reduce(event, merge, initial, disposable) {
          let output = initial;
          return map(event, (e) => {
            output = merge(output, e);
            return output;
          }, disposable);
        }
        Event2.reduce = reduce;
        function snapshot(event, disposable) {
          let listener;
          const options = {
            onWillAddFirstListener() {
              listener = event(emitter.fire, emitter);
            },
            onDidRemoveLastListener() {
              listener === null || listener === void 0 ? void 0 : listener.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
          return emitter.event;
        }
        function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
          let subscription;
          let output = void 0;
          let handle = void 0;
          let numDebouncedCalls = 0;
          let doFire;
          const options = {
            leakWarningThreshold,
            onWillAddFirstListener() {
              subscription = event((cur) => {
                numDebouncedCalls++;
                output = merge(output, cur);
                if (leading && !handle) {
                  emitter.fire(output);
                  output = void 0;
                }
                doFire = () => {
                  const _output = output;
                  output = void 0;
                  handle = void 0;
                  if (!leading || numDebouncedCalls > 1) {
                    emitter.fire(_output);
                  }
                  numDebouncedCalls = 0;
                };
                if (typeof delay === "number") {
                  clearTimeout(handle);
                  handle = setTimeout(doFire, delay);
                } else {
                  if (handle === void 0) {
                    handle = 0;
                    queueMicrotask(doFire);
                  }
                }
              });
            },
            onWillRemoveListener() {
              if (flushOnListenerRemove && numDebouncedCalls > 0) {
                doFire === null || doFire === void 0 ? void 0 : doFire();
              }
            },
            onDidRemoveLastListener() {
              doFire = void 0;
              subscription.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
          return emitter.event;
        }
        Event2.debounce = debounce;
        function accumulate(event, delay = 0, disposable) {
          return Event2.debounce(event, (last, e) => {
            if (!last) {
              return [e];
            }
            last.push(e);
            return last;
          }, delay, void 0, true, void 0, disposable);
        }
        Event2.accumulate = accumulate;
        function latch(event, equals2 = (a, b) => a === b, disposable) {
          let firstCall = true;
          let cache;
          return filter(event, (value) => {
            const shouldEmit = firstCall || !equals2(value, cache);
            firstCall = false;
            cache = value;
            return shouldEmit;
          }, disposable);
        }
        Event2.latch = latch;
        function split(event, isT, disposable) {
          return [
            Event2.filter(event, isT, disposable),
            Event2.filter(event, (e) => !isT(e), disposable)
          ];
        }
        Event2.split = split;
        function buffer(event, flushAfterTimeout = false, _buffer = []) {
          let buffer2 = _buffer.slice();
          let listener = event((e) => {
            if (buffer2) {
              buffer2.push(e);
            } else {
              emitter.fire(e);
            }
          });
          const flush = () => {
            buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e) => emitter.fire(e));
            buffer2 = null;
          };
          const emitter = new Emitter({
            onWillAddFirstListener() {
              if (!listener) {
                listener = event((e) => emitter.fire(e));
              }
            },
            onDidAddFirstListener() {
              if (buffer2) {
                if (flushAfterTimeout) {
                  setTimeout(flush);
                } else {
                  flush();
                }
              }
            },
            onDidRemoveLastListener() {
              if (listener) {
                listener.dispose();
              }
              listener = null;
            }
          });
          return emitter.event;
        }
        Event2.buffer = buffer;
        class ChainableEvent {
          constructor(event) {
            this.event = event;
            this.disposables = new DisposableStore();
          }
          map(fn) {
            return new ChainableEvent(map(this.event, fn, this.disposables));
          }
          forEach(fn) {
            return new ChainableEvent(forEach(this.event, fn, this.disposables));
          }
          filter(fn) {
            return new ChainableEvent(filter(this.event, fn, this.disposables));
          }
          reduce(merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));
          }
          latch() {
            return new ChainableEvent(latch(this.event, void 0, this.disposables));
          }
          debounce(merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold) {
            return new ChainableEvent(debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));
          }
          on(listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
          }
          once(listener, thisArgs, disposables) {
            return once3(this.event)(listener, thisArgs, disposables);
          }
          dispose() {
            this.disposables.dispose();
          }
        }
        function chain(event) {
          return new ChainableEvent(event);
        }
        Event2.chain = chain;
        function fromNodeEventEmitter(emitter, eventName, map2 = (id) => id) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.on(eventName, fn);
          const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
          const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
          return result.event;
        }
        Event2.fromNodeEventEmitter = fromNodeEventEmitter;
        function fromDOMEventEmitter(emitter, eventName, map2 = (id) => id) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
          const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
          const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
          return result.event;
        }
        Event2.fromDOMEventEmitter = fromDOMEventEmitter;
        function toPromise(event) {
          return new Promise((resolve2) => once3(event)(resolve2));
        }
        Event2.toPromise = toPromise;
        function runAndSubscribe(event, handler) {
          handler(void 0);
          return event((e) => handler(e));
        }
        Event2.runAndSubscribe = runAndSubscribe;
        function runAndSubscribeWithStore(event, handler) {
          let store = null;
          function run(e) {
            store === null || store === void 0 ? void 0 : store.dispose();
            store = new DisposableStore();
            handler(e, store);
          }
          run(void 0);
          const disposable = event((e) => run(e));
          return toDisposable(() => {
            disposable.dispose();
            store === null || store === void 0 ? void 0 : store.dispose();
          });
        }
        Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;
        class EmitterObserver {
          constructor(obs, store) {
            this.obs = obs;
            this._counter = 0;
            this._hasChanged = false;
            const options = {
              onWillAddFirstListener: () => {
                obs.addObserver(this);
              },
              onDidRemoveLastListener: () => {
                obs.removeObserver(this);
              }
            };
            if (!store) {
              _addLeakageTraceLogic(options);
            }
            this.emitter = new Emitter(options);
            if (store) {
              store.add(this.emitter);
            }
          }
          beginUpdate(_observable) {
            this._counter++;
          }
          handleChange(_observable, _change) {
            this._hasChanged = true;
          }
          endUpdate(_observable) {
            if (--this._counter === 0) {
              if (this._hasChanged) {
                this._hasChanged = false;
                this.emitter.fire(this.obs.get());
              }
            }
          }
        }
        function fromObservable(obs, store) {
          const observer = new EmitterObserver(obs, store);
          return observer.emitter.event;
        }
        Event2.fromObservable = fromObservable;
      })(Event || (Event = {}));
      EventProfiling = class {
        constructor(name) {
          this.listenerCount = 0;
          this.invocationCount = 0;
          this.elapsedOverall = 0;
          this.durations = [];
          this.name = `${name}_${EventProfiling._idPool++}`;
          EventProfiling.all.add(this);
        }
        start(listenerCount) {
          this._stopWatch = new StopWatch(true);
          this.listenerCount = listenerCount;
        }
        stop() {
          if (this._stopWatch) {
            const elapsed = this._stopWatch.elapsed();
            this.durations.push(elapsed);
            this.elapsedOverall += elapsed;
            this.invocationCount += 1;
            this._stopWatch = void 0;
          }
        }
      };
      EventProfiling.all = /* @__PURE__ */ new Set();
      EventProfiling._idPool = 0;
      _globalLeakWarningThreshold = -1;
      LeakageMonitor = class {
        constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
          this.threshold = threshold;
          this.name = name;
          this._warnCountdown = 0;
        }
        dispose() {
          var _a3;
          (_a3 = this._stacks) === null || _a3 === void 0 ? void 0 : _a3.clear();
        }
        check(stack, listenerCount) {
          const threshold = this.threshold;
          if (threshold <= 0 || listenerCount < threshold) {
            return void 0;
          }
          if (!this._stacks) {
            this._stacks = /* @__PURE__ */ new Map();
          }
          const count = this._stacks.get(stack.value) || 0;
          this._stacks.set(stack.value, count + 1);
          this._warnCountdown -= 1;
          if (this._warnCountdown <= 0) {
            this._warnCountdown = threshold * 0.5;
            let topStack;
            let topCount = 0;
            for (const [stack2, count2] of this._stacks) {
              if (!topStack || topCount < count2) {
                topStack = stack2;
                topCount = count2;
              }
            }
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            console.warn(topStack);
          }
          return () => {
            const count2 = this._stacks.get(stack.value) || 0;
            this._stacks.set(stack.value, count2 - 1);
          };
        }
      };
      Stacktrace = class {
        static create() {
          var _a3;
          return new Stacktrace((_a3 = new Error().stack) !== null && _a3 !== void 0 ? _a3 : "");
        }
        constructor(value) {
          this.value = value;
        }
        print() {
          console.warn(this.value.split("\n").slice(2).join("\n"));
        }
      };
      Listener = class {
        constructor(callback, callbackThis, stack) {
          this.callback = callback;
          this.callbackThis = callbackThis;
          this.stack = stack;
          this.subscription = new SafeDisposable();
        }
        invoke(e) {
          this.callback.call(this.callbackThis, e);
        }
      };
      Emitter = class {
        constructor(options) {
          var _a3, _b, _c, _d, _e;
          this._disposed = false;
          this._options = options;
          this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : void 0;
          this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
          this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
        }
        dispose() {
          var _a3, _b, _c, _d;
          if (!this._disposed) {
            this._disposed = true;
            if (this._listeners) {
              if (_enableDisposeWithListenerWarning) {
                const listeners = Array.from(this._listeners);
                queueMicrotask(() => {
                  var _a4;
                  for (const listener of listeners) {
                    if (listener.subscription.isset()) {
                      listener.subscription.unset();
                      (_a4 = listener.stack) === null || _a4 === void 0 ? void 0 : _a4.print();
                    }
                  }
                });
              }
              this._listeners.clear();
            }
            (_a3 = this._deliveryQueue) === null || _a3 === void 0 ? void 0 : _a3.clear(this);
            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);
            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
          }
        }
        get event() {
          if (!this._event) {
            this._event = (callback, thisArgs, disposables) => {
              var _a3, _b, _c;
              if (!this._listeners) {
                this._listeners = new LinkedList();
              }
              if (this._leakageMon && this._listeners.size > this._leakageMon.threshold * 3) {
                console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
                return Disposable.None;
              }
              const firstListener = this._listeners.isEmpty();
              if (firstListener && ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.onWillAddFirstListener)) {
                this._options.onWillAddFirstListener(this);
              }
              let removeMonitor;
              let stack;
              if (this._leakageMon && this._listeners.size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
                stack = Stacktrace.create();
                removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
              }
              if (_enableDisposeWithListenerWarning) {
                stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
              }
              const listener = new Listener(callback, thisArgs, stack);
              const removeListener = this._listeners.push(listener);
              if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidAddFirstListener)) {
                this._options.onDidAddFirstListener(this);
              }
              if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddListener) {
                this._options.onDidAddListener(this, callback, thisArgs);
              }
              const result = listener.subscription.set(() => {
                var _a4, _b2;
                removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
                if (!this._disposed) {
                  (_b2 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, this);
                  removeListener();
                  if (this._options && this._options.onDidRemoveLastListener) {
                    const hasListeners = this._listeners && !this._listeners.isEmpty();
                    if (!hasListeners) {
                      this._options.onDidRemoveLastListener(this);
                    }
                  }
                }
              });
              if (disposables instanceof DisposableStore) {
                disposables.add(result);
              } else if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        fire(event) {
          var _a3, _b;
          if (this._listeners) {
            if (!this._deliveryQueue) {
              this._deliveryQueue = new PrivateEventDeliveryQueue();
            }
            for (const listener of this._listeners) {
              this._deliveryQueue.push(this, listener, event);
            }
            (_a3 = this._perfMon) === null || _a3 === void 0 ? void 0 : _a3.start(this._deliveryQueue.size);
            this._deliveryQueue.deliver();
            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();
          }
        }
        hasListeners() {
          if (!this._listeners) {
            return false;
          }
          return !this._listeners.isEmpty();
        }
      };
      EventDeliveryQueue = class {
        constructor() {
          this._queue = new LinkedList();
        }
        get size() {
          return this._queue.size;
        }
        push(emitter, listener, event) {
          this._queue.push(new EventDeliveryQueueElement(emitter, listener, event));
        }
        clear(emitter) {
          const newQueue = new LinkedList();
          for (const element of this._queue) {
            if (element.emitter !== emitter) {
              newQueue.push(element);
            }
          }
          this._queue = newQueue;
        }
        deliver() {
          while (this._queue.size > 0) {
            const element = this._queue.shift();
            try {
              element.listener.invoke(element.event);
            } catch (e) {
              onUnexpectedError(e);
            }
          }
        }
      };
      PrivateEventDeliveryQueue = class extends EventDeliveryQueue {
        clear(emitter) {
          this._queue.clear();
        }
      };
      EventDeliveryQueueElement = class {
        constructor(emitter, listener, event) {
          this.emitter = emitter;
          this.listener = listener;
          this.event = event;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/types.js
  function isString(str) {
    return typeof str === "string";
  }
  var init_types = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/types.js"() {
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/objects.js
  function getAllPropertyNames(obj) {
    let res = [];
    let proto = Object.getPrototypeOf(obj);
    while (Object.prototype !== proto) {
      res = res.concat(Object.getOwnPropertyNames(proto));
      proto = Object.getPrototypeOf(proto);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var init_objects = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/objects.js"() {
      init_types();
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/cache.js
  var LRUCachedFunction;
  var init_cache = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/cache.js"() {
      LRUCachedFunction = class {
        constructor(fn) {
          this.fn = fn;
          this.lastCache = void 0;
          this.lastArgKey = void 0;
        }
        get(arg) {
          const key = JSON.stringify(arg);
          if (this.lastArgKey !== key) {
            this.lastArgKey = key;
            this.lastCache = this.fn(arg);
          }
          return this.lastCache;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy;
  var init_lazy = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/lazy.js"() {
      Lazy = class {
        constructor(executor) {
          this.executor = executor;
          this._didRun = false;
        }
        get value() {
          if (!this._didRun) {
            try {
              this._value = this.executor();
            } catch (err) {
              this._error = err;
            } finally {
              this._didRun = true;
            }
          }
          if (this._error) {
            throw this._error;
          }
          return this._value;
        }
        get rawValue() {
          return this._value;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/strings.js
  function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var _a2, IS_BASIC_ASCII, UTF8_BOM_CHARACTER, GraphemeBreakTree, AmbiguousCharacters, InvisibleCharacters;
  var init_strings = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/strings.js"() {
      init_cache();
      init_lazy();
      IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
      UTF8_BOM_CHARACTER = String.fromCharCode(65279);
      GraphemeBreakTree = class {
        static getInstance() {
          if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
          }
          return GraphemeBreakTree._INSTANCE;
        }
        constructor() {
          this._data = getGraphemeBreakRawData();
        }
        getGraphemeBreakType(codePoint) {
          if (codePoint < 32) {
            if (codePoint === 10) {
              return 3;
            }
            if (codePoint === 13) {
              return 2;
            }
            return 4;
          }
          if (codePoint < 127) {
            return 0;
          }
          const data = this._data;
          const nodeCount = data.length / 3;
          let nodeIndex = 1;
          while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
              nodeIndex = 2 * nodeIndex;
            } else if (codePoint > data[3 * nodeIndex + 1]) {
              nodeIndex = 2 * nodeIndex + 1;
            } else {
              return data[3 * nodeIndex + 2];
            }
          }
          return 0;
        }
      };
      GraphemeBreakTree._INSTANCE = null;
      AmbiguousCharacters = class {
        static getInstance(locales) {
          return AmbiguousCharacters.cache.get(Array.from(locales));
        }
        static getLocales() {
          return AmbiguousCharacters._locales.value;
        }
        constructor(confusableDictionary) {
          this.confusableDictionary = confusableDictionary;
        }
        isAmbiguous(codePoint) {
          return this.confusableDictionary.has(codePoint);
        }
        getPrimaryConfusable(codePoint) {
          return this.confusableDictionary.get(codePoint);
        }
        getConfusableCodePoints() {
          return new Set(this.confusableDictionary.keys());
        }
      };
      _a2 = AmbiguousCharacters;
      AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
        return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
      });
      AmbiguousCharacters.cache = new LRUCachedFunction((locales) => {
        function arrayToMap(arr) {
          const result = /* @__PURE__ */ new Map();
          for (let i = 0; i < arr.length; i += 2) {
            result.set(arr[i], arr[i + 1]);
          }
          return result;
        }
        function mergeMaps(map1, map2) {
          const result = new Map(map1);
          for (const [key, value] of map2) {
            result.set(key, value);
          }
          return result;
        }
        function intersectMaps(map1, map2) {
          if (!map1) {
            return map2;
          }
          const result = /* @__PURE__ */ new Map();
          for (const [key, value] of map1) {
            if (map2.has(key)) {
              result.set(key, value);
            }
          }
          return result;
        }
        const data = _a2.ambiguousCharacterData.value;
        let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
        if (filteredLocales.length === 0) {
          filteredLocales = ["_default"];
        }
        let languageSpecificMap = void 0;
        for (const locale of filteredLocales) {
          const map2 = arrayToMap(data[locale]);
          languageSpecificMap = intersectMaps(languageSpecificMap, map2);
        }
        const commonMap = arrayToMap(data["_common"]);
        const map = mergeMaps(commonMap, languageSpecificMap);
        return new AmbiguousCharacters(map);
      });
      AmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter((k) => !k.startsWith("_")));
      InvisibleCharacters = class {
        static getRawData() {
          return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
        }
        static getData() {
          if (!this._data) {
            this._data = new Set(InvisibleCharacters.getRawData());
          }
          return this._data;
        }
        static isInvisibleCharacter(codePoint) {
          return InvisibleCharacters.getData().has(codePoint);
        }
        static get codePoints() {
          return InvisibleCharacters.getData();
        }
      };
      InvisibleCharacters._data = void 0;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
  function propertyIsEvent(name) {
    return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name) {
    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
  }
  function createProxyObject2(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const createProxyDynamicEvent = (eventName) => {
      return function(arg) {
        return proxyListen(eventName, arg);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      if (propertyIsDynamicEvent(methodName)) {
        result[methodName] = createProxyDynamicEvent(methodName);
        continue;
      }
      if (propertyIsEvent(methodName)) {
        result[methodName] = proxyListen(methodName, void 0);
        continue;
      }
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var INITIALIZE, RequestMessage, ReplyMessage, SubscribeEventMessage, EventMessage, UnsubscribeEventMessage, SimpleWorkerProtocol, SimpleWorkerServer;
  var init_simpleWorker = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js"() {
      init_errors();
      init_event();
      init_lifecycle();
      init_objects();
      init_platform();
      init_strings();
      INITIALIZE = "$initialize";
      RequestMessage = class {
        constructor(vsWorker, req, method, args) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.method = method;
          this.args = args;
          this.type = 0;
        }
      };
      ReplyMessage = class {
        constructor(vsWorker, seq, res, err) {
          this.vsWorker = vsWorker;
          this.seq = seq;
          this.res = res;
          this.err = err;
          this.type = 1;
        }
      };
      SubscribeEventMessage = class {
        constructor(vsWorker, req, eventName, arg) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.eventName = eventName;
          this.arg = arg;
          this.type = 2;
        }
      };
      EventMessage = class {
        constructor(vsWorker, req, event) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.event = event;
          this.type = 3;
        }
      };
      UnsubscribeEventMessage = class {
        constructor(vsWorker, req) {
          this.vsWorker = vsWorker;
          this.req = req;
          this.type = 4;
        }
      };
      SimpleWorkerProtocol = class {
        constructor(handler) {
          this._workerId = -1;
          this._handler = handler;
          this._lastSentReq = 0;
          this._pendingReplies = /* @__PURE__ */ Object.create(null);
          this._pendingEmitters = /* @__PURE__ */ new Map();
          this._pendingEvents = /* @__PURE__ */ new Map();
        }
        setWorkerId(workerId) {
          this._workerId = workerId;
        }
        sendMessage(method, args) {
          const req = String(++this._lastSentReq);
          return new Promise((resolve2, reject) => {
            this._pendingReplies[req] = {
              resolve: resolve2,
              reject
            };
            this._send(new RequestMessage(this._workerId, req, method, args));
          });
        }
        listen(eventName, arg) {
          let req = null;
          const emitter = new Emitter({
            onWillAddFirstListener: () => {
              req = String(++this._lastSentReq);
              this._pendingEmitters.set(req, emitter);
              this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
            },
            onDidRemoveLastListener: () => {
              this._pendingEmitters.delete(req);
              this._send(new UnsubscribeEventMessage(this._workerId, req));
              req = null;
            }
          });
          return emitter.event;
        }
        handleMessage(message) {
          if (!message || !message.vsWorker) {
            return;
          }
          if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
            return;
          }
          this._handleMessage(message);
        }
        _handleMessage(msg) {
          switch (msg.type) {
            case 1:
              return this._handleReplyMessage(msg);
            case 0:
              return this._handleRequestMessage(msg);
            case 2:
              return this._handleSubscribeEventMessage(msg);
            case 3:
              return this._handleEventMessage(msg);
            case 4:
              return this._handleUnsubscribeEventMessage(msg);
          }
        }
        _handleReplyMessage(replyMessage) {
          if (!this._pendingReplies[replyMessage.seq]) {
            console.warn("Got reply to unknown seq");
            return;
          }
          const reply = this._pendingReplies[replyMessage.seq];
          delete this._pendingReplies[replyMessage.seq];
          if (replyMessage.err) {
            let err = replyMessage.err;
            if (replyMessage.err.$isError) {
              err = new Error();
              err.name = replyMessage.err.name;
              err.message = replyMessage.err.message;
              err.stack = replyMessage.err.stack;
            }
            reply.reject(err);
            return;
          }
          reply.resolve(replyMessage.res);
        }
        _handleRequestMessage(requestMessage) {
          const req = requestMessage.req;
          const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
          result.then((r) => {
            this._send(new ReplyMessage(this._workerId, req, r, void 0));
          }, (e) => {
            if (e.detail instanceof Error) {
              e.detail = transformErrorForSerialization(e.detail);
            }
            this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
          });
        }
        _handleSubscribeEventMessage(msg) {
          const req = msg.req;
          const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
            this._send(new EventMessage(this._workerId, req, event));
          });
          this._pendingEvents.set(req, disposable);
        }
        _handleEventMessage(msg) {
          if (!this._pendingEmitters.has(msg.req)) {
            console.warn("Got event for unknown req");
            return;
          }
          this._pendingEmitters.get(msg.req).fire(msg.event);
        }
        _handleUnsubscribeEventMessage(msg) {
          if (!this._pendingEvents.has(msg.req)) {
            console.warn("Got unsubscribe for unknown req");
            return;
          }
          this._pendingEvents.get(msg.req).dispose();
          this._pendingEvents.delete(msg.req);
        }
        _send(msg) {
          const transfer = [];
          if (msg.type === 0) {
            for (let i = 0; i < msg.args.length; i++) {
              if (msg.args[i] instanceof ArrayBuffer) {
                transfer.push(msg.args[i]);
              }
            }
          } else if (msg.type === 1) {
            if (msg.res instanceof ArrayBuffer) {
              transfer.push(msg.res);
            }
          }
          this._handler.sendMessage(msg, transfer);
        }
      };
      SimpleWorkerServer = class {
        constructor(postMessage, requestHandlerFactory) {
          this._requestHandlerFactory = requestHandlerFactory;
          this._requestHandler = null;
          this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
              postMessage(msg, transfer);
            },
            handleMessage: (method, args) => this._handleMessage(method, args),
            handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
          });
        }
        onmessage(msg) {
          this._protocol.handleMessage(msg);
        }
        _handleMessage(method, args) {
          if (method === INITIALIZE) {
            return this.initialize(args[0], args[1], args[2], args[3]);
          }
          if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
            return Promise.reject(new Error("Missing requestHandler or method: " + method));
          }
          try {
            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
          } catch (e) {
            return Promise.reject(e);
          }
        }
        _handleEvent(eventName, arg) {
          if (!this._requestHandler) {
            throw new Error(`Missing requestHandler`);
          }
          if (propertyIsDynamicEvent(eventName)) {
            const event = this._requestHandler[eventName].call(this._requestHandler, arg);
            if (typeof event !== "function") {
              throw new Error(`Missing dynamic event ${eventName} on request handler.`);
            }
            return event;
          }
          if (propertyIsEvent(eventName)) {
            const event = this._requestHandler[eventName];
            if (typeof event !== "function") {
              throw new Error(`Missing event ${eventName} on request handler.`);
            }
            return event;
          }
          throw new Error(`Malformed event name ${eventName}`);
        }
        initialize(workerId, loaderConfig, moduleId, hostMethods) {
          this._protocol.setWorkerId(workerId);
          const proxyMethodRequest = (method, args) => {
            return this._protocol.sendMessage(method, args);
          };
          const proxyListen = (eventName, arg) => {
            return this._protocol.listen(eventName, arg);
          };
          const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
          if (this._requestHandlerFactory) {
            this._requestHandler = this._requestHandlerFactory(hostProxy);
            return Promise.resolve(getAllMethodNames(this._requestHandler));
          }
          if (loaderConfig) {
            if (typeof loaderConfig.baseUrl !== "undefined") {
              delete loaderConfig["baseUrl"];
            }
            if (typeof loaderConfig.paths !== "undefined") {
              if (typeof loaderConfig.paths.vs !== "undefined") {
                delete loaderConfig.paths["vs"];
              }
            }
            if (typeof loaderConfig.trustedTypesPolicy !== void 0) {
              delete loaderConfig["trustedTypesPolicy"];
            }
            loaderConfig.catchError = true;
            globals.require.config(loaderConfig);
          }
          return new Promise((resolve2, reject) => {
            const req = globals.require;
            req([moduleId], (module) => {
              this._requestHandler = module.create(hostProxy);
              if (!this._requestHandler) {
                reject(new Error(`No RequestHandler!`));
                return;
              }
              resolve2(getAllMethodNames(this._requestHandler));
            }, reject);
          });
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
  var DiffChange;
  var init_diffChange = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js"() {
      DiffChange = class {
        constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
          this.originalStart = originalStart;
          this.originalLength = originalLength;
          this.modifiedStart = modifiedStart;
          this.modifiedLength = modifiedLength;
        }
        getOriginalEnd() {
          return this.originalStart + this.originalLength;
        }
        getModifiedEnd() {
          return this.modifiedStart + this.modifiedLength;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
      hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value << bits | (mask & value) >>> delta) >>> 0;
  }
  function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    while (value.length < length) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1;
  var init_hash = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/hash.js"() {
      init_strings();
      StringSHA1 = class {
        constructor() {
          this._h0 = 1732584193;
          this._h1 = 4023233417;
          this._h2 = 2562383102;
          this._h3 = 271733878;
          this._h4 = 3285377520;
          this._buff = new Uint8Array(64 + 3);
          this._buffDV = new DataView(this._buff.buffer);
          this._buffLen = 0;
          this._totalLen = 0;
          this._leftoverHighSurrogate = 0;
          this._finished = false;
        }
        update(str) {
          const strLen = str.length;
          if (strLen === 0) {
            return;
          }
          const buff = this._buff;
          let buffLen = this._buffLen;
          let leftoverHighSurrogate = this._leftoverHighSurrogate;
          let charCode;
          let offset;
          if (leftoverHighSurrogate !== 0) {
            charCode = leftoverHighSurrogate;
            offset = -1;
            leftoverHighSurrogate = 0;
          } else {
            charCode = str.charCodeAt(0);
            offset = 0;
          }
          while (true) {
            let codePoint = charCode;
            if (isHighSurrogate(charCode)) {
              if (offset + 1 < strLen) {
                const nextCharCode = str.charCodeAt(offset + 1);
                if (isLowSurrogate(nextCharCode)) {
                  offset++;
                  codePoint = computeCodePoint(charCode, nextCharCode);
                } else {
                  codePoint = 65533;
                }
              } else {
                leftoverHighSurrogate = charCode;
                break;
              }
            } else if (isLowSurrogate(charCode)) {
              codePoint = 65533;
            }
            buffLen = this._push(buff, buffLen, codePoint);
            offset++;
            if (offset < strLen) {
              charCode = str.charCodeAt(offset);
            } else {
              break;
            }
          }
          this._buffLen = buffLen;
          this._leftoverHighSurrogate = leftoverHighSurrogate;
        }
        _push(buff, buffLen, codePoint) {
          if (codePoint < 128) {
            buff[buffLen++] = codePoint;
          } else if (codePoint < 2048) {
            buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else if (codePoint < 65536) {
            buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else {
            buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
            buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          }
          if (buffLen >= 64) {
            this._step();
            buffLen -= 64;
            this._totalLen += 64;
            buff[0] = buff[64 + 0];
            buff[1] = buff[64 + 1];
            buff[2] = buff[64 + 2];
          }
          return buffLen;
        }
        digest() {
          if (!this._finished) {
            this._finished = true;
            if (this._leftoverHighSurrogate) {
              this._leftoverHighSurrogate = 0;
              this._buffLen = this._push(this._buff, this._buffLen, 65533);
            }
            this._totalLen += this._buffLen;
            this._wrapUp();
          }
          return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
        }
        _wrapUp() {
          this._buff[this._buffLen++] = 128;
          fill(this._buff, this._buffLen);
          if (this._buffLen > 56) {
            this._step();
            fill(this._buff);
          }
          const ml = 8 * this._totalLen;
          this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
          this._buffDV.setUint32(60, ml % 4294967296, false);
          this._step();
        }
        _step() {
          const bigBlock32 = StringSHA1._bigBlock32;
          const data = this._buffDV;
          for (let j = 0; j < 64; j += 4) {
            bigBlock32.setUint32(j, data.getUint32(j, false), false);
          }
          for (let j = 64; j < 320; j += 4) {
            bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
          }
          let a = this._h0;
          let b = this._h1;
          let c = this._h2;
          let d = this._h3;
          let e = this._h4;
          let f, k;
          let temp;
          for (let j = 0; j < 80; j++) {
            if (j < 20) {
              f = b & c | ~b & d;
              k = 1518500249;
            } else if (j < 40) {
              f = b ^ c ^ d;
              k = 1859775393;
            } else if (j < 60) {
              f = b & c | b & d | c & d;
              k = 2400959708;
            } else {
              f = b ^ c ^ d;
              k = 3395469782;
            }
            temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
          }
          this._h0 = this._h0 + a & 4294967295;
          this._h1 = this._h1 + b & 4294967295;
          this._h2 = this._h2 + c & 4294967295;
          this._h3 = this._h3 + d & 4294967295;
          this._h4 = this._h4 + e & 4294967295;
        }
      };
      StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var StringDiffSequence, Debug, MyArray, DiffChangeHelper, LcsDiff;
  var init_diff = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"() {
      init_diffChange();
      init_hash();
      StringDiffSequence = class {
        constructor(source) {
          this.source = source;
        }
        getElements() {
          const source = this.source;
          const characters = new Int32Array(source.length);
          for (let i = 0, len = source.length; i < len; i++) {
            characters[i] = source.charCodeAt(i);
          }
          return characters;
        }
      };
      Debug = class {
        static Assert(condition, message) {
          if (!condition) {
            throw new Error(message);
          }
        }
      };
      MyArray = class {
        static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
          for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
          }
        }
        static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
          for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
          }
        }
      };
      DiffChangeHelper = class {
        constructor() {
          this.m_changes = [];
          this.m_originalStart = 1073741824;
          this.m_modifiedStart = 1073741824;
          this.m_originalCount = 0;
          this.m_modifiedCount = 0;
        }
        MarkNextChange() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
          }
          this.m_originalCount = 0;
          this.m_modifiedCount = 0;
          this.m_originalStart = 1073741824;
          this.m_modifiedStart = 1073741824;
        }
        AddOriginalElement(originalIndex, modifiedIndex) {
          this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
          this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
          this.m_originalCount++;
        }
        AddModifiedElement(originalIndex, modifiedIndex) {
          this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
          this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
          this.m_modifiedCount++;
        }
        getChanges() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.MarkNextChange();
          }
          return this.m_changes;
        }
        getReverseChanges() {
          if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            this.MarkNextChange();
          }
          this.m_changes.reverse();
          return this.m_changes;
        }
      };
      LcsDiff = class {
        constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
          this.ContinueProcessingPredicate = continueProcessingPredicate;
          this._originalSequence = originalSequence;
          this._modifiedSequence = modifiedSequence;
          const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
          const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
          this._hasStrings = originalHasStrings && modifiedHasStrings;
          this._originalStringElements = originalStringElements;
          this._originalElementsOrHash = originalElementsOrHash;
          this._modifiedStringElements = modifiedStringElements;
          this._modifiedElementsOrHash = modifiedElementsOrHash;
          this.m_forwardHistory = [];
          this.m_reverseHistory = [];
        }
        static _isStringArray(arr) {
          return arr.length > 0 && typeof arr[0] === "string";
        }
        static _getElements(sequence) {
          const elements = sequence.getElements();
          if (LcsDiff._isStringArray(elements)) {
            const hashes = new Int32Array(elements.length);
            for (let i = 0, len = elements.length; i < len; i++) {
              hashes[i] = stringHash(elements[i], 0);
            }
            return [elements, hashes, true];
          }
          if (elements instanceof Int32Array) {
            return [[], elements, false];
          }
          return [[], new Int32Array(elements), false];
        }
        ElementsAreEqual(originalIndex, newIndex) {
          if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
            return false;
          }
          return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
        }
        ElementsAreStrictEqual(originalIndex, newIndex) {
          if (!this.ElementsAreEqual(originalIndex, newIndex)) {
            return false;
          }
          const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);
          const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
          return originalElement === modifiedElement;
        }
        static _getStrictElement(sequence, index) {
          if (typeof sequence.getStrictElement === "function") {
            return sequence.getStrictElement(index);
          }
          return null;
        }
        OriginalElementsAreEqual(index1, index2) {
          if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
            return false;
          }
          return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
        }
        ModifiedElementsAreEqual(index1, index2) {
          if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
            return false;
          }
          return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
        }
        ComputeDiff(pretty) {
          return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
        }
        _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
          const quitEarlyArr = [false];
          let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
          if (pretty) {
            changes = this.PrettifyChanges(changes);
          }
          return {
            quitEarly: quitEarlyArr[0],
            changes
          };
        }
        ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
          quitEarlyArr[0] = false;
          while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
            originalStart++;
            modifiedStart++;
          }
          while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
            originalEnd--;
            modifiedEnd--;
          }
          if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
            let changes;
            if (modifiedStart <= modifiedEnd) {
              Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
              changes = [
                new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
              ];
            } else if (originalStart <= originalEnd) {
              Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
              changes = [
                new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
              ];
            } else {
              Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
              Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
              changes = [];
            }
            return changes;
          }
          const midOriginalArr = [0];
          const midModifiedArr = [0];
          const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
          const midOriginal = midOriginalArr[0];
          const midModified = midModifiedArr[0];
          if (result !== null) {
            return result;
          } else if (!quitEarlyArr[0]) {
            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
            let rightChanges = [];
            if (!quitEarlyArr[0]) {
              rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
            } else {
              rightChanges = [
                new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
              ];
            }
            return this.ConcatenateChanges(leftChanges, rightChanges);
          }
          return [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        }
        WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
          let forwardChanges = null;
          let reverseChanges = null;
          let changeHelper = new DiffChangeHelper();
          let diagonalMin = diagonalForwardStart;
          let diagonalMax = diagonalForwardEnd;
          let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
          let lastOriginalIndex = -1073741824;
          let historyIndex = this.m_forwardHistory.length - 1;
          do {
            const diagonal = diagonalRelative + diagonalForwardBase;
            if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
              originalIndex = forwardPoints[diagonal + 1];
              modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
              if (originalIndex < lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex;
              changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
              diagonalRelative = diagonal + 1 - diagonalForwardBase;
            } else {
              originalIndex = forwardPoints[diagonal - 1] + 1;
              modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
              if (originalIndex < lastOriginalIndex) {
                changeHelper.MarkNextChange();
              }
              lastOriginalIndex = originalIndex - 1;
              changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
              diagonalRelative = diagonal - 1 - diagonalForwardBase;
            }
            if (historyIndex >= 0) {
              forwardPoints = this.m_forwardHistory[historyIndex];
              diagonalForwardBase = forwardPoints[0];
              diagonalMin = 1;
              diagonalMax = forwardPoints.length - 1;
            }
          } while (--historyIndex >= -1);
          forwardChanges = changeHelper.getReverseChanges();
          if (quitEarlyArr[0]) {
            let originalStartPoint = midOriginalArr[0] + 1;
            let modifiedStartPoint = midModifiedArr[0] + 1;
            if (forwardChanges !== null && forwardChanges.length > 0) {
              const lastForwardChange = forwardChanges[forwardChanges.length - 1];
              originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
              modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
            }
            reverseChanges = [
              new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
            ];
          } else {
            changeHelper = new DiffChangeHelper();
            diagonalMin = diagonalReverseStart;
            diagonalMax = diagonalReverseEnd;
            diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
            lastOriginalIndex = 1073741824;
            historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
              const diagonal = diagonalRelative + diagonalReverseBase;
              if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
                originalIndex = reversePoints[diagonal + 1] - 1;
                modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                if (originalIndex > lastOriginalIndex) {
                  changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex + 1;
                changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                diagonalRelative = diagonal + 1 - diagonalReverseBase;
              } else {
                originalIndex = reversePoints[diagonal - 1];
                modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                if (originalIndex > lastOriginalIndex) {
                  changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex;
                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                diagonalRelative = diagonal - 1 - diagonalReverseBase;
              }
              if (historyIndex >= 0) {
                reversePoints = this.m_reverseHistory[historyIndex];
                diagonalReverseBase = reversePoints[0];
                diagonalMin = 1;
                diagonalMax = reversePoints.length - 1;
              }
            } while (--historyIndex >= -1);
            reverseChanges = changeHelper.getChanges();
          }
          return this.ConcatenateChanges(forwardChanges, reverseChanges);
        }
        ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
          let originalIndex = 0, modifiedIndex = 0;
          let diagonalForwardStart = 0, diagonalForwardEnd = 0;
          let diagonalReverseStart = 0, diagonalReverseEnd = 0;
          originalStart--;
          modifiedStart--;
          midOriginalArr[0] = 0;
          midModifiedArr[0] = 0;
          this.m_forwardHistory = [];
          this.m_reverseHistory = [];
          const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
          const numDiagonals = maxDifferences + 1;
          const forwardPoints = new Int32Array(numDiagonals);
          const reversePoints = new Int32Array(numDiagonals);
          const diagonalForwardBase = modifiedEnd - modifiedStart;
          const diagonalReverseBase = originalEnd - originalStart;
          const diagonalForwardOffset = originalStart - modifiedStart;
          const diagonalReverseOffset = originalEnd - modifiedEnd;
          const delta = diagonalReverseBase - diagonalForwardBase;
          const deltaIsEven = delta % 2 === 0;
          forwardPoints[diagonalForwardBase] = originalStart;
          reversePoints[diagonalReverseBase] = originalEnd;
          quitEarlyArr[0] = false;
          for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
            let furthestOriginalIndex = 0;
            let furthestModifiedIndex = 0;
            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
              if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
                originalIndex = forwardPoints[diagonal + 1];
              } else {
                originalIndex = forwardPoints[diagonal - 1] + 1;
              }
              modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
              const tempOriginalIndex = originalIndex;
              while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                originalIndex++;
                modifiedIndex++;
              }
              forwardPoints[diagonal] = originalIndex;
              if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                furthestOriginalIndex = originalIndex;
                furthestModifiedIndex = modifiedIndex;
              }
              if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
                if (originalIndex >= reversePoints[diagonal]) {
                  midOriginalArr[0] = originalIndex;
                  midModifiedArr[0] = modifiedIndex;
                  if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                  } else {
                    return null;
                  }
                }
              }
            }
            const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
              quitEarlyArr[0] = true;
              midOriginalArr[0] = furthestOriginalIndex;
              midModifiedArr[0] = furthestModifiedIndex;
              if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                originalStart++;
                modifiedStart++;
                return [
                  new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                ];
              }
            }
            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
              if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
                originalIndex = reversePoints[diagonal + 1] - 1;
              } else {
                originalIndex = reversePoints[diagonal - 1];
              }
              modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
              const tempOriginalIndex = originalIndex;
              while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                originalIndex--;
                modifiedIndex--;
              }
              reversePoints[diagonal] = originalIndex;
              if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                if (originalIndex <= forwardPoints[diagonal]) {
                  midOriginalArr[0] = originalIndex;
                  midModifiedArr[0] = modifiedIndex;
                  if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                  } else {
                    return null;
                  }
                }
              }
            }
            if (numDifferences <= 1447) {
              let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
              temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
              MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
              this.m_forwardHistory.push(temp);
              temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
              temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
              MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
              this.m_reverseHistory.push(temp);
            }
          }
          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        }
        PrettifyChanges(changes) {
          for (let i = 0; i < changes.length; i++) {
            const change = changes[i];
            const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
            const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
              const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
              const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
              if (endStrictEqual && !startStrictEqual) {
                break;
              }
              change.originalStart++;
              change.modifiedStart++;
            }
            const mergedChangeArr = [null];
            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
              changes[i] = mergedChangeArr[0];
              changes.splice(i + 1, 1);
              i--;
              continue;
            }
          }
          for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            let originalStop = 0;
            let modifiedStop = 0;
            if (i > 0) {
              const prevChange = changes[i - 1];
              originalStop = prevChange.originalStart + prevChange.originalLength;
              modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
            }
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            let bestDelta = 0;
            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
            for (let delta = 1; ; delta++) {
              const originalStart = change.originalStart - delta;
              const modifiedStart = change.modifiedStart - delta;
              if (originalStart < originalStop || modifiedStart < modifiedStop) {
                break;
              }
              if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
                break;
              }
              if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
                break;
              }
              const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
              const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
              if (score2 > bestScore) {
                bestScore = score2;
                bestDelta = delta;
              }
            }
            change.originalStart -= bestDelta;
            change.modifiedStart -= bestDelta;
            const mergedChangeArr = [null];
            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
              changes[i - 1] = mergedChangeArr[0];
              changes.splice(i, 1);
              i++;
              continue;
            }
          }
          if (this._hasStrings) {
            for (let i = 1, len = changes.length; i < len; i++) {
              const aChange = changes[i - 1];
              const bChange = changes[i];
              const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
              const aOriginalStart = aChange.originalStart;
              const bOriginalEnd = bChange.originalStart + bChange.originalLength;
              const abOriginalLength = bOriginalEnd - aOriginalStart;
              const aModifiedStart = aChange.modifiedStart;
              const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
              const abModifiedLength = bModifiedEnd - aModifiedStart;
              if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
                const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
                if (t) {
                  const [originalMatchStart, modifiedMatchStart] = t;
                  if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                    aChange.originalLength = originalMatchStart - aChange.originalStart;
                    aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                    bChange.originalStart = originalMatchStart + matchedLength;
                    bChange.modifiedStart = modifiedMatchStart + matchedLength;
                    bChange.originalLength = bOriginalEnd - bChange.originalStart;
                    bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
                  }
                }
              }
            }
          }
          return changes;
        }
        _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
          if (originalLength < desiredLength || modifiedLength < desiredLength) {
            return null;
          }
          const originalMax = originalStart + originalLength - desiredLength + 1;
          const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
          let bestScore = 0;
          let bestOriginalStart = 0;
          let bestModifiedStart = 0;
          for (let i = originalStart; i < originalMax; i++) {
            for (let j = modifiedStart; j < modifiedMax; j++) {
              const score2 = this._contiguousSequenceScore(i, j, desiredLength);
              if (score2 > 0 && score2 > bestScore) {
                bestScore = score2;
                bestOriginalStart = i;
                bestModifiedStart = j;
              }
            }
          }
          if (bestScore > 0) {
            return [bestOriginalStart, bestModifiedStart];
          }
          return null;
        }
        _contiguousSequenceScore(originalStart, modifiedStart, length) {
          let score2 = 0;
          for (let l = 0; l < length; l++) {
            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
              return 0;
            }
            score2 += this._originalStringElements[originalStart + l].length;
          }
          return score2;
        }
        _OriginalIsBoundary(index) {
          if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
            return true;
          }
          return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
        }
        _OriginalRegionIsBoundary(originalStart, originalLength) {
          if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
            return true;
          }
          if (originalLength > 0) {
            const originalEnd = originalStart + originalLength;
            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
              return true;
            }
          }
          return false;
        }
        _ModifiedIsBoundary(index) {
          if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
            return true;
          }
          return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
        }
        _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
          if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
            return true;
          }
          if (modifiedLength > 0) {
            const modifiedEnd = modifiedStart + modifiedLength;
            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
              return true;
            }
          }
          return false;
        }
        _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
          const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
          const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
          return originalScore + modifiedScore;
        }
        ConcatenateChanges(left, right) {
          const mergedChangeArr = [];
          if (left.length === 0 || right.length === 0) {
            return right.length > 0 ? right : left;
          } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
            const result = new Array(left.length + right.length - 1);
            MyArray.Copy(left, 0, result, 0, left.length - 1);
            result[left.length - 1] = mergedChangeArr[0];
            MyArray.Copy(right, 1, result, left.length, right.length - 1);
            return result;
          } else {
            const result = new Array(left.length + right.length);
            MyArray.Copy(left, 0, result, 0, left.length);
            MyArray.Copy(right, 0, result, left.length, right.length);
            return result;
          }
        }
        ChangesOverlap(left, right, mergedChangeArr) {
          Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
          Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
          if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            const originalStart = left.originalStart;
            let originalLength = left.originalLength;
            const modifiedStart = left.modifiedStart;
            let modifiedLength = left.modifiedLength;
            if (left.originalStart + left.originalLength >= right.originalStart) {
              originalLength = right.originalStart + right.originalLength - left.originalStart;
            }
            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
              modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
            }
            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
            return true;
          } else {
            mergedChangeArr[0] = null;
            return false;
          }
        }
        ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
          if (diagonal >= 0 && diagonal < numDiagonals) {
            return diagonal;
          }
          const diagonalsBelow = diagonalBaseIndex;
          const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
          const diffEven = numDifferences % 2 === 0;
          if (diagonal < 0) {
            const lowerBoundEven = diagonalsBelow % 2 === 0;
            return diffEven === lowerBoundEven ? 0 : 1;
          } else {
            const upperBoundEven = diagonalsAbove % 2 === 0;
            return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess, cwd, env, platform;
  var init_process = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/process.js"() {
      init_platform();
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        const sandboxProcess = globals.vscode.process;
        safeProcess = {
          get platform() {
            return sandboxProcess.platform;
          },
          get arch() {
            return sandboxProcess.arch;
          },
          get env() {
            return sandboxProcess.env;
          },
          cwd() {
            return sandboxProcess.cwd();
          }
        };
      } else if (typeof process !== "undefined") {
        safeProcess = {
          get platform() {
            return process.platform;
          },
          get arch() {
            return process.arch;
          },
          get env() {
            return process.env;
          },
          cwd() {
            return process.env["VSCODE_CWD"] || process.cwd();
          }
        };
      } else {
        safeProcess = {
          get platform() {
            return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
          },
          get arch() {
            return void 0;
          },
          get env() {
            return {};
          },
          cwd() {
            return "/";
          }
        };
      }
      cwd = safeProcess.cwd;
      env = safeProcess.env;
      platform = safeProcess.platform;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/path.js
  function validateObject(pathObject, name) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType(name, "Object", pathObject);
    }
  }
  function validateString(value, name) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name, "string", value);
    }
  }
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (isPathSeparator2(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i)}`;
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format2(sep2, pathObject) {
    validateObject(pathObject, "pathObject");
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_COLON, CHAR_QUESTION_MARK, ErrorInvalidArgType, platformIsWin32, win32, posixCwd, posix, normalize, resolve, relative, dirname, basename, extname, sep;
  var init_path = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/path.js"() {
      init_process();
      CHAR_UPPERCASE_A = 65;
      CHAR_LOWERCASE_A = 97;
      CHAR_UPPERCASE_Z = 90;
      CHAR_LOWERCASE_Z = 122;
      CHAR_DOT = 46;
      CHAR_FORWARD_SLASH = 47;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_COLON = 58;
      CHAR_QUESTION_MARK = 63;
      ErrorInvalidArgType = class extends Error {
        constructor(name, expected, actual) {
          let determiner;
          if (typeof expected === "string" && expected.indexOf("not ") === 0) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          const type = name.indexOf(".") !== -1 ? "property" : "argument";
          let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
          msg += `. Received type ${typeof actual}`;
          super(msg);
          this.code = "ERR_INVALID_ARG_TYPE";
        }
      };
      platformIsWin32 = platform === "win32";
      win32 = {
        resolve(...pathSegments) {
          let resolvedDevice = "";
          let resolvedTail = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
              path = pathSegments[i];
              validateString(path, "path");
              if (path.length === 0) {
                continue;
              }
            } else if (resolvedDevice.length === 0) {
              path = cwd();
            } else {
              path = env[`=${resolvedDevice}`] || cwd();
              if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
                path = `${resolvedDevice}\\`;
              }
            }
            const len = path.length;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len === 1) {
              if (isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
              }
            } else if (isPathSeparator(code)) {
              isAbsolute = true;
              if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  const firstPart = path.slice(last, j);
                  last = j;
                  while (j < len && isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j < len && j !== last) {
                    last = j;
                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                      j++;
                    }
                    if (j === len || j !== last) {
                      device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                      rootEnd = j;
                    }
                  }
                }
              } else {
                rootEnd = 1;
              }
            } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
              device = path.slice(0, 2);
              rootEnd = 2;
              if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                isAbsolute = true;
                rootEnd = 3;
              }
            }
            if (device.length > 0) {
              if (resolvedDevice.length > 0) {
                if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                  continue;
                }
              } else {
                resolvedDevice = device;
              }
            }
            if (resolvedAbsolute) {
              if (resolvedDevice.length > 0) {
                break;
              }
            } else {
              resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
              resolvedAbsolute = isAbsolute;
              if (isAbsolute && resolvedDevice.length > 0) {
                break;
              }
            }
          }
          resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
          return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
        },
        normalize(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = 0;
          let device;
          let isAbsolute = false;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPosixPathSeparator(code) ? "\\" : path;
          }
          if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                const firstPart = path.slice(last, j);
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return `\\\\${firstPart}\\${path.slice(last)}\\`;
                  }
                  if (j !== last) {
                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                    rootEnd = j;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
              isAbsolute = true;
              rootEnd = 3;
            }
          }
          let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator) : "";
          if (tail.length === 0 && !isAbsolute) {
            tail = ".";
          }
          if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
          }
          if (device === void 0) {
            return isAbsolute ? `\\${tail}` : tail;
          }
          return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
        },
        isAbsolute(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return false;
          }
          const code = path.charCodeAt(0);
          return isPathSeparator(code) || len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          let firstPart;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = firstPart = arg;
              } else {
                joined += `\\${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          let needsReplace = true;
          let slashCount = 0;
          if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
              ++slashCount;
              if (firstLen > 2) {
                if (isPathSeparator(firstPart.charCodeAt(2))) {
                  ++slashCount;
                } else {
                  needsReplace = false;
                }
              }
            }
          }
          if (needsReplace) {
            while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
              slashCount++;
            }
            if (slashCount >= 2) {
              joined = `\\${joined.slice(slashCount)}`;
            }
          }
          return win32.normalize(joined);
        },
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          const fromOrig = win32.resolve(from);
          const toOrig = win32.resolve(to);
          if (fromOrig === toOrig) {
            return "";
          }
          from = fromOrig.toLowerCase();
          to = toOrig.toLowerCase();
          if (from === to) {
            return "";
          }
          let fromStart = 0;
          while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
            fromStart++;
          }
          let fromEnd = from.length;
          while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
            fromEnd--;
          }
          const fromLen = fromEnd - fromStart;
          let toStart = 0;
          while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            toStart++;
          }
          let toEnd = to.length;
          while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
            toEnd--;
          }
          const toLen = toEnd - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_BACKWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i !== length) {
            if (lastCommonSep === -1) {
              return toOrig;
            }
          } else {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                return toOrig.slice(toStart + i + 1);
              }
              if (i === 2) {
                return toOrig.slice(toStart + i);
              }
            }
            if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 2) {
                lastCommonSep = 3;
              }
            }
            if (lastCommonSep === -1) {
              lastCommonSep = 0;
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
              out += out.length === 0 ? ".." : "\\..";
            }
          }
          toStart += lastCommonSep;
          if (out.length > 0) {
            return `${out}${toOrig.slice(toStart, toEnd)}`;
          }
          if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            ++toStart;
          }
          return toOrig.slice(toStart, toEnd);
        },
        toNamespacedPath(path) {
          if (typeof path !== "string" || path.length === 0) {
            return path;
          }
          const resolvedPath = win32.resolve(path);
          if (resolvedPath.length <= 2) {
            return path;
          }
          if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
              const code = resolvedPath.charCodeAt(2);
              if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
              }
            }
          } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            return `\\\\?\\${resolvedPath}`;
          }
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = -1;
          let offset = 0;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPathSeparator(code) ? path : ".";
          }
          if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return path;
                  }
                  if (j !== last) {
                    rootEnd = offset = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
            offset = rootEnd;
          }
          let end = -1;
          let matchedSlash = true;
          for (let i = len - 1; i >= offset; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            if (rootEnd === -1) {
              return ".";
            }
            end = rootEnd;
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
            start = 2;
          }
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
              const code = path.charCodeAt(i);
              if (isPathSeparator(code)) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= start; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let start = 0;
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
          }
          for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format2.bind(null, "\\"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const len = path.length;
          let rootEnd = 0;
          let code = path.charCodeAt(0);
          if (len === 1) {
            if (isPathSeparator(code)) {
              ret.root = ret.dir = path;
              return ret;
            }
            ret.base = ret.name = path;
            return ret;
          }
          if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    rootEnd = j;
                  } else if (j !== last) {
                    rootEnd = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            if (len <= 2) {
              ret.root = ret.dir = path;
              return ret;
            }
            rootEnd = 2;
            if (isPathSeparator(path.charCodeAt(2))) {
              if (len === 3) {
                ret.root = ret.dir = path;
                return ret;
              }
              rootEnd = 3;
            }
          }
          if (rootEnd > 0) {
            ret.root = path.slice(0, rootEnd);
          }
          let startDot = -1;
          let startPart = rootEnd;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(startPart, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
          } else {
            ret.dir = ret.root;
          }
          return ret;
        },
        sep: "\\",
        delimiter: ";",
        win32: null,
        posix: null
      };
      posixCwd = (() => {
        if (platformIsWin32) {
          const regexp = /\\/g;
          return () => {
            const cwd2 = cwd().replace(regexp, "/");
            return cwd2.slice(cwd2.indexOf("/"));
          };
        }
        return () => cwd();
      })();
      posix = {
        resolve(...pathSegments) {
          let resolvedPath = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            const path = i >= 0 ? pathSegments[i] : posixCwd();
            validateString(path, "path");
            if (path.length === 0) {
              continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          }
          resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
          if (resolvedAbsolute) {
            return `/${resolvedPath}`;
          }
          return resolvedPath.length > 0 ? resolvedPath : ".";
        },
        normalize(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
          path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
          if (path.length === 0) {
            if (isAbsolute) {
              return "/";
            }
            return trailingSeparator ? "./" : ".";
          }
          if (trailingSeparator) {
            path += "/";
          }
          return isAbsolute ? `/${path}` : path;
        },
        isAbsolute(path) {
          validateString(path, "path");
          return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = arg;
              } else {
                joined += `/${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return posix.normalize(joined);
        },
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to) {
            return "";
          }
          const fromStart = 1;
          const fromEnd = from.length;
          const fromLen = fromEnd - fromStart;
          const toStart = 1;
          const toLen = to.length - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_FORWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                return to.slice(toStart + i + 1);
              }
              if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              out += out.length === 0 ? ".." : "/..";
            }
          }
          return `${out}${to.slice(toStart + lastCommonSep)}`;
        },
        toNamespacedPath(path) {
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let end = -1;
          let matchedSlash = true;
          for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            return hasRoot ? "/" : ".";
          }
          if (hasRoot && end === 1) {
            return "//";
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
              const code = path.charCodeAt(i);
              if (code === CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format2.bind(null, "/"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let start;
          if (isAbsolute) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            const start2 = startPart === 0 && isAbsolute ? 1 : startPart;
            if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(start2, end);
            } else {
              ret.name = path.slice(start2, startDot);
              ret.base = path.slice(start2, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0) {
            ret.dir = path.slice(0, startPart - 1);
          } else if (isAbsolute) {
            ret.dir = "/";
          }
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix.win32 = win32.win32 = win32;
      posix.posix = win32.posix = posix;
      normalize = platformIsWin32 ? win32.normalize : posix.normalize;
      resolve = platformIsWin32 ? win32.resolve : posix.resolve;
      relative = platformIsWin32 ? win32.relative : posix.relative;
      dirname = platformIsWin32 ? win32.dirname : posix.dirname;
      basename = platformIsWin32 ? win32.basename : posix.basename;
      extname = platformIsWin32 ? win32.extname : posix.extname;
      sep = platformIsWin32 ? win32.sep : posix.sep;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/uri.js
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code = path.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value = uri.path.substr(1);
      }
    } else {
      value = uri.path;
    }
    if (isWindows) {
      value = value.replace(/\//g, "\\");
    }
    return value;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false, false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false, true);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(authority, false, true);
      } else {
        res += encoder(authority.substr(0, idx), false, true);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code = path.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code = path.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true, false);
    }
    if (query) {
      res += "?";
      res += encoder(query, false, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a3) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }
  var _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, Uri, encodeTable, _rEncodedAsHex;
  var init_uri = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/uri.js"() {
      init_path();
      init_platform();
      _schemePattern = /^\w[\w\d+.-]*$/;
      _singleSlashStart = /^\//;
      _doubleSlashStart = /^\/\//;
      _empty = "";
      _slash = "/";
      _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      URI = class {
        static isUri(thing) {
          if (thing instanceof URI) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
        }
        constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
          if (typeof schemeOrData === "object") {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
          } else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
          }
        }
        get fsPath() {
          return uriToFsPath(this, false);
        }
        with(change) {
          if (!change) {
            return this;
          }
          let { scheme, authority, path, query, fragment } = change;
          if (scheme === void 0) {
            scheme = this.scheme;
          } else if (scheme === null) {
            scheme = _empty;
          }
          if (authority === void 0) {
            authority = this.authority;
          } else if (authority === null) {
            authority = _empty;
          }
          if (path === void 0) {
            path = this.path;
          } else if (path === null) {
            path = _empty;
          }
          if (query === void 0) {
            query = this.query;
          } else if (query === null) {
            query = _empty;
          }
          if (fragment === void 0) {
            fragment = this.fragment;
          } else if (fragment === null) {
            fragment = _empty;
          }
          if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
            return this;
          }
          return new Uri(scheme, authority, path, query, fragment);
        }
        static parse(value, _strict = false) {
          const match = _regexp.exec(value);
          if (!match) {
            return new Uri(_empty, _empty, _empty, _empty, _empty);
          }
          return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
        }
        static file(path) {
          let authority = _empty;
          if (isWindows) {
            path = path.replace(/\\/g, _slash);
          }
          if (path[0] === _slash && path[1] === _slash) {
            const idx = path.indexOf(_slash, 2);
            if (idx === -1) {
              authority = path.substring(2);
              path = _slash;
            } else {
              authority = path.substring(2, idx);
              path = path.substring(idx) || _slash;
            }
          }
          return new Uri("file", authority, path, _empty, _empty);
        }
        static from(components) {
          const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
          _validateUri(result, true);
          return result;
        }
        static joinPath(uri, ...pathFragment) {
          if (!uri.path) {
            throw new Error(`[UriError]: cannot call joinPath on URI without path`);
          }
          let newPath;
          if (isWindows && uri.scheme === "file") {
            newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
          } else {
            newPath = posix.join(uri.path, ...pathFragment);
          }
          return uri.with({ path: newPath });
        }
        toString(skipEncoding = false) {
          return _asFormatted(this, skipEncoding);
        }
        toJSON() {
          return this;
        }
        static revive(data) {
          if (!data) {
            return data;
          } else if (data instanceof URI) {
            return data;
          } else {
            const result = new Uri(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
          }
        }
      };
      _pathSepMarker = isWindows ? 1 : void 0;
      Uri = class extends URI {
        constructor() {
          super(...arguments);
          this._formatted = null;
          this._fsPath = null;
        }
        get fsPath() {
          if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
          }
          return this._fsPath;
        }
        toString(skipEncoding = false) {
          if (!skipEncoding) {
            if (!this._formatted) {
              this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
          } else {
            return _asFormatted(this, true);
          }
        }
        toJSON() {
          const res = {
            $mid: 1
          };
          if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
          }
          if (this._formatted) {
            res.external = this._formatted;
          }
          if (this.path) {
            res.path = this.path;
          }
          if (this.scheme) {
            res.scheme = this.scheme;
          }
          if (this.authority) {
            res.authority = this.authority;
          }
          if (this.query) {
            res.query = this.query;
          }
          if (this.fragment) {
            res.fragment = this.fragment;
          }
          return res;
        }
      };
      encodeTable = {
        [58]: "%3A",
        [47]: "%2F",
        [63]: "%3F",
        [35]: "%23",
        [91]: "%5B",
        [93]: "%5D",
        [64]: "%40",
        [33]: "%21",
        [36]: "%24",
        [38]: "%26",
        [39]: "%27",
        [40]: "%28",
        [41]: "%29",
        [42]: "%2A",
        [43]: "%2B",
        [44]: "%2C",
        [59]: "%3B",
        [61]: "%3D",
        [32]: "%20"
      };
      _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/position.js
  var Position;
  var init_position = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/position.js"() {
      Position = class {
        constructor(lineNumber, column) {
          this.lineNumber = lineNumber;
          this.column = column;
        }
        with(newLineNumber = this.lineNumber, newColumn = this.column) {
          if (newLineNumber === this.lineNumber && newColumn === this.column) {
            return this;
          } else {
            return new Position(newLineNumber, newColumn);
          }
        }
        delta(deltaLineNumber = 0, deltaColumn = 0) {
          return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
        }
        equals(other) {
          return Position.equals(this, other);
        }
        static equals(a, b) {
          if (!a && !b) {
            return true;
          }
          return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
        }
        isBefore(other) {
          return Position.isBefore(this, other);
        }
        static isBefore(a, b) {
          if (a.lineNumber < b.lineNumber) {
            return true;
          }
          if (b.lineNumber < a.lineNumber) {
            return false;
          }
          return a.column < b.column;
        }
        isBeforeOrEqual(other) {
          return Position.isBeforeOrEqual(this, other);
        }
        static isBeforeOrEqual(a, b) {
          if (a.lineNumber < b.lineNumber) {
            return true;
          }
          if (b.lineNumber < a.lineNumber) {
            return false;
          }
          return a.column <= b.column;
        }
        static compare(a, b) {
          const aLineNumber = a.lineNumber | 0;
          const bLineNumber = b.lineNumber | 0;
          if (aLineNumber === bLineNumber) {
            const aColumn = a.column | 0;
            const bColumn = b.column | 0;
            return aColumn - bColumn;
          }
          return aLineNumber - bLineNumber;
        }
        clone() {
          return new Position(this.lineNumber, this.column);
        }
        toString() {
          return "(" + this.lineNumber + "," + this.column + ")";
        }
        static lift(pos) {
          return new Position(pos.lineNumber, pos.column);
        }
        static isIPosition(obj) {
          return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/range.js
  var Range;
  var init_range = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/range.js"() {
      init_position();
      Range = class {
        constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
          if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
            this.startLineNumber = endLineNumber;
            this.startColumn = endColumn;
            this.endLineNumber = startLineNumber;
            this.endColumn = startColumn;
          } else {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
          }
        }
        isEmpty() {
          return Range.isEmpty(this);
        }
        static isEmpty(range) {
          return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
        }
        containsPosition(position) {
          return Range.containsPosition(this, position);
        }
        static containsPosition(range, position) {
          if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
          }
          if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
            return false;
          }
          if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
            return false;
          }
          return true;
        }
        static strictContainsPosition(range, position) {
          if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
          }
          if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
            return false;
          }
          if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
            return false;
          }
          return true;
        }
        containsRange(range) {
          return Range.containsRange(this, range);
        }
        static containsRange(range, otherRange) {
          if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
          }
          if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
          }
          return true;
        }
        strictContainsRange(range) {
          return Range.strictContainsRange(this, range);
        }
        static strictContainsRange(range, otherRange) {
          if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
          }
          if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
            return false;
          }
          if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
            return false;
          }
          return true;
        }
        plusRange(range) {
          return Range.plusRange(this, range);
        }
        static plusRange(a, b) {
          let startLineNumber;
          let startColumn;
          let endLineNumber;
          let endColumn;
          if (b.startLineNumber < a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = b.startColumn;
          } else if (b.startLineNumber === a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = Math.min(b.startColumn, a.startColumn);
          } else {
            startLineNumber = a.startLineNumber;
            startColumn = a.startColumn;
          }
          if (b.endLineNumber > a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = b.endColumn;
          } else if (b.endLineNumber === a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = Math.max(b.endColumn, a.endColumn);
          } else {
            endLineNumber = a.endLineNumber;
            endColumn = a.endColumn;
          }
          return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        intersectRanges(range) {
          return Range.intersectRanges(this, range);
        }
        static intersectRanges(a, b) {
          let resultStartLineNumber = a.startLineNumber;
          let resultStartColumn = a.startColumn;
          let resultEndLineNumber = a.endLineNumber;
          let resultEndColumn = a.endColumn;
          const otherStartLineNumber = b.startLineNumber;
          const otherStartColumn = b.startColumn;
          const otherEndLineNumber = b.endLineNumber;
          const otherEndColumn = b.endColumn;
          if (resultStartLineNumber < otherStartLineNumber) {
            resultStartLineNumber = otherStartLineNumber;
            resultStartColumn = otherStartColumn;
          } else if (resultStartLineNumber === otherStartLineNumber) {
            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
          }
          if (resultEndLineNumber > otherEndLineNumber) {
            resultEndLineNumber = otherEndLineNumber;
            resultEndColumn = otherEndColumn;
          } else if (resultEndLineNumber === otherEndLineNumber) {
            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
          }
          if (resultStartLineNumber > resultEndLineNumber) {
            return null;
          }
          if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
            return null;
          }
          return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        }
        equalsRange(other) {
          return Range.equalsRange(this, other);
        }
        static equalsRange(a, b) {
          if (!a && !b) {
            return true;
          }
          return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
        }
        getEndPosition() {
          return Range.getEndPosition(this);
        }
        static getEndPosition(range) {
          return new Position(range.endLineNumber, range.endColumn);
        }
        getStartPosition() {
          return Range.getStartPosition(this);
        }
        static getStartPosition(range) {
          return new Position(range.startLineNumber, range.startColumn);
        }
        toString() {
          return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
        }
        setEndPosition(endLineNumber, endColumn) {
          return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        setStartPosition(startLineNumber, startColumn) {
          return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        collapseToStart() {
          return Range.collapseToStart(this);
        }
        static collapseToStart(range) {
          return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        }
        collapseToEnd() {
          return Range.collapseToEnd(this);
        }
        static collapseToEnd(range) {
          return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
        }
        delta(lineCount) {
          return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
        }
        static fromPositions(start, end = start) {
          return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        static lift(range) {
          if (!range) {
            return null;
          }
          return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        }
        static isIRange(obj) {
          return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
        }
        static areIntersectingOrTouching(a, b) {
          if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {
            return false;
          }
          if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {
            return false;
          }
          return true;
        }
        static areIntersecting(a, b) {
          if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {
            return false;
          }
          if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {
            return false;
          }
          return true;
        }
        static compareRangesUsingStarts(a, b) {
          if (a && b) {
            const aStartLineNumber = a.startLineNumber | 0;
            const bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
              const aStartColumn = a.startColumn | 0;
              const bStartColumn = b.startColumn | 0;
              if (aStartColumn === bStartColumn) {
                const aEndLineNumber = a.endLineNumber | 0;
                const bEndLineNumber = b.endLineNumber | 0;
                if (aEndLineNumber === bEndLineNumber) {
                  const aEndColumn = a.endColumn | 0;
                  const bEndColumn = b.endColumn | 0;
                  return aEndColumn - bEndColumn;
                }
                return aEndLineNumber - bEndLineNumber;
              }
              return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
          }
          const aExists = a ? 1 : 0;
          const bExists = b ? 1 : 0;
          return aExists - bExists;
        }
        static compareRangesUsingEnds(a, b) {
          if (a.endLineNumber === b.endLineNumber) {
            if (a.endColumn === b.endColumn) {
              if (a.startLineNumber === b.startLineNumber) {
                return a.startColumn - b.startColumn;
              }
              return a.startLineNumber - b.startLineNumber;
            }
            return a.endColumn - b.endColumn;
          }
          return a.endLineNumber - b.endLineNumber;
        }
        static spansMultipleLines(range) {
          return range.endLineNumber > range.startLineNumber;
        }
        toJSON() {
          return this;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/arrays.js
  var CompareResult, CallbackIterable;
  var init_arrays = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/arrays.js"() {
      (function(CompareResult2) {
        function isLessThan(result) {
          return result < 0;
        }
        CompareResult2.isLessThan = isLessThan;
        function isGreaterThan(result) {
          return result > 0;
        }
        CompareResult2.isGreaterThan = isGreaterThan;
        function isNeitherLessOrGreaterThan(result) {
          return result === 0;
        }
        CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
        CompareResult2.greaterThan = 1;
        CompareResult2.lessThan = -1;
        CompareResult2.neitherLessOrGreaterThan = 0;
      })(CompareResult || (CompareResult = {}));
      CallbackIterable = class {
        constructor(iterate) {
          this.iterate = iterate;
        }
        toArray() {
          const result = [];
          this.iterate((item) => {
            result.push(item);
            return true;
          });
          return result;
        }
        filter(predicate) {
          return new CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
        }
        map(mapFn) {
          return new CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
        }
        findLast(predicate) {
          let result;
          this.iterate((item) => {
            if (predicate(item)) {
              result = item;
            }
            return true;
          });
          return result;
        }
        findLastMaxBy(comparator) {
          let result;
          let first = true;
          this.iterate((item) => {
            if (first || CompareResult.isGreaterThan(comparator(item, result))) {
              first = false;
              result = item;
            }
            return true;
          });
          return result;
        }
      };
      CallbackIterable.empty = new CallbackIterable((_callback) => {
      });
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/uint.js
  function toUint8(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 255) {
      return 255;
    }
    return v | 0;
  }
  function toUint32(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 4294967295) {
      return 4294967295;
    }
    return v | 0;
  }
  var init_uint = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/uint.js"() {
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer, PrefixSumIndexOfResult;
  var init_prefixSumComputer = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js"() {
      init_arrays();
      init_uint();
      PrefixSumComputer = class {
        constructor(values) {
          this.values = values;
          this.prefixSum = new Uint32Array(values.length);
          this.prefixSumValidIndex = new Int32Array(1);
          this.prefixSumValidIndex[0] = -1;
        }
        insertValues(insertIndex, insertValues) {
          insertIndex = toUint32(insertIndex);
          const oldValues = this.values;
          const oldPrefixSum = this.prefixSum;
          const insertValuesLen = insertValues.length;
          if (insertValuesLen === 0) {
            return false;
          }
          this.values = new Uint32Array(oldValues.length + insertValuesLen);
          this.values.set(oldValues.subarray(0, insertIndex), 0);
          this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
          this.values.set(insertValues, insertIndex);
          if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
          }
          this.prefixSum = new Uint32Array(this.values.length);
          if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
          }
          return true;
        }
        setValue(index, value) {
          index = toUint32(index);
          value = toUint32(value);
          if (this.values[index] === value) {
            return false;
          }
          this.values[index] = value;
          if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
          }
          return true;
        }
        removeValues(startIndex, count) {
          startIndex = toUint32(startIndex);
          count = toUint32(count);
          const oldValues = this.values;
          const oldPrefixSum = this.prefixSum;
          if (startIndex >= oldValues.length) {
            return false;
          }
          const maxCount = oldValues.length - startIndex;
          if (count >= maxCount) {
            count = maxCount;
          }
          if (count === 0) {
            return false;
          }
          this.values = new Uint32Array(oldValues.length - count);
          this.values.set(oldValues.subarray(0, startIndex), 0);
          this.values.set(oldValues.subarray(startIndex + count), startIndex);
          this.prefixSum = new Uint32Array(this.values.length);
          if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
          }
          if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
          }
          return true;
        }
        getTotalSum() {
          if (this.values.length === 0) {
            return 0;
          }
          return this._getPrefixSum(this.values.length - 1);
        }
        getPrefixSum(index) {
          if (index < 0) {
            return 0;
          }
          index = toUint32(index);
          return this._getPrefixSum(index);
        }
        _getPrefixSum(index) {
          if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
          }
          let startIndex = this.prefixSumValidIndex[0] + 1;
          if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
          }
          if (index >= this.values.length) {
            index = this.values.length - 1;
          }
          for (let i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
          }
          this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
          return this.prefixSum[index];
        }
        getIndexOf(sum) {
          sum = Math.floor(sum);
          this.getTotalSum();
          let low = 0;
          let high = this.values.length - 1;
          let mid = 0;
          let midStop = 0;
          let midStart = 0;
          while (low <= high) {
            mid = low + (high - low) / 2 | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (sum < midStart) {
              high = mid - 1;
            } else if (sum >= midStop) {
              low = mid + 1;
            } else {
              break;
            }
          }
          return new PrefixSumIndexOfResult(mid, sum - midStart);
        }
      };
      PrefixSumIndexOfResult = class {
        constructor(index, remainder) {
          this.index = index;
          this.remainder = remainder;
          this._prefixSumIndexOfResultBrand = void 0;
          this.index = index;
          this.remainder = remainder;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel;
  var init_mirrorTextModel = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js"() {
      init_strings();
      init_position();
      init_prefixSumComputer();
      MirrorTextModel = class {
        constructor(uri, lines, eol, versionId) {
          this._uri = uri;
          this._lines = lines;
          this._eol = eol;
          this._versionId = versionId;
          this._lineStarts = null;
          this._cachedTextValue = null;
        }
        dispose() {
          this._lines.length = 0;
        }
        get version() {
          return this._versionId;
        }
        getText() {
          if (this._cachedTextValue === null) {
            this._cachedTextValue = this._lines.join(this._eol);
          }
          return this._cachedTextValue;
        }
        onEvents(e) {
          if (e.eol && e.eol !== this._eol) {
            this._eol = e.eol;
            this._lineStarts = null;
          }
          const changes = e.changes;
          for (const change of changes) {
            this._acceptDeleteRange(change.range);
            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
          }
          this._versionId = e.versionId;
          this._cachedTextValue = null;
        }
        _ensureLineStarts() {
          if (!this._lineStarts) {
            const eolLength = this._eol.length;
            const linesLength = this._lines.length;
            const lineStartValues = new Uint32Array(linesLength);
            for (let i = 0; i < linesLength; i++) {
              lineStartValues[i] = this._lines[i].length + eolLength;
            }
            this._lineStarts = new PrefixSumComputer(lineStartValues);
          }
        }
        _setLineText(lineIndex, newValue) {
          this._lines[lineIndex] = newValue;
          if (this._lineStarts) {
            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
          }
        }
        _acceptDeleteRange(range) {
          if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
              return;
            }
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
          }
          this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
          this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
          if (this._lineStarts) {
            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
          }
        }
        _acceptInsertText(position, insertText) {
          if (insertText.length === 0) {
            return;
          }
          const insertLines = splitLines(insertText);
          if (insertLines.length === 1) {
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
            return;
          }
          insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
          this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
          const newLengths = new Uint32Array(insertLines.length - 1);
          for (let i = 1; i < insertLines.length; i++) {
            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this._eol.length;
          }
          if (this._lineStarts) {
            this._lineStarts.insertValues(position.lineNumber, newLengths);
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  function getWordAtText(column, wordDefinition, text, textOffset, config) {
    if (!config) {
      config = Iterable.first(_defaultConfig);
    }
    if (text.length > config.maxLen) {
      let start = column - config.maxLen / 2;
      if (start < 0) {
        start = 0;
      } else {
        textOffset += start;
      }
      text = text.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1; ; i++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }
  var USUAL_WORD_SEPARATORS, DEFAULT_WORD_REGEXP, _defaultConfig;
  var init_wordHelper = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"() {
      init_iterator();
      init_linkedList();
      USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
      DEFAULT_WORD_REGEXP = createWordRegExp();
      _defaultConfig = new LinkedList();
      _defaultConfig.unshift({
        maxLen: 1e3,
        windowSize: 15,
        timeBudget: 150
      });
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier;
  var init_characterClassifier = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js"() {
      init_uint();
      CharacterClassifier = class {
        constructor(_defaultValue) {
          const defaultValue = toUint8(_defaultValue);
          this._defaultValue = defaultValue;
          this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
          this._map = /* @__PURE__ */ new Map();
        }
        static _createAsciiMap(defaultValue) {
          const asciiMap = new Uint8Array(256);
          asciiMap.fill(defaultValue);
          return asciiMap;
        }
        set(charCode, _value) {
          const value = toUint8(_value);
          if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
          } else {
            this._map.set(charCode, value);
          }
        }
        get(charCode) {
          if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
          } else {
            return this._map.get(charCode) || this._defaultValue;
          }
        }
        clear() {
          this._asciiMap.fill(this._defaultValue);
          this._map.clear();
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [1, 104, 2],
        [1, 72, 2],
        [1, 102, 6],
        [1, 70, 6],
        [2, 116, 3],
        [2, 84, 3],
        [3, 116, 4],
        [3, 84, 4],
        [4, 112, 5],
        [4, 80, 5],
        [5, 115, 9],
        [5, 83, 9],
        [5, 58, 10],
        [6, 105, 7],
        [6, 73, 7],
        [7, 108, 8],
        [7, 76, 8],
        [8, 101, 9],
        [8, 69, 9],
        [9, 58, 10],
        [10, 47, 11],
        [11, 47, 12]
      ]);
    }
    return _stateMachine;
  }
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(0);
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
        _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1);
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;:";
      for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
        _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2);
      }
    }
    return _classifier;
  }
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }
  var Uint8Matrix, StateMachine, _stateMachine, _classifier, LinkComputer;
  var init_linkComputer = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js"() {
      init_characterClassifier();
      Uint8Matrix = class {
        constructor(rows, cols, defaultValue) {
          const data = new Uint8Array(rows * cols);
          for (let i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
          }
          this._data = data;
          this.rows = rows;
          this.cols = cols;
        }
        get(row, col) {
          return this._data[row * this.cols + col];
        }
        set(row, col, value) {
          this._data[row * this.cols + col] = value;
        }
      };
      StateMachine = class {
        constructor(edges) {
          let maxCharCode = 0;
          let maxState = 0;
          for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            if (chCode > maxCharCode) {
              maxCharCode = chCode;
            }
            if (from > maxState) {
              maxState = from;
            }
            if (to > maxState) {
              maxState = to;
            }
          }
          maxCharCode++;
          maxState++;
          const states = new Uint8Matrix(maxState, maxCharCode, 0);
          for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            states.set(from, chCode, to);
          }
          this._states = states;
          this._maxCharCode = maxCharCode;
        }
        nextState(currentState, chCode) {
          if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0;
          }
          return this._states.get(currentState, chCode);
        }
      };
      _stateMachine = null;
      _classifier = null;
      LinkComputer = class {
        static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
          let lastIncludedCharIndex = linkEndIndex - 1;
          do {
            const chCode = line.charCodeAt(lastIncludedCharIndex);
            const chClass = classifier.get(chCode);
            if (chClass !== 2) {
              break;
            }
            lastIncludedCharIndex--;
          } while (lastIncludedCharIndex > linkBeginIndex);
          if (linkBeginIndex > 0) {
            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
              lastIncludedCharIndex--;
            }
          }
          return {
            range: {
              startLineNumber: lineNumber,
              startColumn: linkBeginIndex + 1,
              endLineNumber: lineNumber,
              endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
          };
        }
        static computeLinks(model, stateMachine = getStateMachine()) {
          const classifier = getClassifier();
          const result = [];
          for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            const line = model.getLineContent(i);
            const len = line.length;
            let j = 0;
            let linkBeginIndex = 0;
            let linkBeginChCode = 0;
            let state = 1;
            let hasOpenParens = false;
            let hasOpenSquareBracket = false;
            let inSquareBrackets = false;
            let hasOpenCurlyBracket = false;
            while (j < len) {
              let resetStateMachine = false;
              const chCode = line.charCodeAt(j);
              if (state === 13) {
                let chClass;
                switch (chCode) {
                  case 40:
                    hasOpenParens = true;
                    chClass = 0;
                    break;
                  case 41:
                    chClass = hasOpenParens ? 0 : 1;
                    break;
                  case 91:
                    inSquareBrackets = true;
                    hasOpenSquareBracket = true;
                    chClass = 0;
                    break;
                  case 93:
                    inSquareBrackets = false;
                    chClass = hasOpenSquareBracket ? 0 : 1;
                    break;
                  case 123:
                    hasOpenCurlyBracket = true;
                    chClass = 0;
                    break;
                  case 125:
                    chClass = hasOpenCurlyBracket ? 0 : 1;
                    break;
                  case 39:
                  case 34:
                  case 96:
                    if (linkBeginChCode === chCode) {
                      chClass = 1;
                    } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                      chClass = 0;
                    } else {
                      chClass = 1;
                    }
                    break;
                  case 42:
                    chClass = linkBeginChCode === 42 ? 1 : 0;
                    break;
                  case 124:
                    chClass = linkBeginChCode === 124 ? 1 : 0;
                    break;
                  case 32:
                    chClass = inSquareBrackets ? 0 : 1;
                    break;
                  default:
                    chClass = classifier.get(chCode);
                }
                if (chClass === 1) {
                  result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                  resetStateMachine = true;
                }
              } else if (state === 12) {
                let chClass;
                if (chCode === 91) {
                  hasOpenSquareBracket = true;
                  chClass = 0;
                } else {
                  chClass = classifier.get(chCode);
                }
                if (chClass === 1) {
                  resetStateMachine = true;
                } else {
                  state = 13;
                }
              } else {
                state = stateMachine.nextState(state, chCode);
                if (state === 0) {
                  resetStateMachine = true;
                }
              }
              if (resetStateMachine) {
                state = 1;
                hasOpenParens = false;
                hasOpenSquareBracket = false;
                hasOpenCurlyBracket = false;
                linkBeginIndex = j + 1;
                linkBeginChCode = chCode;
              }
              j++;
            }
            if (state === 13) {
              result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
          }
          return result;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace;
  var init_inplaceReplaceSupport = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js"() {
      BasicInplaceReplace = class {
        constructor() {
          this._defaultValueSet = [
            ["true", "false"],
            ["True", "False"],
            ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
            ["public", "protected", "private"]
          ];
        }
        navigateValueSet(range1, text1, range2, text2, up) {
          if (range1 && text1) {
            const result = this.doNavigateValueSet(text1, up);
            if (result) {
              return {
                range: range1,
                value: result
              };
            }
          }
          if (range2 && text2) {
            const result = this.doNavigateValueSet(text2, up);
            if (result) {
              return {
                range: range2,
                value: result
              };
            }
          }
          return null;
        }
        doNavigateValueSet(text, up) {
          const numberResult = this.numberReplace(text, up);
          if (numberResult !== null) {
            return numberResult;
          }
          return this.textReplace(text, up);
        }
        numberReplace(value, up) {
          const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
          let n1 = Number(value);
          const n2 = parseFloat(value);
          if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
            if (n1 === 0 && !up) {
              return null;
            } else {
              n1 = Math.floor(n1 * precision);
              n1 += up ? precision : -precision;
              return String(n1 / precision);
            }
          }
          return null;
        }
        textReplace(value, up) {
          return this.valueSetsReplace(this._defaultValueSet, value, up);
        }
        valueSetsReplace(valueSets, value, up) {
          let result = null;
          for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
            result = this.valueSetReplace(valueSets[i], value, up);
          }
          return result;
        }
        valueSetReplace(valueSet, value, up) {
          let idx = valueSet.indexOf(value);
          if (idx >= 0) {
            idx += up ? 1 : -1;
            if (idx < 0) {
              idx = valueSet.length - 1;
            } else {
              idx %= valueSet.length;
            }
            return valueSet[idx];
          }
          return null;
        }
      };
      BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent, CancellationToken, MutableToken, CancellationTokenSource;
  var init_cancellation = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/cancellation.js"() {
      init_event();
      shortcutEvent = Object.freeze(function(callback, context) {
        const handle = setTimeout(callback.bind(context), 0);
        return { dispose() {
          clearTimeout(handle);
        } };
      });
      (function(CancellationToken2) {
        function isCancellationToken(thing) {
          if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
            return true;
          }
          if (thing instanceof MutableToken) {
            return true;
          }
          if (!thing || typeof thing !== "object") {
            return false;
          }
          return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
        }
        CancellationToken2.isCancellationToken = isCancellationToken;
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: shortcutEvent
        });
      })(CancellationToken || (CancellationToken = {}));
      MutableToken = class {
        constructor() {
          this._isCancelled = false;
          this._emitter = null;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
          }
        }
      };
      CancellationTokenSource = class {
        constructor(parent) {
          this._token = void 0;
          this._parentListener = void 0;
          this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
        }
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else if (this._token instanceof MutableToken) {
            this._token.cancel();
          }
        }
        dispose(cancel = false) {
          var _a3;
          if (cancel) {
            this.cancel();
          }
          (_a3 = this._parentListener) === null || _a3 === void 0 ? void 0 : _a3.dispose();
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }
  var KeyCodeStrMap, uiMap, userSettingsUSMap, userSettingsGeneralMap, EVENT_KEY_CODE_MAP, NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE, scanCodeIntToStr, scanCodeStrToInt, scanCodeLowerCaseStrToInt, IMMUTABLE_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE, KeyCodeUtils;
  var init_keyCodes = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/keyCodes.js"() {
      KeyCodeStrMap = class {
        constructor() {
          this._keyCodeToStr = [];
          this._strToKeyCode = /* @__PURE__ */ Object.create(null);
        }
        define(keyCode, str) {
          this._keyCodeToStr[keyCode] = str;
          this._strToKeyCode[str.toLowerCase()] = keyCode;
        }
        keyCodeToStr(keyCode) {
          return this._keyCodeToStr[keyCode];
        }
        strToKeyCode(str) {
          return this._strToKeyCode[str.toLowerCase()] || 0;
        }
      };
      uiMap = new KeyCodeStrMap();
      userSettingsUSMap = new KeyCodeStrMap();
      userSettingsGeneralMap = new KeyCodeStrMap();
      EVENT_KEY_CODE_MAP = new Array(230);
      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
      scanCodeIntToStr = [];
      scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
      scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
      IMMUTABLE_CODE_TO_KEY_CODE = [];
      IMMUTABLE_KEY_CODE_TO_CODE = [];
      for (let i = 0; i <= 193; i++) {
        IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
      }
      for (let i = 0; i <= 127; i++) {
        IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
      }
      (function() {
        const empty = "";
        const mappings = [
          [0, 1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
          [0, 1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
          [0, 1, 2, "Super", 0, empty, 0, empty, empty, empty],
          [0, 1, 3, "Fn", 0, empty, 0, empty, empty, empty],
          [0, 1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
          [0, 1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
          [0, 1, 6, "Resume", 0, empty, 0, empty, empty, empty],
          [0, 1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
          [0, 1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
          [0, 1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
          [31, 0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
          [32, 0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
          [33, 0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
          [34, 0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
          [35, 0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
          [36, 0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
          [37, 0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
          [38, 0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
          [39, 0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
          [40, 0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
          [41, 0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
          [42, 0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
          [43, 0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
          [44, 0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
          [45, 0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
          [46, 0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
          [47, 0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
          [48, 0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
          [49, 0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
          [50, 0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
          [51, 0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
          [52, 0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
          [53, 0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
          [54, 0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
          [55, 0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
          [56, 0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
          [22, 0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
          [23, 0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
          [24, 0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
          [25, 0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
          [26, 0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
          [27, 0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
          [28, 0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
          [29, 0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
          [30, 0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
          [21, 0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
          [3, 1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
          [9, 1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
          [1, 1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
          [2, 1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
          [10, 1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
          [83, 0, 51, "Minus", 83, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
          [81, 0, 52, "Equal", 81, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
          [87, 0, 53, "BracketLeft", 87, "[", 219, "VK_OEM_4", "[", "OEM_4"],
          [89, 0, 54, "BracketRight", 89, "]", 221, "VK_OEM_6", "]", "OEM_6"],
          [88, 0, 55, "Backslash", 88, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
          [0, 0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
          [80, 0, 57, "Semicolon", 80, ";", 186, "VK_OEM_1", ";", "OEM_1"],
          [90, 0, 58, "Quote", 90, "'", 222, "VK_OEM_7", "'", "OEM_7"],
          [86, 0, 59, "Backquote", 86, "`", 192, "VK_OEM_3", "`", "OEM_3"],
          [82, 0, 60, "Comma", 82, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
          [84, 0, 61, "Period", 84, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
          [85, 0, 62, "Slash", 85, "/", 191, "VK_OEM_2", "/", "OEM_2"],
          [8, 1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
          [59, 1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
          [60, 1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
          [61, 1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
          [62, 1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
          [63, 1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
          [64, 1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
          [65, 1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
          [66, 1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
          [67, 1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
          [68, 1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
          [69, 1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
          [70, 1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
          [0, 1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
          [79, 1, 77, "ScrollLock", 79, "ScrollLock", 145, "VK_SCROLL", empty, empty],
          [7, 1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
          [19, 1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
          [14, 1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
          [11, 1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
          [20, 1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
          [13, 1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
          [12, 1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
          [17, 1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
          [15, 1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
          [18, 1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
          [16, 1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
          [78, 1, 89, "NumLock", 78, "NumLock", 144, "VK_NUMLOCK", empty, empty],
          [108, 1, 90, "NumpadDivide", 108, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
          [103, 1, 91, "NumpadMultiply", 103, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
          [106, 1, 92, "NumpadSubtract", 106, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
          [104, 1, 93, "NumpadAdd", 104, "NumPad_Add", 107, "VK_ADD", empty, empty],
          [3, 1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
          [94, 1, 95, "Numpad1", 94, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
          [95, 1, 96, "Numpad2", 95, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
          [96, 1, 97, "Numpad3", 96, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
          [97, 1, 98, "Numpad4", 97, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
          [98, 1, 99, "Numpad5", 98, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
          [99, 1, 100, "Numpad6", 99, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
          [100, 1, 101, "Numpad7", 100, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
          [101, 1, 102, "Numpad8", 101, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
          [102, 1, 103, "Numpad9", 102, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
          [93, 1, 104, "Numpad0", 93, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
          [107, 1, 105, "NumpadDecimal", 107, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
          [92, 0, 106, "IntlBackslash", 92, "OEM_102", 226, "VK_OEM_102", empty, empty],
          [58, 1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
          [0, 1, 108, "Power", 0, empty, 0, empty, empty, empty],
          [0, 1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
          [71, 1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
          [72, 1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
          [73, 1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
          [74, 1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
          [75, 1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
          [76, 1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
          [77, 1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
          [0, 1, 117, "F20", 0, empty, 0, "VK_F20", empty, empty],
          [0, 1, 118, "F21", 0, empty, 0, "VK_F21", empty, empty],
          [0, 1, 119, "F22", 0, empty, 0, "VK_F22", empty, empty],
          [0, 1, 120, "F23", 0, empty, 0, "VK_F23", empty, empty],
          [0, 1, 121, "F24", 0, empty, 0, "VK_F24", empty, empty],
          [0, 1, 122, "Open", 0, empty, 0, empty, empty, empty],
          [0, 1, 123, "Help", 0, empty, 0, empty, empty, empty],
          [0, 1, 124, "Select", 0, empty, 0, empty, empty, empty],
          [0, 1, 125, "Again", 0, empty, 0, empty, empty, empty],
          [0, 1, 126, "Undo", 0, empty, 0, empty, empty, empty],
          [0, 1, 127, "Cut", 0, empty, 0, empty, empty, empty],
          [0, 1, 128, "Copy", 0, empty, 0, empty, empty, empty],
          [0, 1, 129, "Paste", 0, empty, 0, empty, empty, empty],
          [0, 1, 130, "Find", 0, empty, 0, empty, empty, empty],
          [0, 1, 131, "AudioVolumeMute", 112, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
          [0, 1, 132, "AudioVolumeUp", 113, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
          [0, 1, 133, "AudioVolumeDown", 114, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
          [105, 1, 134, "NumpadComma", 105, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
          [110, 0, 135, "IntlRo", 110, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
          [0, 1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
          [0, 0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
          [0, 1, 138, "Convert", 0, empty, 0, empty, empty, empty],
          [0, 1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
          [0, 1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
          [0, 1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
          [0, 1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
          [0, 1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
          [0, 1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
          [0, 1, 145, "Abort", 0, empty, 0, empty, empty, empty],
          [0, 1, 146, "Props", 0, empty, 0, empty, empty, empty],
          [0, 1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
          [0, 1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
          [0, 1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
          [0, 1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
          [0, 1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
          [0, 1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
          [0, 1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
          [0, 1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
          [0, 1, 155, "NumpadClear", 126, "Clear", 12, "VK_CLEAR", empty, empty],
          [0, 1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
          [5, 1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
          [4, 1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
          [6, 1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
          [57, 1, 0, empty, 57, "Meta", 0, "VK_COMMAND", empty, empty],
          [5, 1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
          [4, 1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
          [6, 1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
          [57, 1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
          [5, 1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
          [4, 1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
          [6, 1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
          [57, 1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
          [0, 1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
          [0, 1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
          [0, 1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
          [0, 1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
          [0, 1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
          [0, 1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
          [114, 1, 171, "MediaTrackNext", 119, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
          [115, 1, 172, "MediaTrackPrevious", 120, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
          [116, 1, 173, "MediaStop", 121, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
          [0, 1, 174, "Eject", 0, empty, 0, empty, empty, empty],
          [117, 1, 175, "MediaPlayPause", 122, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
          [0, 1, 176, "MediaSelect", 123, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
          [0, 1, 177, "LaunchMail", 124, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
          [0, 1, 178, "LaunchApp2", 125, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
          [0, 1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
          [0, 1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
          [0, 1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
          [0, 1, 182, "BrowserSearch", 115, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
          [0, 1, 183, "BrowserHome", 116, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
          [112, 1, 184, "BrowserBack", 117, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
          [113, 1, 185, "BrowserForward", 118, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
          [0, 1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
          [0, 1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
          [0, 1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
          [0, 1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
          [0, 1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
          [0, 1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
          [0, 1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
          [109, 1, 0, empty, 109, "KeyInComposition", 229, empty, empty, empty],
          [111, 1, 0, empty, 111, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
          [91, 1, 0, empty, 91, "OEM_8", 223, "VK_OEM_8", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
          [0, 1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
        ];
        const seenKeyCode = [];
        const seenScanCode = [];
        for (const mapping of mappings) {
          const [_keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
          if (!seenScanCode[scanCode]) {
            seenScanCode[scanCode] = true;
            scanCodeIntToStr[scanCode] = scanCodeStr;
            scanCodeStrToInt[scanCodeStr] = scanCode;
            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
            if (immutable) {
              IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
              if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
                IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
              }
            }
          }
          if (!seenKeyCode[keyCode]) {
            seenKeyCode[keyCode] = true;
            if (!keyCodeStr) {
              throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
            }
            uiMap.define(keyCode, keyCodeStr);
            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
          }
          if (eventKeyCode) {
            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
          }
          if (vkey) {
            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
          }
        }
        IMMUTABLE_KEY_CODE_TO_CODE[3] = 46;
      })();
      (function(KeyCodeUtils2) {
        function toString(keyCode) {
          return uiMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toString = toString;
        function fromString(key) {
          return uiMap.strToKeyCode(key);
        }
        KeyCodeUtils2.fromString = fromString;
        function toUserSettingsUS(keyCode) {
          return userSettingsUSMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
        function toUserSettingsGeneral(keyCode) {
          return userSettingsGeneralMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
        function fromUserSettings(key) {
          return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
        }
        KeyCodeUtils2.fromUserSettings = fromUserSettings;
        function toElectronAccelerator(keyCode) {
          if (keyCode >= 93 && keyCode <= 108) {
            return null;
          }
          switch (keyCode) {
            case 16:
              return "Up";
            case 18:
              return "Down";
            case 15:
              return "Left";
            case 17:
              return "Right";
          }
          return uiMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
      })(KeyCodeUtils || (KeyCodeUtils = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
  var Selection;
  var init_selection = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/selection.js"() {
      init_position();
      init_range();
      Selection = class extends Range {
        constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
          super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
          this.selectionStartLineNumber = selectionStartLineNumber;
          this.selectionStartColumn = selectionStartColumn;
          this.positionLineNumber = positionLineNumber;
          this.positionColumn = positionColumn;
        }
        toString() {
          return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
        }
        equalsSelection(other) {
          return Selection.selectionsEqual(this, other);
        }
        static selectionsEqual(a, b) {
          return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
        }
        getDirection() {
          if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
            return 0;
          }
          return 1;
        }
        setEndPosition(endLineNumber, endColumn) {
          if (this.getDirection() === 0) {
            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
          }
          return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        }
        getPosition() {
          return new Position(this.positionLineNumber, this.positionColumn);
        }
        getSelectionStart() {
          return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
        }
        setStartPosition(startLineNumber, startColumn) {
          if (this.getDirection() === 0) {
            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
          }
          return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        }
        static fromPositions(start, end = start) {
          return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        static fromRange(range, direction) {
          if (direction === 0) {
            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
          } else {
            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
          }
        }
        static liftSelection(sel) {
          return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        }
        static selectionsArrEqual(a, b) {
          if (a && !b || !a && b) {
            return false;
          }
          if (!a && !b) {
            return true;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0, len = a.length; i < len; i++) {
            if (!this.selectionsEqual(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
        static isISelection(obj) {
          return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
        }
        static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
          if (direction === 0) {
            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
          }
          return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/codicons.js
  function register(id, fontCharacter) {
    if (isString(fontCharacter)) {
      const val = _codiconFontCharacters[fontCharacter];
      if (val === void 0) {
        throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
      }
      fontCharacter = val;
    }
    _codiconFontCharacters[id] = fontCharacter;
    return { id };
  }
  var _codiconFontCharacters, Codicon;
  var init_codicons = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/codicons.js"() {
      init_types();
      _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
      Codicon = {
        add: register("add", 6e4),
        plus: register("plus", 6e4),
        gistNew: register("gist-new", 6e4),
        repoCreate: register("repo-create", 6e4),
        lightbulb: register("lightbulb", 60001),
        lightBulb: register("light-bulb", 60001),
        repo: register("repo", 60002),
        repoDelete: register("repo-delete", 60002),
        gistFork: register("gist-fork", 60003),
        repoForked: register("repo-forked", 60003),
        gitPullRequest: register("git-pull-request", 60004),
        gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
        recordKeys: register("record-keys", 60005),
        keyboard: register("keyboard", 60005),
        tag: register("tag", 60006),
        tagAdd: register("tag-add", 60006),
        tagRemove: register("tag-remove", 60006),
        person: register("person", 60007),
        personFollow: register("person-follow", 60007),
        personOutline: register("person-outline", 60007),
        personFilled: register("person-filled", 60007),
        gitBranch: register("git-branch", 60008),
        gitBranchCreate: register("git-branch-create", 60008),
        gitBranchDelete: register("git-branch-delete", 60008),
        sourceControl: register("source-control", 60008),
        mirror: register("mirror", 60009),
        mirrorPublic: register("mirror-public", 60009),
        star: register("star", 60010),
        starAdd: register("star-add", 60010),
        starDelete: register("star-delete", 60010),
        starEmpty: register("star-empty", 60010),
        comment: register("comment", 60011),
        commentAdd: register("comment-add", 60011),
        alert: register("alert", 60012),
        warning: register("warning", 60012),
        search: register("search", 60013),
        searchSave: register("search-save", 60013),
        logOut: register("log-out", 60014),
        signOut: register("sign-out", 60014),
        logIn: register("log-in", 60015),
        signIn: register("sign-in", 60015),
        eye: register("eye", 60016),
        eyeUnwatch: register("eye-unwatch", 60016),
        eyeWatch: register("eye-watch", 60016),
        circleFilled: register("circle-filled", 60017),
        primitiveDot: register("primitive-dot", 60017),
        closeDirty: register("close-dirty", 60017),
        debugBreakpoint: register("debug-breakpoint", 60017),
        debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
        debugHint: register("debug-hint", 60017),
        primitiveSquare: register("primitive-square", 60018),
        edit: register("edit", 60019),
        pencil: register("pencil", 60019),
        info: register("info", 60020),
        issueOpened: register("issue-opened", 60020),
        gistPrivate: register("gist-private", 60021),
        gitForkPrivate: register("git-fork-private", 60021),
        lock: register("lock", 60021),
        mirrorPrivate: register("mirror-private", 60021),
        close: register("close", 60022),
        removeClose: register("remove-close", 60022),
        x: register("x", 60022),
        repoSync: register("repo-sync", 60023),
        sync: register("sync", 60023),
        clone: register("clone", 60024),
        desktopDownload: register("desktop-download", 60024),
        beaker: register("beaker", 60025),
        microscope: register("microscope", 60025),
        vm: register("vm", 60026),
        deviceDesktop: register("device-desktop", 60026),
        file: register("file", 60027),
        fileText: register("file-text", 60027),
        more: register("more", 60028),
        ellipsis: register("ellipsis", 60028),
        kebabHorizontal: register("kebab-horizontal", 60028),
        mailReply: register("mail-reply", 60029),
        reply: register("reply", 60029),
        organization: register("organization", 60030),
        organizationFilled: register("organization-filled", 60030),
        organizationOutline: register("organization-outline", 60030),
        newFile: register("new-file", 60031),
        fileAdd: register("file-add", 60031),
        newFolder: register("new-folder", 60032),
        fileDirectoryCreate: register("file-directory-create", 60032),
        trash: register("trash", 60033),
        trashcan: register("trashcan", 60033),
        history: register("history", 60034),
        clock: register("clock", 60034),
        folder: register("folder", 60035),
        fileDirectory: register("file-directory", 60035),
        symbolFolder: register("symbol-folder", 60035),
        logoGithub: register("logo-github", 60036),
        markGithub: register("mark-github", 60036),
        github: register("github", 60036),
        terminal: register("terminal", 60037),
        console: register("console", 60037),
        repl: register("repl", 60037),
        zap: register("zap", 60038),
        symbolEvent: register("symbol-event", 60038),
        error: register("error", 60039),
        stop: register("stop", 60039),
        variable: register("variable", 60040),
        symbolVariable: register("symbol-variable", 60040),
        array: register("array", 60042),
        symbolArray: register("symbol-array", 60042),
        symbolModule: register("symbol-module", 60043),
        symbolPackage: register("symbol-package", 60043),
        symbolNamespace: register("symbol-namespace", 60043),
        symbolObject: register("symbol-object", 60043),
        symbolMethod: register("symbol-method", 60044),
        symbolFunction: register("symbol-function", 60044),
        symbolConstructor: register("symbol-constructor", 60044),
        symbolBoolean: register("symbol-boolean", 60047),
        symbolNull: register("symbol-null", 60047),
        symbolNumeric: register("symbol-numeric", 60048),
        symbolNumber: register("symbol-number", 60048),
        symbolStructure: register("symbol-structure", 60049),
        symbolStruct: register("symbol-struct", 60049),
        symbolParameter: register("symbol-parameter", 60050),
        symbolTypeParameter: register("symbol-type-parameter", 60050),
        symbolKey: register("symbol-key", 60051),
        symbolText: register("symbol-text", 60051),
        symbolReference: register("symbol-reference", 60052),
        goToFile: register("go-to-file", 60052),
        symbolEnum: register("symbol-enum", 60053),
        symbolValue: register("symbol-value", 60053),
        symbolRuler: register("symbol-ruler", 60054),
        symbolUnit: register("symbol-unit", 60054),
        activateBreakpoints: register("activate-breakpoints", 60055),
        archive: register("archive", 60056),
        arrowBoth: register("arrow-both", 60057),
        arrowDown: register("arrow-down", 60058),
        arrowLeft: register("arrow-left", 60059),
        arrowRight: register("arrow-right", 60060),
        arrowSmallDown: register("arrow-small-down", 60061),
        arrowSmallLeft: register("arrow-small-left", 60062),
        arrowSmallRight: register("arrow-small-right", 60063),
        arrowSmallUp: register("arrow-small-up", 60064),
        arrowUp: register("arrow-up", 60065),
        bell: register("bell", 60066),
        bold: register("bold", 60067),
        book: register("book", 60068),
        bookmark: register("bookmark", 60069),
        debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
        debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
        debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
        debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
        debugBreakpointData: register("debug-breakpoint-data", 60073),
        debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
        debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
        debugBreakpointLog: register("debug-breakpoint-log", 60075),
        debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
        briefcase: register("briefcase", 60076),
        broadcast: register("broadcast", 60077),
        browser: register("browser", 60078),
        bug: register("bug", 60079),
        calendar: register("calendar", 60080),
        caseSensitive: register("case-sensitive", 60081),
        check: register("check", 60082),
        checklist: register("checklist", 60083),
        chevronDown: register("chevron-down", 60084),
        dropDownButton: register("drop-down-button", 60084),
        chevronLeft: register("chevron-left", 60085),
        chevronRight: register("chevron-right", 60086),
        chevronUp: register("chevron-up", 60087),
        chromeClose: register("chrome-close", 60088),
        chromeMaximize: register("chrome-maximize", 60089),
        chromeMinimize: register("chrome-minimize", 60090),
        chromeRestore: register("chrome-restore", 60091),
        circle: register("circle", 60092),
        circleOutline: register("circle-outline", 60092),
        debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
        circleSlash: register("circle-slash", 60093),
        circuitBoard: register("circuit-board", 60094),
        clearAll: register("clear-all", 60095),
        clippy: register("clippy", 60096),
        closeAll: register("close-all", 60097),
        cloudDownload: register("cloud-download", 60098),
        cloudUpload: register("cloud-upload", 60099),
        code: register("code", 60100),
        collapseAll: register("collapse-all", 60101),
        colorMode: register("color-mode", 60102),
        commentDiscussion: register("comment-discussion", 60103),
        compareChanges: register("compare-changes", 60157),
        creditCard: register("credit-card", 60105),
        dash: register("dash", 60108),
        dashboard: register("dashboard", 60109),
        database: register("database", 60110),
        debugContinue: register("debug-continue", 60111),
        debugDisconnect: register("debug-disconnect", 60112),
        debugPause: register("debug-pause", 60113),
        debugRestart: register("debug-restart", 60114),
        debugStart: register("debug-start", 60115),
        debugStepInto: register("debug-step-into", 60116),
        debugStepOut: register("debug-step-out", 60117),
        debugStepOver: register("debug-step-over", 60118),
        debugStop: register("debug-stop", 60119),
        debug: register("debug", 60120),
        deviceCameraVideo: register("device-camera-video", 60121),
        deviceCamera: register("device-camera", 60122),
        deviceMobile: register("device-mobile", 60123),
        diffAdded: register("diff-added", 60124),
        diffIgnored: register("diff-ignored", 60125),
        diffModified: register("diff-modified", 60126),
        diffRemoved: register("diff-removed", 60127),
        diffRenamed: register("diff-renamed", 60128),
        diff: register("diff", 60129),
        discard: register("discard", 60130),
        editorLayout: register("editor-layout", 60131),
        emptyWindow: register("empty-window", 60132),
        exclude: register("exclude", 60133),
        extensions: register("extensions", 60134),
        eyeClosed: register("eye-closed", 60135),
        fileBinary: register("file-binary", 60136),
        fileCode: register("file-code", 60137),
        fileMedia: register("file-media", 60138),
        filePdf: register("file-pdf", 60139),
        fileSubmodule: register("file-submodule", 60140),
        fileSymlinkDirectory: register("file-symlink-directory", 60141),
        fileSymlinkFile: register("file-symlink-file", 60142),
        fileZip: register("file-zip", 60143),
        files: register("files", 60144),
        filter: register("filter", 60145),
        flame: register("flame", 60146),
        foldDown: register("fold-down", 60147),
        foldUp: register("fold-up", 60148),
        fold: register("fold", 60149),
        folderActive: register("folder-active", 60150),
        folderOpened: register("folder-opened", 60151),
        gear: register("gear", 60152),
        gift: register("gift", 60153),
        gistSecret: register("gist-secret", 60154),
        gist: register("gist", 60155),
        gitCommit: register("git-commit", 60156),
        gitCompare: register("git-compare", 60157),
        gitMerge: register("git-merge", 60158),
        githubAction: register("github-action", 60159),
        githubAlt: register("github-alt", 60160),
        globe: register("globe", 60161),
        grabber: register("grabber", 60162),
        graph: register("graph", 60163),
        gripper: register("gripper", 60164),
        heart: register("heart", 60165),
        home: register("home", 60166),
        horizontalRule: register("horizontal-rule", 60167),
        hubot: register("hubot", 60168),
        inbox: register("inbox", 60169),
        issueClosed: register("issue-closed", 60324),
        issueReopened: register("issue-reopened", 60171),
        issues: register("issues", 60172),
        italic: register("italic", 60173),
        jersey: register("jersey", 60174),
        json: register("json", 60175),
        bracket: register("bracket", 60175),
        kebabVertical: register("kebab-vertical", 60176),
        key: register("key", 60177),
        law: register("law", 60178),
        lightbulbAutofix: register("lightbulb-autofix", 60179),
        linkExternal: register("link-external", 60180),
        link: register("link", 60181),
        listOrdered: register("list-ordered", 60182),
        listUnordered: register("list-unordered", 60183),
        liveShare: register("live-share", 60184),
        loading: register("loading", 60185),
        location: register("location", 60186),
        mailRead: register("mail-read", 60187),
        mail: register("mail", 60188),
        markdown: register("markdown", 60189),
        megaphone: register("megaphone", 60190),
        mention: register("mention", 60191),
        milestone: register("milestone", 60192),
        mortarBoard: register("mortar-board", 60193),
        move: register("move", 60194),
        multipleWindows: register("multiple-windows", 60195),
        mute: register("mute", 60196),
        noNewline: register("no-newline", 60197),
        note: register("note", 60198),
        octoface: register("octoface", 60199),
        openPreview: register("open-preview", 60200),
        package_: register("package", 60201),
        paintcan: register("paintcan", 60202),
        pin: register("pin", 60203),
        play: register("play", 60204),
        run: register("run", 60204),
        plug: register("plug", 60205),
        preserveCase: register("preserve-case", 60206),
        preview: register("preview", 60207),
        project: register("project", 60208),
        pulse: register("pulse", 60209),
        question: register("question", 60210),
        quote: register("quote", 60211),
        radioTower: register("radio-tower", 60212),
        reactions: register("reactions", 60213),
        references: register("references", 60214),
        refresh: register("refresh", 60215),
        regex: register("regex", 60216),
        remoteExplorer: register("remote-explorer", 60217),
        remote: register("remote", 60218),
        remove: register("remove", 60219),
        replaceAll: register("replace-all", 60220),
        replace: register("replace", 60221),
        repoClone: register("repo-clone", 60222),
        repoForcePush: register("repo-force-push", 60223),
        repoPull: register("repo-pull", 60224),
        repoPush: register("repo-push", 60225),
        report: register("report", 60226),
        requestChanges: register("request-changes", 60227),
        rocket: register("rocket", 60228),
        rootFolderOpened: register("root-folder-opened", 60229),
        rootFolder: register("root-folder", 60230),
        rss: register("rss", 60231),
        ruby: register("ruby", 60232),
        saveAll: register("save-all", 60233),
        saveAs: register("save-as", 60234),
        save: register("save", 60235),
        screenFull: register("screen-full", 60236),
        screenNormal: register("screen-normal", 60237),
        searchStop: register("search-stop", 60238),
        server: register("server", 60240),
        settingsGear: register("settings-gear", 60241),
        settings: register("settings", 60242),
        shield: register("shield", 60243),
        smiley: register("smiley", 60244),
        sortPrecedence: register("sort-precedence", 60245),
        splitHorizontal: register("split-horizontal", 60246),
        splitVertical: register("split-vertical", 60247),
        squirrel: register("squirrel", 60248),
        starFull: register("star-full", 60249),
        starHalf: register("star-half", 60250),
        symbolClass: register("symbol-class", 60251),
        symbolColor: register("symbol-color", 60252),
        symbolCustomColor: register("symbol-customcolor", 60252),
        symbolConstant: register("symbol-constant", 60253),
        symbolEnumMember: register("symbol-enum-member", 60254),
        symbolField: register("symbol-field", 60255),
        symbolFile: register("symbol-file", 60256),
        symbolInterface: register("symbol-interface", 60257),
        symbolKeyword: register("symbol-keyword", 60258),
        symbolMisc: register("symbol-misc", 60259),
        symbolOperator: register("symbol-operator", 60260),
        symbolProperty: register("symbol-property", 60261),
        wrench: register("wrench", 60261),
        wrenchSubaction: register("wrench-subaction", 60261),
        symbolSnippet: register("symbol-snippet", 60262),
        tasklist: register("tasklist", 60263),
        telescope: register("telescope", 60264),
        textSize: register("text-size", 60265),
        threeBars: register("three-bars", 60266),
        thumbsdown: register("thumbsdown", 60267),
        thumbsup: register("thumbsup", 60268),
        tools: register("tools", 60269),
        triangleDown: register("triangle-down", 60270),
        triangleLeft: register("triangle-left", 60271),
        triangleRight: register("triangle-right", 60272),
        triangleUp: register("triangle-up", 60273),
        twitter: register("twitter", 60274),
        unfold: register("unfold", 60275),
        unlock: register("unlock", 60276),
        unmute: register("unmute", 60277),
        unverified: register("unverified", 60278),
        verified: register("verified", 60279),
        versions: register("versions", 60280),
        vmActive: register("vm-active", 60281),
        vmOutline: register("vm-outline", 60282),
        vmRunning: register("vm-running", 60283),
        watch: register("watch", 60284),
        whitespace: register("whitespace", 60285),
        wholeWord: register("whole-word", 60286),
        window: register("window", 60287),
        wordWrap: register("word-wrap", 60288),
        zoomIn: register("zoom-in", 60289),
        zoomOut: register("zoom-out", 60290),
        listFilter: register("list-filter", 60291),
        listFlat: register("list-flat", 60292),
        listSelection: register("list-selection", 60293),
        selection: register("selection", 60293),
        listTree: register("list-tree", 60294),
        debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
        debugBreakpointFunction: register("debug-breakpoint-function", 60296),
        debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
        debugStackframeActive: register("debug-stackframe-active", 60297),
        circleSmallFilled: register("circle-small-filled", 60298),
        debugStackframeDot: register("debug-stackframe-dot", 60298),
        debugStackframe: register("debug-stackframe", 60299),
        debugStackframeFocused: register("debug-stackframe-focused", 60299),
        debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
        symbolString: register("symbol-string", 60301),
        debugReverseContinue: register("debug-reverse-continue", 60302),
        debugStepBack: register("debug-step-back", 60303),
        debugRestartFrame: register("debug-restart-frame", 60304),
        callIncoming: register("call-incoming", 60306),
        callOutgoing: register("call-outgoing", 60307),
        menu: register("menu", 60308),
        expandAll: register("expand-all", 60309),
        feedback: register("feedback", 60310),
        groupByRefType: register("group-by-ref-type", 60311),
        ungroupByRefType: register("ungroup-by-ref-type", 60312),
        account: register("account", 60313),
        bellDot: register("bell-dot", 60314),
        debugConsole: register("debug-console", 60315),
        library: register("library", 60316),
        output: register("output", 60317),
        runAll: register("run-all", 60318),
        syncIgnored: register("sync-ignored", 60319),
        pinned: register("pinned", 60320),
        githubInverted: register("github-inverted", 60321),
        debugAlt: register("debug-alt", 60305),
        serverProcess: register("server-process", 60322),
        serverEnvironment: register("server-environment", 60323),
        pass: register("pass", 60324),
        stopCircle: register("stop-circle", 60325),
        playCircle: register("play-circle", 60326),
        record: register("record", 60327),
        debugAltSmall: register("debug-alt-small", 60328),
        vmConnect: register("vm-connect", 60329),
        cloud: register("cloud", 60330),
        merge: register("merge", 60331),
        exportIcon: register("export", 60332),
        graphLeft: register("graph-left", 60333),
        magnet: register("magnet", 60334),
        notebook: register("notebook", 60335),
        redo: register("redo", 60336),
        checkAll: register("check-all", 60337),
        pinnedDirty: register("pinned-dirty", 60338),
        passFilled: register("pass-filled", 60339),
        circleLargeFilled: register("circle-large-filled", 60340),
        circleLarge: register("circle-large", 60341),
        circleLargeOutline: register("circle-large-outline", 60341),
        combine: register("combine", 60342),
        gather: register("gather", 60342),
        table: register("table", 60343),
        variableGroup: register("variable-group", 60344),
        typeHierarchy: register("type-hierarchy", 60345),
        typeHierarchySub: register("type-hierarchy-sub", 60346),
        typeHierarchySuper: register("type-hierarchy-super", 60347),
        gitPullRequestCreate: register("git-pull-request-create", 60348),
        runAbove: register("run-above", 60349),
        runBelow: register("run-below", 60350),
        notebookTemplate: register("notebook-template", 60351),
        debugRerun: register("debug-rerun", 60352),
        workspaceTrusted: register("workspace-trusted", 60353),
        workspaceUntrusted: register("workspace-untrusted", 60354),
        workspaceUnspecified: register("workspace-unspecified", 60355),
        terminalCmd: register("terminal-cmd", 60356),
        terminalDebian: register("terminal-debian", 60357),
        terminalLinux: register("terminal-linux", 60358),
        terminalPowershell: register("terminal-powershell", 60359),
        terminalTmux: register("terminal-tmux", 60360),
        terminalUbuntu: register("terminal-ubuntu", 60361),
        terminalBash: register("terminal-bash", 60362),
        arrowSwap: register("arrow-swap", 60363),
        copy: register("copy", 60364),
        personAdd: register("person-add", 60365),
        filterFilled: register("filter-filled", 60366),
        wand: register("wand", 60367),
        debugLineByLine: register("debug-line-by-line", 60368),
        inspect: register("inspect", 60369),
        layers: register("layers", 60370),
        layersDot: register("layers-dot", 60371),
        layersActive: register("layers-active", 60372),
        compass: register("compass", 60373),
        compassDot: register("compass-dot", 60374),
        compassActive: register("compass-active", 60375),
        azure: register("azure", 60376),
        issueDraft: register("issue-draft", 60377),
        gitPullRequestClosed: register("git-pull-request-closed", 60378),
        gitPullRequestDraft: register("git-pull-request-draft", 60379),
        debugAll: register("debug-all", 60380),
        debugCoverage: register("debug-coverage", 60381),
        runErrors: register("run-errors", 60382),
        folderLibrary: register("folder-library", 60383),
        debugContinueSmall: register("debug-continue-small", 60384),
        beakerStop: register("beaker-stop", 60385),
        graphLine: register("graph-line", 60386),
        graphScatter: register("graph-scatter", 60387),
        pieChart: register("pie-chart", 60388),
        bracketDot: register("bracket-dot", 60389),
        bracketError: register("bracket-error", 60390),
        lockSmall: register("lock-small", 60391),
        azureDevops: register("azure-devops", 60392),
        verifiedFilled: register("verified-filled", 60393),
        newLine: register("newline", 60394),
        layout: register("layout", 60395),
        layoutActivitybarLeft: register("layout-activitybar-left", 60396),
        layoutActivitybarRight: register("layout-activitybar-right", 60397),
        layoutPanelLeft: register("layout-panel-left", 60398),
        layoutPanelCenter: register("layout-panel-center", 60399),
        layoutPanelJustify: register("layout-panel-justify", 60400),
        layoutPanelRight: register("layout-panel-right", 60401),
        layoutPanel: register("layout-panel", 60402),
        layoutSidebarLeft: register("layout-sidebar-left", 60403),
        layoutSidebarRight: register("layout-sidebar-right", 60404),
        layoutStatusbar: register("layout-statusbar", 60405),
        layoutMenubar: register("layout-menubar", 60406),
        layoutCentered: register("layout-centered", 60407),
        layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
        layoutPanelOff: register("layout-panel-off", 60417),
        layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
        target: register("target", 60408),
        indent: register("indent", 60409),
        recordSmall: register("record-small", 60410),
        errorSmall: register("error-small", 60411),
        arrowCircleDown: register("arrow-circle-down", 60412),
        arrowCircleLeft: register("arrow-circle-left", 60413),
        arrowCircleRight: register("arrow-circle-right", 60414),
        arrowCircleUp: register("arrow-circle-up", 60415),
        heartFilled: register("heart-filled", 60420),
        map: register("map", 60421),
        mapFilled: register("map-filled", 60422),
        circleSmall: register("circle-small", 60423),
        bellSlash: register("bell-slash", 60424),
        bellSlashDot: register("bell-slash-dot", 60425),
        commentUnresolved: register("comment-unresolved", 60426),
        gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
        gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
        searchFuzzy: register("search-fuzzy", 60429),
        commentDraft: register("comment-draft", 60430),
        dialogError: register("dialog-error", "error"),
        dialogWarning: register("dialog-warning", "warning"),
        dialogInfo: register("dialog-info", "info"),
        dialogClose: register("dialog-close", "close"),
        treeItemExpanded: register("tree-item-expanded", "chevron-down"),
        treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
        treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
        treeFilterClear: register("tree-filter-clear", "close"),
        treeItemLoading: register("tree-item-loading", "loading"),
        menuSelection: register("menu-selection", "check"),
        menuSubmenu: register("menu-submenu", "chevron-right"),
        menuBarMore: register("menubar-more", "more"),
        scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
        scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
        scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
        scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
        toolBarMore: register("toolbar-more", "more"),
        quickInputBack: register("quick-input-back", "arrow-left")
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
  var __awaiter, TokenizationRegistry, TokenizationSupportFactoryData;
  var init_tokenizationRegistry = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js"() {
      init_event();
      init_lifecycle();
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      TokenizationRegistry = class {
        constructor() {
          this._map = /* @__PURE__ */ new Map();
          this._factories = /* @__PURE__ */ new Map();
          this._onDidChange = new Emitter();
          this.onDidChange = this._onDidChange.event;
          this._colorMap = null;
        }
        fire(languages) {
          this._onDidChange.fire({
            changedLanguages: languages,
            changedColorMap: false
          });
        }
        register(language, support) {
          this._map.set(language, support);
          this.fire([language]);
          return toDisposable(() => {
            if (this._map.get(language) !== support) {
              return;
            }
            this._map.delete(language);
            this.fire([language]);
          });
        }
        registerFactory(languageId, factory) {
          var _a3;
          (_a3 = this._factories.get(languageId)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
          const myData = new TokenizationSupportFactoryData(this, languageId, factory);
          this._factories.set(languageId, myData);
          return toDisposable(() => {
            const v = this._factories.get(languageId);
            if (!v || v !== myData) {
              return;
            }
            this._factories.delete(languageId);
            v.dispose();
          });
        }
        getOrCreate(languageId) {
          return __awaiter(this, void 0, void 0, function* () {
            const tokenizationSupport = this.get(languageId);
            if (tokenizationSupport) {
              return tokenizationSupport;
            }
            const factory = this._factories.get(languageId);
            if (!factory || factory.isResolved) {
              return null;
            }
            yield factory.resolve();
            return this.get(languageId);
          });
        }
        get(language) {
          return this._map.get(language) || null;
        }
        isResolved(languageId) {
          const tokenizationSupport = this.get(languageId);
          if (tokenizationSupport) {
            return true;
          }
          const factory = this._factories.get(languageId);
          if (!factory || factory.isResolved) {
            return true;
          }
          return false;
        }
        setColorMap(colorMap) {
          this._colorMap = colorMap;
          this._onDidChange.fire({
            changedLanguages: Array.from(this._map.keys()),
            changedColorMap: true
          });
        }
        getColorMap() {
          return this._colorMap;
        }
        getDefaultBackground() {
          if (this._colorMap && this._colorMap.length > 2) {
            return this._colorMap[2];
          }
          return null;
        }
      };
      TokenizationSupportFactoryData = class extends Disposable {
        get isResolved() {
          return this._isResolved;
        }
        constructor(_registry, _languageId, _factory) {
          super();
          this._registry = _registry;
          this._languageId = _languageId;
          this._factory = _factory;
          this._isDisposed = false;
          this._resolvePromise = null;
          this._isResolved = false;
        }
        dispose() {
          this._isDisposed = true;
          super.dispose();
        }
        resolve() {
          return __awaiter(this, void 0, void 0, function* () {
            if (!this._resolvePromise) {
              this._resolvePromise = this._create();
            }
            return this._resolvePromise;
          });
        }
        _create() {
          return __awaiter(this, void 0, void 0, function* () {
            const value = yield Promise.resolve(this._factory.createTokenizationSupport());
            this._isResolved = true;
            if (value && !this._isDisposed) {
              this._register(this._registry.register(this._languageId, value));
            }
          });
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/languages.js
  var Token, CompletionItemKinds, InlineCompletionTriggerKind, SignatureHelpTriggerKind, DocumentHighlightKind, SymbolKinds, FoldingRangeKind, Command, InlayHintKind, TokenizationRegistry2;
  var init_languages = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/languages.js"() {
      init_codicons();
      init_uri();
      init_range();
      init_tokenizationRegistry();
      Token = class {
        constructor(offset, type, language) {
          this.offset = offset;
          this.type = type;
          this.language = language;
          this._tokenBrand = void 0;
        }
        toString() {
          return "(" + this.offset + ", " + this.type + ")";
        }
      };
      (function(CompletionItemKinds2) {
        const byKind = /* @__PURE__ */ new Map();
        byKind.set(0, Codicon.symbolMethod);
        byKind.set(1, Codicon.symbolFunction);
        byKind.set(2, Codicon.symbolConstructor);
        byKind.set(3, Codicon.symbolField);
        byKind.set(4, Codicon.symbolVariable);
        byKind.set(5, Codicon.symbolClass);
        byKind.set(6, Codicon.symbolStruct);
        byKind.set(7, Codicon.symbolInterface);
        byKind.set(8, Codicon.symbolModule);
        byKind.set(9, Codicon.symbolProperty);
        byKind.set(10, Codicon.symbolEvent);
        byKind.set(11, Codicon.symbolOperator);
        byKind.set(12, Codicon.symbolUnit);
        byKind.set(13, Codicon.symbolValue);
        byKind.set(15, Codicon.symbolEnum);
        byKind.set(14, Codicon.symbolConstant);
        byKind.set(15, Codicon.symbolEnum);
        byKind.set(16, Codicon.symbolEnumMember);
        byKind.set(17, Codicon.symbolKeyword);
        byKind.set(27, Codicon.symbolSnippet);
        byKind.set(18, Codicon.symbolText);
        byKind.set(19, Codicon.symbolColor);
        byKind.set(20, Codicon.symbolFile);
        byKind.set(21, Codicon.symbolReference);
        byKind.set(22, Codicon.symbolCustomColor);
        byKind.set(23, Codicon.symbolFolder);
        byKind.set(24, Codicon.symbolTypeParameter);
        byKind.set(25, Codicon.account);
        byKind.set(26, Codicon.issues);
        function toIcon(kind) {
          let codicon = byKind.get(kind);
          if (!codicon) {
            console.info("No codicon found for CompletionItemKind " + kind);
            codicon = Codicon.symbolProperty;
          }
          return codicon;
        }
        CompletionItemKinds2.toIcon = toIcon;
        const data = /* @__PURE__ */ new Map();
        data.set("method", 0);
        data.set("function", 1);
        data.set("constructor", 2);
        data.set("field", 3);
        data.set("variable", 4);
        data.set("class", 5);
        data.set("struct", 6);
        data.set("interface", 7);
        data.set("module", 8);
        data.set("property", 9);
        data.set("event", 10);
        data.set("operator", 11);
        data.set("unit", 12);
        data.set("value", 13);
        data.set("constant", 14);
        data.set("enum", 15);
        data.set("enum-member", 16);
        data.set("enumMember", 16);
        data.set("keyword", 17);
        data.set("snippet", 27);
        data.set("text", 18);
        data.set("color", 19);
        data.set("file", 20);
        data.set("reference", 21);
        data.set("customcolor", 22);
        data.set("folder", 23);
        data.set("type-parameter", 24);
        data.set("typeParameter", 24);
        data.set("account", 25);
        data.set("issue", 26);
        function fromString(value, strict) {
          let res = data.get(value);
          if (typeof res === "undefined" && !strict) {
            res = 9;
          }
          return res;
        }
        CompletionItemKinds2.fromString = fromString;
      })(CompletionItemKinds || (CompletionItemKinds = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
      })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
      (function(SignatureHelpTriggerKind3) {
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
        DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
        DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
      })(DocumentHighlightKind || (DocumentHighlightKind = {}));
      (function(SymbolKinds2) {
        const byKind = /* @__PURE__ */ new Map();
        byKind.set(0, Codicon.symbolFile);
        byKind.set(1, Codicon.symbolModule);
        byKind.set(2, Codicon.symbolNamespace);
        byKind.set(3, Codicon.symbolPackage);
        byKind.set(4, Codicon.symbolClass);
        byKind.set(5, Codicon.symbolMethod);
        byKind.set(6, Codicon.symbolProperty);
        byKind.set(7, Codicon.symbolField);
        byKind.set(8, Codicon.symbolConstructor);
        byKind.set(9, Codicon.symbolEnum);
        byKind.set(10, Codicon.symbolInterface);
        byKind.set(11, Codicon.symbolFunction);
        byKind.set(12, Codicon.symbolVariable);
        byKind.set(13, Codicon.symbolConstant);
        byKind.set(14, Codicon.symbolString);
        byKind.set(15, Codicon.symbolNumber);
        byKind.set(16, Codicon.symbolBoolean);
        byKind.set(17, Codicon.symbolArray);
        byKind.set(18, Codicon.symbolObject);
        byKind.set(19, Codicon.symbolKey);
        byKind.set(20, Codicon.symbolNull);
        byKind.set(21, Codicon.symbolEnumMember);
        byKind.set(22, Codicon.symbolStruct);
        byKind.set(23, Codicon.symbolEvent);
        byKind.set(24, Codicon.symbolOperator);
        byKind.set(25, Codicon.symbolTypeParameter);
        function toIcon(kind) {
          let icon = byKind.get(kind);
          if (!icon) {
            console.info("No codicon found for SymbolKind " + kind);
            icon = Codicon.symbolProperty;
          }
          return icon;
        }
        SymbolKinds2.toIcon = toIcon;
      })(SymbolKinds || (SymbolKinds = {}));
      FoldingRangeKind = class {
        static fromValue(value) {
          switch (value) {
            case "comment":
              return FoldingRangeKind.Comment;
            case "imports":
              return FoldingRangeKind.Imports;
            case "region":
              return FoldingRangeKind.Region;
          }
          return new FoldingRangeKind(value);
        }
        constructor(value) {
          this.value = value;
        }
      };
      FoldingRangeKind.Comment = new FoldingRangeKind("comment");
      FoldingRangeKind.Imports = new FoldingRangeKind("imports");
      FoldingRangeKind.Region = new FoldingRangeKind("region");
      (function(Command2) {
        function is(obj) {
          if (!obj || typeof obj !== "object") {
            return false;
          }
          return typeof obj.id === "string" && typeof obj.title === "string";
        }
        Command2.is = is;
      })(Command || (Command = {}));
      (function(InlayHintKind3) {
        InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
        InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
      })(InlayHintKind || (InlayHintKind = {}));
      TokenizationRegistry2 = new TokenizationRegistry();
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport, CodeActionTriggerType, CompletionItemInsertTextRule, CompletionItemKind, CompletionItemTag, CompletionTriggerKind, ContentWidgetPositionPreference, CursorChangeReason, DefaultEndOfLine, DocumentHighlightKind2, EditorAutoIndentStrategy, EditorOption, EndOfLinePreference, EndOfLineSequence, IndentAction, InjectedTextCursorStops, InlayHintKind2, InlineCompletionTriggerKind2, KeyCode, MarkerSeverity, MarkerTag, MinimapPosition, MouseTargetType, OverlayWidgetPositionPreference, OverviewRulerLane, PositionAffinity, RenderLineNumbersType, RenderMinimap, ScrollType, ScrollbarVisibility, SelectionDirection, SignatureHelpTriggerKind2, SymbolKind, SymbolTag, TextEditorCursorBlinkingStyle, TextEditorCursorStyle, TrackedRangeStickiness, WrappingIndent;
  var init_standaloneEnums = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js"() {
      (function(AccessibilitySupport2) {
        AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
        AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
        AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
      })(AccessibilitySupport || (AccessibilitySupport = {}));
      (function(CodeActionTriggerType2) {
        CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
        CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
      })(CodeActionTriggerType || (CodeActionTriggerType = {}));
      (function(CompletionItemInsertTextRule2) {
        CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
        CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
        CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
      })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
      (function(CompletionItemKind2) {
        CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
        CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
        CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
        CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
        CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
        CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
        CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
        CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
        CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
        CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
        CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
        CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
        CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
        CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
        CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
        CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
        CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
        CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
        CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
        CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
        CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
        CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
        CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
        CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
        CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
        CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
        CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
        CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
      })(CompletionItemKind || (CompletionItemKind = {}));
      (function(CompletionItemTag2) {
        CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
      })(CompletionItemTag || (CompletionItemTag = {}));
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
      })(CompletionTriggerKind || (CompletionTriggerKind = {}));
      (function(ContentWidgetPositionPreference2) {
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
        ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
      })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
      (function(CursorChangeReason2) {
        CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
        CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
        CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
        CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
        CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
        CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
        CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
      })(CursorChangeReason || (CursorChangeReason = {}));
      (function(DefaultEndOfLine2) {
        DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
        DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
      })(DefaultEndOfLine || (DefaultEndOfLine = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
        DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
        DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
      })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
      (function(EditorAutoIndentStrategy2) {
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
        EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
      })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
      (function(EditorOption2) {
        EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
        EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
        EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
        EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
        EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
        EditorOption2[EditorOption2["autoClosingBrackets"] = 5] = "autoClosingBrackets";
        EditorOption2[EditorOption2["autoClosingDelete"] = 6] = "autoClosingDelete";
        EditorOption2[EditorOption2["autoClosingOvertype"] = 7] = "autoClosingOvertype";
        EditorOption2[EditorOption2["autoClosingQuotes"] = 8] = "autoClosingQuotes";
        EditorOption2[EditorOption2["autoIndent"] = 9] = "autoIndent";
        EditorOption2[EditorOption2["automaticLayout"] = 10] = "automaticLayout";
        EditorOption2[EditorOption2["autoSurround"] = 11] = "autoSurround";
        EditorOption2[EditorOption2["bracketPairColorization"] = 12] = "bracketPairColorization";
        EditorOption2[EditorOption2["guides"] = 13] = "guides";
        EditorOption2[EditorOption2["codeLens"] = 14] = "codeLens";
        EditorOption2[EditorOption2["codeLensFontFamily"] = 15] = "codeLensFontFamily";
        EditorOption2[EditorOption2["codeLensFontSize"] = 16] = "codeLensFontSize";
        EditorOption2[EditorOption2["colorDecorators"] = 17] = "colorDecorators";
        EditorOption2[EditorOption2["colorDecoratorsLimit"] = 18] = "colorDecoratorsLimit";
        EditorOption2[EditorOption2["columnSelection"] = 19] = "columnSelection";
        EditorOption2[EditorOption2["comments"] = 20] = "comments";
        EditorOption2[EditorOption2["contextmenu"] = 21] = "contextmenu";
        EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 22] = "copyWithSyntaxHighlighting";
        EditorOption2[EditorOption2["cursorBlinking"] = 23] = "cursorBlinking";
        EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 24] = "cursorSmoothCaretAnimation";
        EditorOption2[EditorOption2["cursorStyle"] = 25] = "cursorStyle";
        EditorOption2[EditorOption2["cursorSurroundingLines"] = 26] = "cursorSurroundingLines";
        EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 27] = "cursorSurroundingLinesStyle";
        EditorOption2[EditorOption2["cursorWidth"] = 28] = "cursorWidth";
        EditorOption2[EditorOption2["disableLayerHinting"] = 29] = "disableLayerHinting";
        EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 30] = "disableMonospaceOptimizations";
        EditorOption2[EditorOption2["domReadOnly"] = 31] = "domReadOnly";
        EditorOption2[EditorOption2["dragAndDrop"] = 32] = "dragAndDrop";
        EditorOption2[EditorOption2["dropIntoEditor"] = 33] = "dropIntoEditor";
        EditorOption2[EditorOption2["emptySelectionClipboard"] = 34] = "emptySelectionClipboard";
        EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 35] = "experimentalWhitespaceRendering";
        EditorOption2[EditorOption2["extraEditorClassName"] = 36] = "extraEditorClassName";
        EditorOption2[EditorOption2["fastScrollSensitivity"] = 37] = "fastScrollSensitivity";
        EditorOption2[EditorOption2["find"] = 38] = "find";
        EditorOption2[EditorOption2["fixedOverflowWidgets"] = 39] = "fixedOverflowWidgets";
        EditorOption2[EditorOption2["folding"] = 40] = "folding";
        EditorOption2[EditorOption2["foldingStrategy"] = 41] = "foldingStrategy";
        EditorOption2[EditorOption2["foldingHighlight"] = 42] = "foldingHighlight";
        EditorOption2[EditorOption2["foldingImportsByDefault"] = 43] = "foldingImportsByDefault";
        EditorOption2[EditorOption2["foldingMaximumRegions"] = 44] = "foldingMaximumRegions";
        EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 45] = "unfoldOnClickAfterEndOfLine";
        EditorOption2[EditorOption2["fontFamily"] = 46] = "fontFamily";
        EditorOption2[EditorOption2["fontInfo"] = 47] = "fontInfo";
        EditorOption2[EditorOption2["fontLigatures"] = 48] = "fontLigatures";
        EditorOption2[EditorOption2["fontSize"] = 49] = "fontSize";
        EditorOption2[EditorOption2["fontWeight"] = 50] = "fontWeight";
        EditorOption2[EditorOption2["fontVariations"] = 51] = "fontVariations";
        EditorOption2[EditorOption2["formatOnPaste"] = 52] = "formatOnPaste";
        EditorOption2[EditorOption2["formatOnType"] = 53] = "formatOnType";
        EditorOption2[EditorOption2["glyphMargin"] = 54] = "glyphMargin";
        EditorOption2[EditorOption2["gotoLocation"] = 55] = "gotoLocation";
        EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 56] = "hideCursorInOverviewRuler";
        EditorOption2[EditorOption2["hover"] = 57] = "hover";
        EditorOption2[EditorOption2["inDiffEditor"] = 58] = "inDiffEditor";
        EditorOption2[EditorOption2["inlineSuggest"] = 59] = "inlineSuggest";
        EditorOption2[EditorOption2["letterSpacing"] = 60] = "letterSpacing";
        EditorOption2[EditorOption2["lightbulb"] = 61] = "lightbulb";
        EditorOption2[EditorOption2["lineDecorationsWidth"] = 62] = "lineDecorationsWidth";
        EditorOption2[EditorOption2["lineHeight"] = 63] = "lineHeight";
        EditorOption2[EditorOption2["lineNumbers"] = 64] = "lineNumbers";
        EditorOption2[EditorOption2["lineNumbersMinChars"] = 65] = "lineNumbersMinChars";
        EditorOption2[EditorOption2["linkedEditing"] = 66] = "linkedEditing";
        EditorOption2[EditorOption2["links"] = 67] = "links";
        EditorOption2[EditorOption2["matchBrackets"] = 68] = "matchBrackets";
        EditorOption2[EditorOption2["minimap"] = 69] = "minimap";
        EditorOption2[EditorOption2["mouseStyle"] = 70] = "mouseStyle";
        EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 71] = "mouseWheelScrollSensitivity";
        EditorOption2[EditorOption2["mouseWheelZoom"] = 72] = "mouseWheelZoom";
        EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 73] = "multiCursorMergeOverlapping";
        EditorOption2[EditorOption2["multiCursorModifier"] = 74] = "multiCursorModifier";
        EditorOption2[EditorOption2["multiCursorPaste"] = 75] = "multiCursorPaste";
        EditorOption2[EditorOption2["multiCursorLimit"] = 76] = "multiCursorLimit";
        EditorOption2[EditorOption2["occurrencesHighlight"] = 77] = "occurrencesHighlight";
        EditorOption2[EditorOption2["overviewRulerBorder"] = 78] = "overviewRulerBorder";
        EditorOption2[EditorOption2["overviewRulerLanes"] = 79] = "overviewRulerLanes";
        EditorOption2[EditorOption2["padding"] = 80] = "padding";
        EditorOption2[EditorOption2["parameterHints"] = 81] = "parameterHints";
        EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 82] = "peekWidgetDefaultFocus";
        EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 83] = "definitionLinkOpensInPeek";
        EditorOption2[EditorOption2["quickSuggestions"] = 84] = "quickSuggestions";
        EditorOption2[EditorOption2["quickSuggestionsDelay"] = 85] = "quickSuggestionsDelay";
        EditorOption2[EditorOption2["readOnly"] = 86] = "readOnly";
        EditorOption2[EditorOption2["renameOnType"] = 87] = "renameOnType";
        EditorOption2[EditorOption2["renderControlCharacters"] = 88] = "renderControlCharacters";
        EditorOption2[EditorOption2["renderFinalNewline"] = 89] = "renderFinalNewline";
        EditorOption2[EditorOption2["renderLineHighlight"] = 90] = "renderLineHighlight";
        EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 91] = "renderLineHighlightOnlyWhenFocus";
        EditorOption2[EditorOption2["renderValidationDecorations"] = 92] = "renderValidationDecorations";
        EditorOption2[EditorOption2["renderWhitespace"] = 93] = "renderWhitespace";
        EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 94] = "revealHorizontalRightPadding";
        EditorOption2[EditorOption2["roundedSelection"] = 95] = "roundedSelection";
        EditorOption2[EditorOption2["rulers"] = 96] = "rulers";
        EditorOption2[EditorOption2["scrollbar"] = 97] = "scrollbar";
        EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 98] = "scrollBeyondLastColumn";
        EditorOption2[EditorOption2["scrollBeyondLastLine"] = 99] = "scrollBeyondLastLine";
        EditorOption2[EditorOption2["scrollPredominantAxis"] = 100] = "scrollPredominantAxis";
        EditorOption2[EditorOption2["selectionClipboard"] = 101] = "selectionClipboard";
        EditorOption2[EditorOption2["selectionHighlight"] = 102] = "selectionHighlight";
        EditorOption2[EditorOption2["selectOnLineNumbers"] = 103] = "selectOnLineNumbers";
        EditorOption2[EditorOption2["showFoldingControls"] = 104] = "showFoldingControls";
        EditorOption2[EditorOption2["showUnused"] = 105] = "showUnused";
        EditorOption2[EditorOption2["snippetSuggestions"] = 106] = "snippetSuggestions";
        EditorOption2[EditorOption2["smartSelect"] = 107] = "smartSelect";
        EditorOption2[EditorOption2["smoothScrolling"] = 108] = "smoothScrolling";
        EditorOption2[EditorOption2["stickyScroll"] = 109] = "stickyScroll";
        EditorOption2[EditorOption2["stickyTabStops"] = 110] = "stickyTabStops";
        EditorOption2[EditorOption2["stopRenderingLineAfter"] = 111] = "stopRenderingLineAfter";
        EditorOption2[EditorOption2["suggest"] = 112] = "suggest";
        EditorOption2[EditorOption2["suggestFontSize"] = 113] = "suggestFontSize";
        EditorOption2[EditorOption2["suggestLineHeight"] = 114] = "suggestLineHeight";
        EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 115] = "suggestOnTriggerCharacters";
        EditorOption2[EditorOption2["suggestSelection"] = 116] = "suggestSelection";
        EditorOption2[EditorOption2["tabCompletion"] = 117] = "tabCompletion";
        EditorOption2[EditorOption2["tabIndex"] = 118] = "tabIndex";
        EditorOption2[EditorOption2["unicodeHighlighting"] = 119] = "unicodeHighlighting";
        EditorOption2[EditorOption2["unusualLineTerminators"] = 120] = "unusualLineTerminators";
        EditorOption2[EditorOption2["useShadowDOM"] = 121] = "useShadowDOM";
        EditorOption2[EditorOption2["useTabStops"] = 122] = "useTabStops";
        EditorOption2[EditorOption2["wordBreak"] = 123] = "wordBreak";
        EditorOption2[EditorOption2["wordSeparators"] = 124] = "wordSeparators";
        EditorOption2[EditorOption2["wordWrap"] = 125] = "wordWrap";
        EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 126] = "wordWrapBreakAfterCharacters";
        EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 127] = "wordWrapBreakBeforeCharacters";
        EditorOption2[EditorOption2["wordWrapColumn"] = 128] = "wordWrapColumn";
        EditorOption2[EditorOption2["wordWrapOverride1"] = 129] = "wordWrapOverride1";
        EditorOption2[EditorOption2["wordWrapOverride2"] = 130] = "wordWrapOverride2";
        EditorOption2[EditorOption2["wrappingIndent"] = 131] = "wrappingIndent";
        EditorOption2[EditorOption2["wrappingStrategy"] = 132] = "wrappingStrategy";
        EditorOption2[EditorOption2["showDeprecated"] = 133] = "showDeprecated";
        EditorOption2[EditorOption2["inlayHints"] = 134] = "inlayHints";
        EditorOption2[EditorOption2["editorClassName"] = 135] = "editorClassName";
        EditorOption2[EditorOption2["pixelRatio"] = 136] = "pixelRatio";
        EditorOption2[EditorOption2["tabFocusMode"] = 137] = "tabFocusMode";
        EditorOption2[EditorOption2["layoutInfo"] = 138] = "layoutInfo";
        EditorOption2[EditorOption2["wrappingInfo"] = 139] = "wrappingInfo";
      })(EditorOption || (EditorOption = {}));
      (function(EndOfLinePreference2) {
        EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
        EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
        EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
      })(EndOfLinePreference || (EndOfLinePreference = {}));
      (function(EndOfLineSequence2) {
        EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
        EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
      })(EndOfLineSequence || (EndOfLineSequence = {}));
      (function(IndentAction2) {
        IndentAction2[IndentAction2["None"] = 0] = "None";
        IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
        IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
        IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
      })(IndentAction || (IndentAction = {}));
      (function(InjectedTextCursorStops3) {
        InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
        InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
      })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
      (function(InlayHintKind3) {
        InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
        InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
      })(InlayHintKind2 || (InlayHintKind2 = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
      })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
      (function(KeyCode2) {
        KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
        KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
        KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
        KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
        KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
        KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
        KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
        KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
        KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
        KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
        KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
        KeyCode2[KeyCode2["Space"] = 10] = "Space";
        KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
        KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
        KeyCode2[KeyCode2["End"] = 13] = "End";
        KeyCode2[KeyCode2["Home"] = 14] = "Home";
        KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
        KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
        KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
        KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
        KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
        KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
        KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
        KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
        KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
        KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
        KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
        KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
        KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
        KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
        KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
        KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
        KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
        KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
        KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
        KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
        KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
        KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
        KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
        KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
        KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
        KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
        KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
        KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
        KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
        KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
        KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
        KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
        KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
        KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
        KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
        KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
        KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
        KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
        KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
        KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
        KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
        KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
        KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
        KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
        KeyCode2[KeyCode2["F1"] = 59] = "F1";
        KeyCode2[KeyCode2["F2"] = 60] = "F2";
        KeyCode2[KeyCode2["F3"] = 61] = "F3";
        KeyCode2[KeyCode2["F4"] = 62] = "F4";
        KeyCode2[KeyCode2["F5"] = 63] = "F5";
        KeyCode2[KeyCode2["F6"] = 64] = "F6";
        KeyCode2[KeyCode2["F7"] = 65] = "F7";
        KeyCode2[KeyCode2["F8"] = 66] = "F8";
        KeyCode2[KeyCode2["F9"] = 67] = "F9";
        KeyCode2[KeyCode2["F10"] = 68] = "F10";
        KeyCode2[KeyCode2["F11"] = 69] = "F11";
        KeyCode2[KeyCode2["F12"] = 70] = "F12";
        KeyCode2[KeyCode2["F13"] = 71] = "F13";
        KeyCode2[KeyCode2["F14"] = 72] = "F14";
        KeyCode2[KeyCode2["F15"] = 73] = "F15";
        KeyCode2[KeyCode2["F16"] = 74] = "F16";
        KeyCode2[KeyCode2["F17"] = 75] = "F17";
        KeyCode2[KeyCode2["F18"] = 76] = "F18";
        KeyCode2[KeyCode2["F19"] = 77] = "F19";
        KeyCode2[KeyCode2["NumLock"] = 78] = "NumLock";
        KeyCode2[KeyCode2["ScrollLock"] = 79] = "ScrollLock";
        KeyCode2[KeyCode2["Semicolon"] = 80] = "Semicolon";
        KeyCode2[KeyCode2["Equal"] = 81] = "Equal";
        KeyCode2[KeyCode2["Comma"] = 82] = "Comma";
        KeyCode2[KeyCode2["Minus"] = 83] = "Minus";
        KeyCode2[KeyCode2["Period"] = 84] = "Period";
        KeyCode2[KeyCode2["Slash"] = 85] = "Slash";
        KeyCode2[KeyCode2["Backquote"] = 86] = "Backquote";
        KeyCode2[KeyCode2["BracketLeft"] = 87] = "BracketLeft";
        KeyCode2[KeyCode2["Backslash"] = 88] = "Backslash";
        KeyCode2[KeyCode2["BracketRight"] = 89] = "BracketRight";
        KeyCode2[KeyCode2["Quote"] = 90] = "Quote";
        KeyCode2[KeyCode2["OEM_8"] = 91] = "OEM_8";
        KeyCode2[KeyCode2["IntlBackslash"] = 92] = "IntlBackslash";
        KeyCode2[KeyCode2["Numpad0"] = 93] = "Numpad0";
        KeyCode2[KeyCode2["Numpad1"] = 94] = "Numpad1";
        KeyCode2[KeyCode2["Numpad2"] = 95] = "Numpad2";
        KeyCode2[KeyCode2["Numpad3"] = 96] = "Numpad3";
        KeyCode2[KeyCode2["Numpad4"] = 97] = "Numpad4";
        KeyCode2[KeyCode2["Numpad5"] = 98] = "Numpad5";
        KeyCode2[KeyCode2["Numpad6"] = 99] = "Numpad6";
        KeyCode2[KeyCode2["Numpad7"] = 100] = "Numpad7";
        KeyCode2[KeyCode2["Numpad8"] = 101] = "Numpad8";
        KeyCode2[KeyCode2["Numpad9"] = 102] = "Numpad9";
        KeyCode2[KeyCode2["NumpadMultiply"] = 103] = "NumpadMultiply";
        KeyCode2[KeyCode2["NumpadAdd"] = 104] = "NumpadAdd";
        KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode2[KeyCode2["NumpadSubtract"] = 106] = "NumpadSubtract";
        KeyCode2[KeyCode2["NumpadDecimal"] = 107] = "NumpadDecimal";
        KeyCode2[KeyCode2["NumpadDivide"] = 108] = "NumpadDivide";
        KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
        KeyCode2[KeyCode2["ABNT_C1"] = 110] = "ABNT_C1";
        KeyCode2[KeyCode2["ABNT_C2"] = 111] = "ABNT_C2";
        KeyCode2[KeyCode2["AudioVolumeMute"] = 112] = "AudioVolumeMute";
        KeyCode2[KeyCode2["AudioVolumeUp"] = 113] = "AudioVolumeUp";
        KeyCode2[KeyCode2["AudioVolumeDown"] = 114] = "AudioVolumeDown";
        KeyCode2[KeyCode2["BrowserSearch"] = 115] = "BrowserSearch";
        KeyCode2[KeyCode2["BrowserHome"] = 116] = "BrowserHome";
        KeyCode2[KeyCode2["BrowserBack"] = 117] = "BrowserBack";
        KeyCode2[KeyCode2["BrowserForward"] = 118] = "BrowserForward";
        KeyCode2[KeyCode2["MediaTrackNext"] = 119] = "MediaTrackNext";
        KeyCode2[KeyCode2["MediaTrackPrevious"] = 120] = "MediaTrackPrevious";
        KeyCode2[KeyCode2["MediaStop"] = 121] = "MediaStop";
        KeyCode2[KeyCode2["MediaPlayPause"] = 122] = "MediaPlayPause";
        KeyCode2[KeyCode2["LaunchMediaPlayer"] = 123] = "LaunchMediaPlayer";
        KeyCode2[KeyCode2["LaunchMail"] = 124] = "LaunchMail";
        KeyCode2[KeyCode2["LaunchApp2"] = 125] = "LaunchApp2";
        KeyCode2[KeyCode2["Clear"] = 126] = "Clear";
        KeyCode2[KeyCode2["MAX_VALUE"] = 127] = "MAX_VALUE";
      })(KeyCode || (KeyCode = {}));
      (function(MarkerSeverity2) {
        MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
        MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
        MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
        MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
      })(MarkerSeverity || (MarkerSeverity = {}));
      (function(MarkerTag2) {
        MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
        MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
      })(MarkerTag || (MarkerTag = {}));
      (function(MinimapPosition3) {
        MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
        MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
      })(MinimapPosition || (MinimapPosition = {}));
      (function(MouseTargetType2) {
        MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
        MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
        MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
        MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
        MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
        MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
        MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
        MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
        MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
        MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
        MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
        MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
        MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
        MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
      })(MouseTargetType || (MouseTargetType = {}));
      (function(OverlayWidgetPositionPreference2) {
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
        OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
      })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
      (function(OverviewRulerLane3) {
        OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
        OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
        OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
        OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
      })(OverviewRulerLane || (OverviewRulerLane = {}));
      (function(PositionAffinity2) {
        PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
        PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
        PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
        PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
        PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
      })(PositionAffinity || (PositionAffinity = {}));
      (function(RenderLineNumbersType2) {
        RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
        RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
        RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
        RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
        RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
      })(RenderLineNumbersType || (RenderLineNumbersType = {}));
      (function(RenderMinimap2) {
        RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
        RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
        RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
      })(RenderMinimap || (RenderMinimap = {}));
      (function(ScrollType2) {
        ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
        ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
      })(ScrollType || (ScrollType = {}));
      (function(ScrollbarVisibility2) {
        ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
        ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
      })(ScrollbarVisibility || (ScrollbarVisibility = {}));
      (function(SelectionDirection2) {
        SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
        SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
      })(SelectionDirection || (SelectionDirection = {}));
      (function(SignatureHelpTriggerKind3) {
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
      (function(SymbolKind2) {
        SymbolKind2[SymbolKind2["File"] = 0] = "File";
        SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
        SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
        SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
        SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
        SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
        SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
        SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
        SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
        SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
        SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
        SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
        SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
        SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
        SymbolKind2[SymbolKind2["String"] = 14] = "String";
        SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
        SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
        SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
        SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
        SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
        SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
        SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
        SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
        SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
        SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
        SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
      })(SymbolKind || (SymbolKind = {}));
      (function(SymbolTag2) {
        SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
      })(SymbolTag || (SymbolTag = {}));
      (function(TextEditorCursorBlinkingStyle2) {
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
        TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
      })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
      (function(TextEditorCursorStyle2) {
        TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
        TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
        TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
        TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
        TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
        TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
      })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
      (function(TrackedRangeStickiness2) {
        TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
      })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
      (function(WrappingIndent2) {
        WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
        WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
        WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
        WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
      })(WrappingIndent || (WrappingIndent = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      languages: void 0,
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position,
      Range,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI,
      Token
    };
  }
  var KeyMod;
  var init_editorBaseApi = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js"() {
      init_cancellation();
      init_event();
      init_keyCodes();
      init_uri();
      init_position();
      init_range();
      init_selection();
      init_languages();
      init_standaloneEnums();
      KeyMod = class {
        static chord(firstPart, secondPart) {
          return KeyChord(firstPart, secondPart);
        }
      };
      KeyMod.CtrlCmd = 2048;
      KeyMod.Shift = 1024;
      KeyMod.Alt = 512;
      KeyMod.WinCtrl = 256;
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
  function once2(computeFn) {
    const cache = {};
    return (input) => {
      if (!cache.hasOwnProperty(input)) {
        cache[input] = computeFn(input);
      }
      return cache[input];
    };
  }
  var WordCharacterClassifier, getMapForWordSeparators;
  var init_wordCharacterClassifier = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js"() {
      init_characterClassifier();
      WordCharacterClassifier = class extends CharacterClassifier {
        constructor(wordSeparators) {
          super(0);
          for (let i = 0, len = wordSeparators.length; i < len; i++) {
            this.set(wordSeparators.charCodeAt(i), 2);
          }
          this.set(32, 1);
          this.set(9, 1);
        }
      };
      getMapForWordSeparators = once2((input) => new WordCharacterClassifier(input));
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane2, MinimapPosition2, InjectedTextCursorStops2;
  var init_model = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/model.js"() {
      init_objects();
      (function(OverviewRulerLane3) {
        OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
        OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
        OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
        OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
      })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
      (function(MinimapPosition3) {
        MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
        MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
      })(MinimapPosition2 || (MinimapPosition2 = {}));
      (function(InjectedTextCursorStops3) {
        InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
        InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
        InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
      })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);
  }
  var Searcher;
  var init_textModelSearch = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"() {
      init_strings();
      init_wordCharacterClassifier();
      init_position();
      init_range();
      init_model();
      Searcher = class {
        constructor(wordSeparators, searchRegex) {
          this._wordSeparators = wordSeparators;
          this._searchRegex = searchRegex;
          this._prevMatchStartIndex = -1;
          this._prevMatchLength = 0;
        }
        reset(lastIndex) {
          this._searchRegex.lastIndex = lastIndex;
          this._prevMatchStartIndex = -1;
          this._prevMatchLength = 0;
        }
        next(text) {
          const textLength = text.length;
          let m;
          do {
            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
              return null;
            }
            m = this._searchRegex.exec(text);
            if (!m) {
              return null;
            }
            const matchStartIndex = m.index;
            const matchLength = m[0].length;
            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
              if (matchLength === 0) {
                if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
                  this._searchRegex.lastIndex += 2;
                } else {
                  this._searchRegex.lastIndex += 1;
                }
                continue;
              }
              return null;
            }
            this._prevMatchStartIndex = matchStartIndex;
            this._prevMatchLength = matchLength;
            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
              return m;
            }
          } while (m);
          return null;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/assert.js
  function assertNever(value, message = "Unreachable") {
    throw new Error(message);
  }
  function assertFn(condition) {
    if (!condition()) {
      debugger;
      condition();
      onUnexpectedError(new BugIndicatingError("Assertion Failed"));
    }
  }
  function checkAdjacentItems(items, predicate) {
    let i = 0;
    while (i < items.length - 1) {
      const a = items[i];
      const b = items[i + 1];
      if (!predicate(a, b)) {
        return false;
      }
      i++;
    }
    return true;
  }
  var init_assert = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/assert.js"() {
      init_errors();
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
    return src;
  }
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }
  var UnicodeTextModelHighlighter, CodePointHighlighter;
  var init_unicodeTextModelHighlighter = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"() {
      init_range();
      init_textModelSearch();
      init_strings();
      init_assert();
      init_wordHelper();
      UnicodeTextModelHighlighter = class {
        static computeUnicodeHighlights(model, options, range) {
          const startLine = range ? range.startLineNumber : 1;
          const endLine = range ? range.endLineNumber : model.getLineCount();
          const codePointHighlighter = new CodePointHighlighter(options);
          const candidates = codePointHighlighter.getCandidateCodePoints();
          let regex;
          if (candidates === "allNonBasicAscii") {
            regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
          } else {
            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
          }
          const searcher = new Searcher(null, regex);
          const ranges = [];
          let hasMore = false;
          let m;
          let ambiguousCharacterCount = 0;
          let invisibleCharacterCount = 0;
          let nonBasicAsciiCharacterCount = 0;
          forLoop:
            for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
              const lineContent = model.getLineContent(lineNumber);
              const lineLength = lineContent.length;
              searcher.reset(0);
              do {
                m = searcher.next(lineContent);
                if (m) {
                  let startIndex = m.index;
                  let endIndex = m.index + m[0].length;
                  if (startIndex > 0) {
                    const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                    if (isHighSurrogate(charCodeBefore)) {
                      startIndex--;
                    }
                  }
                  if (endIndex + 1 < lineLength) {
                    const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                    if (isHighSurrogate(charCodeBefore)) {
                      endIndex++;
                    }
                  }
                  const str = lineContent.substring(startIndex, endIndex);
                  let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
                  if (word && word.endColumn <= startIndex + 1) {
                    word = null;
                  }
                  const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
                  if (highlightReason !== 0) {
                    if (highlightReason === 3) {
                      ambiguousCharacterCount++;
                    } else if (highlightReason === 2) {
                      invisibleCharacterCount++;
                    } else if (highlightReason === 1) {
                      nonBasicAsciiCharacterCount++;
                    } else {
                      assertNever(highlightReason);
                    }
                    const MAX_RESULT_LENGTH = 1e3;
                    if (ranges.length >= MAX_RESULT_LENGTH) {
                      hasMore = true;
                      break forLoop;
                    }
                    ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
                  }
                }
              } while (m);
            }
          return {
            ranges,
            hasMore,
            ambiguousCharacterCount,
            invisibleCharacterCount,
            nonBasicAsciiCharacterCount
          };
        }
        static computeUnicodeHighlightReason(char, options) {
          const codePointHighlighter = new CodePointHighlighter(options);
          const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
          switch (reason) {
            case 0:
              return null;
            case 2:
              return { kind: 1 };
            case 3: {
              const codePoint = char.codePointAt(0);
              const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
              const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
              return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
            }
            case 1:
              return { kind: 2 };
          }
        }
      };
      CodePointHighlighter = class {
        constructor(options) {
          this.options = options;
          this.allowedCodePoints = new Set(options.allowedCodePoints);
          this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
        }
        getCandidateCodePoints() {
          if (this.options.nonBasicASCII) {
            return "allNonBasicAscii";
          }
          const set = /* @__PURE__ */ new Set();
          if (this.options.invisibleCharacters) {
            for (const cp of InvisibleCharacters.codePoints) {
              if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
                set.add(cp);
              }
            }
          }
          if (this.options.ambiguousCharacters) {
            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
              set.add(cp);
            }
          }
          for (const cp of this.allowedCodePoints) {
            set.delete(cp);
          }
          return set;
        }
        shouldHighlightNonBasicASCII(character, wordContext) {
          const codePoint = character.codePointAt(0);
          if (this.allowedCodePoints.has(codePoint)) {
            return 0;
          }
          if (this.options.nonBasicASCII) {
            return 1;
          }
          let hasBasicASCIICharacters = false;
          let hasNonConfusableNonBasicAsciiCharacter = false;
          if (wordContext) {
            for (const char of wordContext) {
              const codePoint2 = char.codePointAt(0);
              const isBasicASCII2 = isBasicASCII(char);
              hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
              if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
                hasNonConfusableNonBasicAsciiCharacter = true;
              }
            }
          }
          if (!hasBasicASCIICharacters && hasNonConfusableNonBasicAsciiCharacter) {
            return 0;
          }
          if (this.options.invisibleCharacters) {
            if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
              return 2;
            }
          }
          if (this.options.ambiguousCharacters) {
            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
              return 3;
            }
          }
          return 0;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
  var LineRangeMapping, RangeMapping, LineRange;
  var init_linesDiffComputer = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js"() {
      LineRangeMapping = class {
        constructor(originalRange, modifiedRange, innerChanges) {
          this.originalRange = originalRange;
          this.modifiedRange = modifiedRange;
          this.innerChanges = innerChanges;
        }
        toString() {
          return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
        }
      };
      RangeMapping = class {
        constructor(originalRange, modifiedRange) {
          this.originalRange = originalRange;
          this.modifiedRange = modifiedRange;
        }
        toString() {
          return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
        }
      };
      LineRange = class {
        constructor(startLineNumber, endLineNumberExclusive) {
          this.startLineNumber = startLineNumber;
          this.endLineNumberExclusive = endLineNumberExclusive;
        }
        get isEmpty() {
          return this.startLineNumber === this.endLineNumberExclusive;
        }
        delta(offset) {
          return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
        }
        get length() {
          return this.endLineNumberExclusive - this.startLineNumber;
        }
        join(other) {
          return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
        }
        toString() {
          return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
      const currChange = rawChanges[i];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r = firstNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r = lastNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }
  var MINIMUM_MATCHING_CHARACTER_LENGTH, SmartLinesDiffComputer, LineSequence, CharSequence, CharChange, LineChange, DiffComputer;
  var init_smartLinesDiffComputer = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js"() {
      init_diff();
      init_linesDiffComputer();
      init_strings();
      init_range();
      init_assert();
      MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
      SmartLinesDiffComputer = class {
        computeDiff(originalLines, modifiedLines, options) {
          var _a3;
          const diffComputer = new DiffComputer(originalLines, modifiedLines, {
            maxComputationTime: options.maxComputationTimeMs,
            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
            shouldComputeCharChanges: true,
            shouldMakePrettyDiff: true,
            shouldPostProcessCharChanges: true
          });
          const result = diffComputer.computeDiff();
          const changes = [];
          let lastChange = null;
          for (const c of result.changes) {
            let originalRange;
            if (c.originalEndLineNumber === 0) {
              originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
            } else {
              originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
            }
            let modifiedRange;
            if (c.modifiedEndLineNumber === 0) {
              modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
            } else {
              modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
            }
            let change = new LineRangeMapping(originalRange, modifiedRange, (_a3 = c.charChanges) === null || _a3 === void 0 ? void 0 : _a3.map((c2) => new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));
            if (lastChange) {
              if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {
                change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
                changes.pop();
              }
            }
            changes.push(change);
            lastChange = change;
          }
          assertFn(() => {
            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);
          });
          return {
            quitEarly: result.quitEarly,
            changes
          };
        }
      };
      LineSequence = class {
        constructor(lines) {
          const startColumns = [];
          const endColumns = [];
          for (let i = 0, length = lines.length; i < length; i++) {
            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
            endColumns[i] = getLastNonBlankColumn(lines[i], 1);
          }
          this.lines = lines;
          this._startColumns = startColumns;
          this._endColumns = endColumns;
        }
        getElements() {
          const elements = [];
          for (let i = 0, len = this.lines.length; i < len; i++) {
            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
          }
          return elements;
        }
        getStrictElement(index) {
          return this.lines[index];
        }
        getStartLineNumber(i) {
          return i + 1;
        }
        getEndLineNumber(i) {
          return i + 1;
        }
        createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
          const charCodes = [];
          const lineNumbers = [];
          const columns = [];
          let len = 0;
          for (let index = startIndex; index <= endIndex; index++) {
            const lineContent = this.lines[index];
            const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
            const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
            for (let col = startColumn; col < endColumn; col++) {
              charCodes[len] = lineContent.charCodeAt(col - 1);
              lineNumbers[len] = index + 1;
              columns[len] = col;
              len++;
            }
            if (!shouldIgnoreTrimWhitespace && index < endIndex) {
              charCodes[len] = 10;
              lineNumbers[len] = index + 1;
              columns[len] = lineContent.length + 1;
              len++;
            }
          }
          return new CharSequence(charCodes, lineNumbers, columns);
        }
      };
      CharSequence = class {
        constructor(charCodes, lineNumbers, columns) {
          this._charCodes = charCodes;
          this._lineNumbers = lineNumbers;
          this._columns = columns;
        }
        toString() {
          return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
        }
        _assertIndex(index, arr) {
          if (index < 0 || index >= arr.length) {
            throw new Error(`Illegal index`);
          }
        }
        getElements() {
          return this._charCodes;
        }
        getStartLineNumber(i) {
          if (i > 0 && i === this._lineNumbers.length) {
            return this.getEndLineNumber(i - 1);
          }
          this._assertIndex(i, this._lineNumbers);
          return this._lineNumbers[i];
        }
        getEndLineNumber(i) {
          if (i === -1) {
            return this.getStartLineNumber(i + 1);
          }
          this._assertIndex(i, this._lineNumbers);
          if (this._charCodes[i] === 10) {
            return this._lineNumbers[i] + 1;
          }
          return this._lineNumbers[i];
        }
        getStartColumn(i) {
          if (i > 0 && i === this._columns.length) {
            return this.getEndColumn(i - 1);
          }
          this._assertIndex(i, this._columns);
          return this._columns[i];
        }
        getEndColumn(i) {
          if (i === -1) {
            return this.getStartColumn(i + 1);
          }
          this._assertIndex(i, this._columns);
          if (this._charCodes[i] === 10) {
            return 1;
          }
          return this._columns[i] + 1;
        }
      };
      CharChange = class {
        constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
          this.originalStartLineNumber = originalStartLineNumber;
          this.originalStartColumn = originalStartColumn;
          this.originalEndLineNumber = originalEndLineNumber;
          this.originalEndColumn = originalEndColumn;
          this.modifiedStartLineNumber = modifiedStartLineNumber;
          this.modifiedStartColumn = modifiedStartColumn;
          this.modifiedEndLineNumber = modifiedEndLineNumber;
          this.modifiedEndColumn = modifiedEndColumn;
        }
        static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
          const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
          const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
          const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
          const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
          const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
          const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
          const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
          const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
          return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
        }
      };
      LineChange = class {
        constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
          this.originalStartLineNumber = originalStartLineNumber;
          this.originalEndLineNumber = originalEndLineNumber;
          this.modifiedStartLineNumber = modifiedStartLineNumber;
          this.modifiedEndLineNumber = modifiedEndLineNumber;
          this.charChanges = charChanges;
        }
        static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
          let originalStartLineNumber;
          let originalEndLineNumber;
          let modifiedStartLineNumber;
          let modifiedEndLineNumber;
          let charChanges = void 0;
          if (diffChange.originalLength === 0) {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
            originalEndLineNumber = 0;
          } else {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
          }
          if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
            modifiedEndLineNumber = 0;
          } else {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
          }
          if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
              let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
              if (shouldPostProcessCharChanges) {
                rawChanges = postProcessCharChanges(rawChanges);
              }
              charChanges = [];
              for (let i = 0, length = rawChanges.length; i < length; i++) {
                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
              }
            }
          }
          return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
        }
      };
      DiffComputer = class {
        constructor(originalLines, modifiedLines, opts) {
          this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
          this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
          this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
          this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
          this.originalLines = originalLines;
          this.modifiedLines = modifiedLines;
          this.original = new LineSequence(originalLines);
          this.modified = new LineSequence(modifiedLines);
          this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
          this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
        }
        computeDiff() {
          if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
              return {
                quitEarly: false,
                changes: []
              };
            }
            return {
              quitEarly: false,
              changes: [{
                originalStartLineNumber: 1,
                originalEndLineNumber: 1,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: this.modified.lines.length,
                charChanges: void 0
              }]
            };
          }
          if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            return {
              quitEarly: false,
              changes: [{
                originalStartLineNumber: 1,
                originalEndLineNumber: this.original.lines.length,
                modifiedStartLineNumber: 1,
                modifiedEndLineNumber: 1,
                charChanges: void 0
              }]
            };
          }
          const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
          const rawChanges = diffResult.changes;
          const quitEarly = diffResult.quitEarly;
          if (this.shouldIgnoreTrimWhitespace) {
            const lineChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
              lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            }
            return {
              quitEarly,
              changes: lineChanges
            };
          }
          const result = [];
          let originalLineIndex = 0;
          let modifiedLineIndex = 0;
          for (let i = -1, len = rawChanges.length; i < len; i++) {
            const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
            const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
            const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
              const originalLine = this.originalLines[originalLineIndex];
              const modifiedLine = this.modifiedLines[modifiedLineIndex];
              if (originalLine !== modifiedLine) {
                {
                  let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                  let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                  while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                    const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                    const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                    if (originalChar !== modifiedChar) {
                      break;
                    }
                    originalStartColumn--;
                    modifiedStartColumn--;
                  }
                  if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                    this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                  }
                }
                {
                  let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                  let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                  const originalMaxColumn = originalLine.length + 1;
                  const modifiedMaxColumn = modifiedLine.length + 1;
                  while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                    const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                    const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                    if (originalChar !== modifiedChar) {
                      break;
                    }
                    originalEndColumn++;
                    modifiedEndColumn++;
                  }
                  if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                    this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                  }
                }
              }
              originalLineIndex++;
              modifiedLineIndex++;
            }
            if (nextChange) {
              result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
              originalLineIndex += nextChange.originalLength;
              modifiedLineIndex += nextChange.modifiedLength;
            }
          }
          return {
            quitEarly,
            changes: result
          };
        }
        _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
          if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
            return;
          }
          let charChanges = void 0;
          if (this.shouldComputeCharChanges) {
            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
          }
          result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
        }
        _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
          const len = result.length;
          if (len === 0) {
            return false;
          }
          const prevChange = result[len - 1];
          if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
            return false;
          }
          if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
              prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
          }
          if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
            prevChange.originalEndLineNumber = originalLineNumber;
            prevChange.modifiedEndLineNumber = modifiedLineNumber;
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
              prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
          }
          return false;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js
  var SequenceDiff, OffsetRange;
  var init_diffAlgorithm = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js"() {
      SequenceDiff = class {
        constructor(seq1Range, seq2Range) {
          this.seq1Range = seq1Range;
          this.seq2Range = seq2Range;
        }
        reverse() {
          return new SequenceDiff(this.seq2Range, this.seq1Range);
        }
        toString() {
          return `${this.seq1Range} <-> ${this.seq2Range}`;
        }
      };
      OffsetRange = class {
        constructor(start, endExclusive) {
          this.start = start;
          this.endExclusive = endExclusive;
        }
        get isEmpty() {
          return this.start === this.endExclusive;
        }
        delta(offset) {
          return new OffsetRange(this.start + offset, this.endExclusive + offset);
        }
        get length() {
          return this.endExclusive - this.start;
        }
        toString() {
          return `[${this.start}, ${this.endExclusive})`;
        }
        join(other) {
          return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js
  var Array2D;
  var init_utils = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js"() {
      Array2D = class {
        constructor(width, height) {
          this.width = width;
          this.height = height;
          this.array = [];
          this.array = new Array(width * height);
        }
        get(x, y) {
          return this.array[x + y * this.width];
        }
        set(x, y, value) {
          this.array[x + y * this.width] = value;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js
  var DynamicProgrammingDiffing;
  var init_dynamicProgrammingDiffing = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js"() {
      init_diffAlgorithm();
      init_utils();
      DynamicProgrammingDiffing = class {
        compute(sequence1, sequence2, equalityScore) {
          const lcsLengths = new Array2D(sequence1.length, sequence2.length);
          const directions = new Array2D(sequence1.length, sequence2.length);
          const lengths = new Array2D(sequence1.length, sequence2.length);
          for (let s12 = 0; s12 < sequence1.length; s12++) {
            for (let s22 = 0; s22 < sequence2.length; s22++) {
              const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
              const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
              let extendedSeqScore;
              if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
                if (s12 === 0 || s22 === 0) {
                  extendedSeqScore = 0;
                } else {
                  extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
                }
                if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
                  extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
                }
                extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
              } else {
                extendedSeqScore = -1;
              }
              const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
              if (newValue === extendedSeqScore) {
                const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
                lengths.set(s12, s22, prevLen + 1);
                directions.set(s12, s22, 3);
              } else if (newValue === horizontalLen) {
                lengths.set(s12, s22, 0);
                directions.set(s12, s22, 1);
              } else if (newValue === verticalLen) {
                lengths.set(s12, s22, 0);
                directions.set(s12, s22, 2);
              }
              lcsLengths.set(s12, s22, newValue);
            }
          }
          const result = [];
          let lastAligningPosS1 = sequence1.length;
          let lastAligningPosS2 = sequence2.length;
          function reportDecreasingAligningPositions(s12, s22) {
            if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
              result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
            }
            lastAligningPosS1 = s12;
            lastAligningPosS2 = s22;
          }
          let s1 = sequence1.length - 1;
          let s2 = sequence2.length - 1;
          while (s1 >= 0 && s2 >= 0) {
            if (directions.get(s1, s2) === 3) {
              reportDecreasingAligningPositions(s1, s2);
              s1--;
              s2--;
            } else {
              if (directions.get(s1, s2) === 1) {
                s1--;
              } else {
                s2--;
              }
            }
          }
          reportDecreasingAligningPositions(-1, -1);
          result.reverse();
          return result;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js
  function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    let result = sequenceDiffs;
    result = joinSequenceDiffs(sequence1, sequence2, result);
    result = shiftSequenceDiffs(sequence1, sequence2, result);
    return result;
  }
  function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    for (const s of sequenceDiffs) {
      const last = result[result.length - 1];
      if (!last) {
        result.push(s);
        continue;
      }
      if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
        result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
      } else {
        result.push(s);
      }
    }
    return result;
  }
  function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    if (sequenceDiffs.length > 0) {
      result.push(sequenceDiffs[0]);
    }
    for (let i = 1; i < sequenceDiffs.length; i++) {
      const lastResult = result[result.length - 1];
      const cur = sequenceDiffs[i];
      if (cur.seq1Range.isEmpty) {
        let all = true;
        const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;
        for (let i2 = 1; i2 <= length; i2++) {
          if (sequence2.getElement(cur.seq2Range.start - i2) !== sequence2.getElement(cur.seq2Range.endExclusive - i2)) {
            all = false;
            break;
          }
        }
        if (all) {
          result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));
          continue;
        }
      }
      result.push(cur);
    }
    return result;
  }
  function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
      return sequenceDiffs;
    }
    for (let i = 0; i < sequenceDiffs.length; i++) {
      const diff = sequenceDiffs[i];
      if (diff.seq1Range.isEmpty) {
        const seq2PrevEndExclusive = i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1;
        const seq2NextStart = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length;
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);
      } else if (diff.seq2Range.isEmpty) {
        const seq1PrevEndExclusive = i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1;
        const seq1NextStart = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length;
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();
      }
    }
    return sequenceDiffs;
  }
  function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {
    const maxShiftLimit = 20;
    let deltaBefore = 1;
    while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive && sequence2.getElement(diff.seq2Range.start - deltaBefore) === sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
      deltaBefore++;
    }
    deltaBefore--;
    let deltaAfter = 0;
    while (diff.seq2Range.start + deltaAfter < seq2NextStart && sequence2.getElement(diff.seq2Range.start + deltaAfter) === sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
      deltaAfter++;
    }
    if (deltaBefore === 0 && deltaAfter === 0) {
      return diff;
    }
    let bestDelta = 0;
    let bestScore = -1;
    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
      const seq2OffsetStart = diff.seq2Range.start + delta;
      const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
      const seq1Offset = diff.seq1Range.start + delta;
      const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
      if (score2 > bestScore) {
        bestScore = score2;
        bestDelta = delta;
      }
    }
    if (bestDelta !== 0) {
      return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));
    }
    return diff;
  }
  var init_joinSequenceDiffs = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js"() {
      init_diffAlgorithm();
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js
  var MyersDiffAlgorithm, SnakePath, FastInt32Array, FastArrayNegativeIndices;
  var init_myersDiffAlgorithm = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js"() {
      init_diffAlgorithm();
      MyersDiffAlgorithm = class {
        compute(seq1, seq2) {
          if (seq1.length === 0) {
            return [new SequenceDiff(new OffsetRange(0, 0), new OffsetRange(0, seq2.length))];
          } else if (seq2.length === 0) {
            return [new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, 0))];
          }
          function getXAfterSnake(x, y) {
            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {
              x++;
              y++;
            }
            return x;
          }
          let d = 0;
          const V = new FastInt32Array();
          V.set(0, getXAfterSnake(0, 0));
          const paths = new FastArrayNegativeIndices();
          paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
          let k = 0;
          loop:
            while (true) {
              d++;
              for (k = -d; k <= d; k += 2) {
                const maxXofDLineTop = k === d ? -1 : V.get(k + 1);
                const maxXofDLineLeft = k === -d ? -1 : V.get(k - 1) + 1;
                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);
                const y = x - k;
                const newMaxX = getXAfterSnake(x, y);
                V.set(k, newMaxX);
                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);
                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {
                  break loop;
                }
              }
            }
          let path = paths.get(k);
          const result = [];
          let lastAligningPosS1 = seq1.length;
          let lastAligningPosS2 = seq2.length;
          while (true) {
            const endX = path ? path.x + path.length : 0;
            const endY = path ? path.y + path.length : 0;
            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
              result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
            }
            if (!path) {
              break;
            }
            lastAligningPosS1 = path.x;
            lastAligningPosS2 = path.y;
            path = path.prev;
          }
          result.reverse();
          return result;
        }
      };
      SnakePath = class {
        constructor(prev, x, y, length) {
          this.prev = prev;
          this.x = x;
          this.y = y;
          this.length = length;
        }
      };
      FastInt32Array = class {
        constructor() {
          this.positiveArr = new Int32Array(10);
          this.negativeArr = new Int32Array(10);
        }
        get(idx) {
          if (idx < 0) {
            idx = -idx - 1;
            return this.negativeArr[idx];
          } else {
            return this.positiveArr[idx];
          }
        }
        set(idx, value) {
          if (idx < 0) {
            idx = -idx - 1;
            if (idx >= this.negativeArr.length) {
              const arr = this.negativeArr;
              this.negativeArr = new Int32Array(arr.length * 2);
              this.negativeArr.set(arr);
            }
            this.negativeArr[idx] = value;
          } else {
            if (idx >= this.positiveArr.length) {
              const arr = this.positiveArr;
              this.positiveArr = new Int32Array(arr.length * 2);
              this.positiveArr.set(arr);
            }
            this.positiveArr[idx] = value;
          }
        }
      };
      FastArrayNegativeIndices = class {
        constructor() {
          this.positiveArr = [];
          this.negativeArr = [];
        }
        get(idx) {
          if (idx < 0) {
            idx = -idx - 1;
            return this.negativeArr[idx];
          } else {
            return this.positiveArr[idx];
          }
        }
        set(idx, value) {
          if (idx < 0) {
            idx = -idx - 1;
            this.negativeArr[idx] = value;
          } else {
            this.positiveArr[idx] = value;
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js
  function lineRangeMappingFromRangeMappings(alignments) {
    const changes = [];
    for (const g of group(alignments, (a1, a2) => a2.originalRange.startLineNumber - (a1.originalRange.endLineNumber - (a1.originalRange.endColumn > 1 ? 0 : 1)) <= 1 || a2.modifiedRange.startLineNumber - (a1.modifiedRange.endLineNumber - (a1.modifiedRange.endColumn > 1 ? 0 : 1)) <= 1)) {
      const first = g[0];
      const last = g[g.length - 1];
      changes.push(new LineRangeMapping(new LineRange(first.originalRange.startLineNumber, last.originalRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), new LineRange(first.modifiedRange.startLineNumber, last.modifiedRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), g));
    }
    assertFn(() => {
      return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);
    });
    return changes;
  }
  function* group(items, shouldBeGrouped) {
    let currentGroup;
    let last;
    for (const item of items) {
      if (last !== void 0 && shouldBeGrouped(last, item)) {
        currentGroup.push(item);
      } else {
        if (currentGroup) {
          yield currentGroup;
        }
        currentGroup = [item];
      }
      last = item;
    }
    if (currentGroup) {
      yield currentGroup;
    }
  }
  function getIndentation(str) {
    let i = 0;
    while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
      i++;
    }
    return i;
  }
  function getCategoryBoundaryScore(category) {
    return score[category];
  }
  function getCategory(charCode) {
    if (charCode === 10) {
      return 7;
    } else if (charCode === 13) {
      return 6;
    } else if (isSpace(charCode)) {
      return 5;
    } else if (charCode >= 97 && charCode <= 122) {
      return 0;
    } else if (charCode >= 65 && charCode <= 90) {
      return 1;
    } else if (charCode >= 48 && charCode <= 57) {
      return 2;
    } else if (charCode === -1) {
      return 3;
    } else {
      return 4;
    }
  }
  function isSpace(charCode) {
    return charCode === 32 || charCode === 9;
  }
  var StandardLinesDiffComputer, LineSequence2, Slice, score;
  var init_standardLinesDiffComputer = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js"() {
      init_assert();
      init_position();
      init_range();
      init_diffAlgorithm();
      init_dynamicProgrammingDiffing();
      init_joinSequenceDiffs();
      init_myersDiffAlgorithm();
      init_linesDiffComputer();
      StandardLinesDiffComputer = class {
        constructor() {
          this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
          this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
        }
        computeDiff(originalLines, modifiedLines, options) {
          const perfectHashes = /* @__PURE__ */ new Map();
          function getOrCreateHash(text) {
            let hash = perfectHashes.get(text);
            if (hash === void 0) {
              hash = perfectHashes.size;
              perfectHashes.set(text, hash);
            }
            return hash;
          }
          const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));
          const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));
          const sequence1 = new LineSequence2(srcDocLines, originalLines);
          const sequence2 = new LineSequence2(tgtDocLines, modifiedLines);
          let lineAlignments = (() => {
            if (sequence1.length + sequence2.length < 1500) {
              return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
            }
            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
          })();
          lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
          const alignments = [];
          const scanForWhitespaceChanges = (equalLinesCount) => {
            for (let i = 0; i < equalLinesCount; i++) {
              const seq1Offset = seq1LastStart + i;
              const seq2Offset = seq2LastStart + i;
              if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
                const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)));
                for (const a of characterDiffs) {
                  alignments.push(a);
                }
              }
            }
          };
          let seq1LastStart = 0;
          let seq2LastStart = 0;
          for (const diff of lineAlignments) {
            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
            const equalLinesCount = diff.seq1Range.start - seq1LastStart;
            scanForWhitespaceChanges(equalLinesCount);
            seq1LastStart = diff.seq1Range.endExclusive;
            seq2LastStart = diff.seq2Range.endExclusive;
            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff);
            for (const a of characterDiffs) {
              alignments.push(a);
            }
          }
          scanForWhitespaceChanges(originalLines.length - seq1LastStart);
          const changes = lineRangeMappingFromRangeMappings(alignments);
          return {
            quitEarly: false,
            changes
          };
        }
        refineDiff(originalLines, modifiedLines, diff) {
          const sourceSlice = new Slice(originalLines, diff.seq1Range);
          const targetSlice = new Slice(modifiedLines, diff.seq2Range);
          const originalDiffs = sourceSlice.length + targetSlice.length < 500 ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice) : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice);
          let diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, originalDiffs);
          diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);
          const result = diffs.map((d) => new RangeMapping(sourceSlice.translateRange(d.seq1Range).delta(diff.seq1Range.start), targetSlice.translateRange(d.seq2Range).delta(diff.seq2Range.start)));
          return result;
        }
      };
      LineSequence2 = class {
        constructor(trimmedHash, lines) {
          this.trimmedHash = trimmedHash;
          this.lines = lines;
        }
        getElement(offset) {
          return this.trimmedHash[offset];
        }
        get length() {
          return this.trimmedHash.length;
        }
        getBoundaryScore(length) {
          const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
          const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
          return 1e3 - (indentationBefore + indentationAfter);
        }
      };
      Slice = class {
        constructor(lines, lineRange) {
          this.lines = lines;
          this.lineRange = lineRange;
          let chars = 0;
          this.firstCharOnLineOffsets = new Int32Array(lineRange.length);
          for (let i = lineRange.start; i < lineRange.endExclusive; i++) {
            const line = lines[i];
            chars += line.length;
            this.firstCharOnLineOffsets[i - lineRange.start] = chars + 1;
            chars++;
          }
          this.elements = new Int32Array(chars);
          let offset = 0;
          for (let i = lineRange.start; i < lineRange.endExclusive; i++) {
            const line = lines[i];
            for (let i2 = 0; i2 < line.length; i2++) {
              this.elements[offset + i2] = line.charCodeAt(i2);
            }
            offset += line.length;
            if (i < lines.length - 1) {
              this.elements[offset] = "\n".charCodeAt(0);
              offset += 1;
            }
          }
        }
        getElement(offset) {
          return this.elements[offset];
        }
        get length() {
          return this.elements.length;
        }
        getBoundaryScore(length) {
          const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
          const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
          if (prevCategory === 6 && nextCategory === 7) {
            return 0;
          }
          let score2 = 0;
          if (prevCategory !== nextCategory) {
            score2 += 10;
            if (nextCategory === 1) {
              score2 += 1;
            }
          }
          score2 += getCategoryBoundaryScore(prevCategory);
          score2 += getCategoryBoundaryScore(nextCategory);
          return score2;
        }
        translateOffset(offset) {
          let i = 0;
          let j = this.firstCharOnLineOffsets.length;
          while (i < j) {
            const k = Math.floor((i + j) / 2);
            if (this.firstCharOnLineOffsets[k] > offset) {
              j = k;
            } else {
              i = k + 1;
            }
          }
          const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOnLineOffsets[i - 1];
          return new Position(i + 1, offset - offsetOfPrevLineBreak + 1);
        }
        translateRange(range) {
          return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
        }
      };
      score = {
        [0]: 0,
        [1]: 0,
        [2]: 0,
        [3]: 10,
        [4]: 2,
        [5]: 3,
        [6]: 10,
        [7]: 10
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
  var linesDiffComputers;
  var init_linesDiffComputers = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js"() {
      init_smartLinesDiffComputer();
      init_standardLinesDiffComputer();
      linesDiffComputers = {
        smart: new SmartLinesDiffComputer(),
        experimental: new StandardLinesDiffComputer()
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
  var __awaiter2, MirrorModel, EditorSimpleWorker;
  var init_editorSimpleWorker = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"() {
      init_diff();
      init_platform();
      init_uri();
      init_position();
      init_range();
      init_mirrorTextModel();
      init_wordHelper();
      init_linkComputer();
      init_inplaceReplaceSupport();
      init_editorBaseApi();
      init_stopwatch();
      init_unicodeTextModelHighlighter();
      init_linesDiffComputers();
      init_objects();
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      MirrorModel = class extends MirrorTextModel {
        get uri() {
          return this._uri;
        }
        get eol() {
          return this._eol;
        }
        getValue() {
          return this.getText();
        }
        getLinesContent() {
          return this._lines.slice(0);
        }
        getLineCount() {
          return this._lines.length;
        }
        getLineContent(lineNumber) {
          return this._lines[lineNumber - 1];
        }
        getWordAtPosition(position, wordDefinition) {
          const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
          if (wordAtText) {
            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
          }
          return null;
        }
        words(wordDefinition) {
          const lines = this._lines;
          const wordenize = this._wordenize.bind(this);
          let lineNumber = 0;
          let lineText = "";
          let wordRangesIdx = 0;
          let wordRanges = [];
          return {
            *[Symbol.iterator]() {
              while (true) {
                if (wordRangesIdx < wordRanges.length) {
                  const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
                  wordRangesIdx += 1;
                  yield value;
                } else {
                  if (lineNumber < lines.length) {
                    lineText = lines[lineNumber];
                    wordRanges = wordenize(lineText, wordDefinition);
                    wordRangesIdx = 0;
                    lineNumber += 1;
                  } else {
                    break;
                  }
                }
              }
            }
          };
        }
        getLineWords(lineNumber, wordDefinition) {
          const content = this._lines[lineNumber - 1];
          const ranges = this._wordenize(content, wordDefinition);
          const words = [];
          for (const range of ranges) {
            words.push({
              word: content.substring(range.start, range.end),
              startColumn: range.start + 1,
              endColumn: range.end + 1
            });
          }
          return words;
        }
        _wordenize(content, wordDefinition) {
          const result = [];
          let match;
          wordDefinition.lastIndex = 0;
          while (match = wordDefinition.exec(content)) {
            if (match[0].length === 0) {
              break;
            }
            result.push({ start: match.index, end: match.index + match[0].length });
          }
          return result;
        }
        getValueInRange(range) {
          range = this._validateRange(range);
          if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
          }
          const lineEnding = this._eol;
          const startLineIndex = range.startLineNumber - 1;
          const endLineIndex = range.endLineNumber - 1;
          const resultLines = [];
          resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
          for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
          }
          resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
          return resultLines.join(lineEnding);
        }
        offsetAt(position) {
          position = this._validatePosition(position);
          this._ensureLineStarts();
          return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
        }
        positionAt(offset) {
          offset = Math.floor(offset);
          offset = Math.max(0, offset);
          this._ensureLineStarts();
          const out = this._lineStarts.getIndexOf(offset);
          const lineLength = this._lines[out.index].length;
          return {
            lineNumber: 1 + out.index,
            column: 1 + Math.min(out.remainder, lineLength)
          };
        }
        _validateRange(range) {
          const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
          const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
          if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
            return {
              startLineNumber: start.lineNumber,
              startColumn: start.column,
              endLineNumber: end.lineNumber,
              endColumn: end.column
            };
          }
          return range;
        }
        _validatePosition(position) {
          if (!Position.isIPosition(position)) {
            throw new Error("bad position");
          }
          let { lineNumber, column } = position;
          let hasChanged = false;
          if (lineNumber < 1) {
            lineNumber = 1;
            column = 1;
            hasChanged = true;
          } else if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
            column = this._lines[lineNumber - 1].length + 1;
            hasChanged = true;
          } else {
            const maxCharacter = this._lines[lineNumber - 1].length + 1;
            if (column < 1) {
              column = 1;
              hasChanged = true;
            } else if (column > maxCharacter) {
              column = maxCharacter;
              hasChanged = true;
            }
          }
          if (!hasChanged) {
            return position;
          } else {
            return { lineNumber, column };
          }
        }
      };
      EditorSimpleWorker = class {
        constructor(host, foreignModuleFactory) {
          this._host = host;
          this._models = /* @__PURE__ */ Object.create(null);
          this._foreignModuleFactory = foreignModuleFactory;
          this._foreignModule = null;
        }
        dispose() {
          this._models = /* @__PURE__ */ Object.create(null);
        }
        _getModel(uri) {
          return this._models[uri];
        }
        _getModels() {
          const all = [];
          Object.keys(this._models).forEach((key) => all.push(this._models[key]));
          return all;
        }
        acceptNewModel(data) {
          this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
        }
        acceptModelChanged(strURL, e) {
          if (!this._models[strURL]) {
            return;
          }
          const model = this._models[strURL];
          model.onEvents(e);
        }
        acceptRemovedModel(strURL) {
          if (!this._models[strURL]) {
            return;
          }
          delete this._models[strURL];
        }
        computeUnicodeHighlights(url, options, range) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(url);
            if (!model) {
              return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
            }
            return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
          });
        }
        computeDiff(originalUrl, modifiedUrl, options, algorithm) {
          return __awaiter2(this, void 0, void 0, function* () {
            const original = this._getModel(originalUrl);
            const modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
              return null;
            }
            return EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
          });
        }
        static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
          const diffAlgorithm = algorithm === "experimental" ? linesDiffComputers.experimental : linesDiffComputers.smart;
          const originalLines = originalTextModel.getLinesContent();
          const modifiedLines = modifiedTextModel.getLinesContent();
          const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
          const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
          return {
            identical,
            quitEarly: result.quitEarly,
            changes: result.changes.map((m) => {
              var _a3;
              return [m.originalRange.startLineNumber, m.originalRange.endLineNumberExclusive, m.modifiedRange.startLineNumber, m.modifiedRange.endLineNumberExclusive, (_a3 = m.innerChanges) === null || _a3 === void 0 ? void 0 : _a3.map((m2) => [
                m2.originalRange.startLineNumber,
                m2.originalRange.startColumn,
                m2.originalRange.endLineNumber,
                m2.originalRange.endColumn,
                m2.modifiedRange.startLineNumber,
                m2.modifiedRange.startColumn,
                m2.modifiedRange.endLineNumber,
                m2.modifiedRange.endColumn
              ])];
            })
          };
        }
        static _modelsAreIdentical(original, modified) {
          const originalLineCount = original.getLineCount();
          const modifiedLineCount = modified.getLineCount();
          if (originalLineCount !== modifiedLineCount) {
            return false;
          }
          for (let line = 1; line <= originalLineCount; line++) {
            const originalLine = original.getLineContent(line);
            const modifiedLine = modified.getLineContent(line);
            if (originalLine !== modifiedLine) {
              return false;
            }
          }
          return true;
        }
        computeMoreMinimalEdits(modelUrl, edits) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return edits;
            }
            const result = [];
            let lastEol = void 0;
            edits = edits.slice(0).sort((a, b) => {
              if (a.range && b.range) {
                return Range.compareRangesUsingStarts(a.range, b.range);
              }
              const aRng = a.range ? 0 : 1;
              const bRng = b.range ? 0 : 1;
              return aRng - bRng;
            });
            for (let { range, text, eol } of edits) {
              if (typeof eol === "number") {
                lastEol = eol;
              }
              if (Range.isEmpty(range) && !text) {
                continue;
              }
              const original = model.getValueInRange(range);
              text = text.replace(/\r\n|\n|\r/g, model.eol);
              if (original === text) {
                continue;
              }
              if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
                result.push({ range, text });
                continue;
              }
              const changes = stringDiff(original, text, false);
              const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
              for (const change of changes) {
                const start = model.positionAt(editOffset + change.originalStart);
                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                const newEdit = {
                  text: text.substr(change.modifiedStart, change.modifiedLength),
                  range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                };
                if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                  result.push(newEdit);
                }
              }
            }
            if (typeof lastEol === "number") {
              result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
            }
            return result;
          });
        }
        computeLinks(modelUrl) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return null;
            }
            return computeLinks(model);
          });
        }
        textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const sw = new StopWatch(true);
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const seen = /* @__PURE__ */ new Set();
            outer:
              for (const url of modelUrls) {
                const model = this._getModel(url);
                if (!model) {
                  continue;
                }
                for (const word of model.words(wordDefRegExp)) {
                  if (word === leadingWord || !isNaN(Number(word))) {
                    continue;
                  }
                  seen.add(word);
                  if (seen.size > EditorSimpleWorker._suggestionsLimit) {
                    break outer;
                  }
                }
              }
            return { words: Array.from(seen), duration: sw.elapsed() };
          });
        }
        computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return /* @__PURE__ */ Object.create(null);
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const result = /* @__PURE__ */ Object.create(null);
            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
              const words = model.getLineWords(line, wordDefRegExp);
              for (const word of words) {
                if (!isNaN(Number(word.word))) {
                  continue;
                }
                let array = result[word.word];
                if (!array) {
                  array = [];
                  result[word.word] = array;
                }
                array.push({
                  startLineNumber: line,
                  startColumn: word.startColumn,
                  endLineNumber: line,
                  endColumn: word.endColumn
                });
              }
            }
            return result;
          });
        }
        navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
          return __awaiter2(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
              return null;
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            if (range.startColumn === range.endColumn) {
              range = {
                startLineNumber: range.startLineNumber,
                startColumn: range.startColumn,
                endLineNumber: range.endLineNumber,
                endColumn: range.endColumn + 1
              };
            }
            const selectionText = model.getValueInRange(range);
            const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
            if (!wordRange) {
              return null;
            }
            const word = model.getValueInRange(wordRange);
            const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
            return result;
          });
        }
        loadForeignModule(moduleId, createData, foreignHostMethods) {
          const proxyMethodRequest = (method, args) => {
            return this._host.fhr(method, args);
          };
          const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
          const ctx = {
            host: foreignHost,
            getMirrorModels: () => {
              return this._getModels();
            }
          };
          if (this._foreignModuleFactory) {
            this._foreignModule = this._foreignModuleFactory(ctx, createData);
            return Promise.resolve(getAllMethodNames(this._foreignModule));
          }
          return Promise.reject(new Error(`Unexpected usage`));
        }
        fmr(method, args) {
          if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
            return Promise.reject(new Error("Missing requestHandler or method: " + method));
          }
          try {
            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
          } catch (e) {
            return Promise.reject(e);
          }
        }
      };
      EditorSimpleWorker._diffLimit = 1e5;
      EditorSimpleWorker._suggestionsLimit = 1e4;
      if (typeof importScripts === "function") {
        globals.monaco = createMonacoBaseAPI();
      }
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/editor.worker.js
  var editor_worker_exports = {};
  __export(editor_worker_exports, {
    initialize: () => initialize
  });
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      self.postMessage(msg);
    }, (host) => new EditorSimpleWorker(host, foreignModule));
    self.onmessage = (e) => {
      simpleWorker.onmessage(e.data);
    };
  }
  var initialized;
  var init_editor_worker = __esm({
    "node_modules/monaco-editor/esm/vs/editor/editor.worker.js"() {
      init_simpleWorker();
      init_editorSimpleWorker();
      initialized = false;
      self.onmessage = (e) => {
        if (!initialized) {
          initialize(null);
        }
      };
    }
  });

  // node_modules/graphql/version.js
  var require_version = __commonJS({
    "node_modules/graphql/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.versionInfo = exports.version = void 0;
      var version = "16.6.0";
      exports.version = version;
      var versionInfo = Object.freeze({
        major: 16,
        minor: 6,
        patch: 0,
        preReleaseTag: null
      });
      exports.versionInfo = versionInfo;
    }
  });

  // node_modules/graphql/jsutils/devAssert.js
  var require_devAssert = __commonJS({
    "node_modules/graphql/jsutils/devAssert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.devAssert = devAssert;
      function devAssert(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message);
        }
      }
    }
  });

  // node_modules/graphql/jsutils/isPromise.js
  var require_isPromise = __commonJS({
    "node_modules/graphql/jsutils/isPromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPromise = isPromise;
      function isPromise(value) {
        return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
      }
    }
  });

  // node_modules/graphql/jsutils/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/graphql/jsutils/isObjectLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isObjectLike = isObjectLike;
      function isObjectLike(value) {
        return typeof value == "object" && value !== null;
      }
    }
  });

  // node_modules/graphql/jsutils/invariant.js
  var require_invariant = __commonJS({
    "node_modules/graphql/jsutils/invariant.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invariant = invariant;
      function invariant(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message != null ? message : "Unexpected invariant triggered.");
        }
      }
    }
  });

  // node_modules/graphql/language/location.js
  var require_location = __commonJS({
    "node_modules/graphql/language/location.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getLocation = getLocation;
      var _invariant = require_invariant();
      var LineRegExp = /\r\n|[\n\r]/g;
      function getLocation(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match of source.body.matchAll(LineRegExp)) {
          typeof match.index === "number" || (0, _invariant.invariant)(false);
          if (match.index >= position) {
            break;
          }
          lastLineStart = match.index + match[0].length;
          line += 1;
        }
        return {
          line,
          column: position + 1 - lastLineStart
        };
      }
    }
  });

  // node_modules/graphql/language/printLocation.js
  var require_printLocation = __commonJS({
    "node_modules/graphql/language/printLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printLocation = printLocation;
      exports.printSourceLocation = printSourceLocation;
      var _location = require_location();
      function printLocation(location) {
        return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
      }
      function printSourceLocation(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = "".padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
          const subLineIndex = Math.floor(columnNum / 80);
          const subLineColumnNum = columnNum % 80;
          const subLines = [];
          for (let i = 0; i < locationLine.length; i += 80) {
            subLines.push(locationLine.slice(i, i + 80));
          }
          return locationStr + printPrefixedLines([
            [`${lineNum} |`, subLines[0]],
            ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
            ["|", "^".padStart(subLineColumnNum)],
            ["|", subLines[subLineIndex + 1]]
          ]);
        }
        return locationStr + printPrefixedLines([
          [`${lineNum - 1} |`, lines[lineIndex - 1]],
          [`${lineNum} |`, locationLine],
          ["|", "^".padStart(columnNum)],
          [`${lineNum + 1} |`, lines[lineIndex + 1]]
        ]);
      }
      function printPrefixedLines(lines) {
        const existingLines = lines.filter(([_, line]) => line !== void 0);
        const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
        return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
      }
    }
  });

  // node_modules/graphql/error/GraphQLError.js
  var require_GraphQLError = __commonJS({
    "node_modules/graphql/error/GraphQLError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLError = void 0;
      exports.formatError = formatError;
      exports.printError = printError;
      var _isObjectLike = require_isObjectLike();
      var _location = require_location();
      var _printLocation = require_printLocation();
      function toNormalizedOptions(args) {
        const firstArg = args[0];
        if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
          return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
          };
        }
        return firstArg;
      }
      var GraphQLError = class extends Error {
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path !== null && path !== void 0 ? path : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
          const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => (0, _location.getLocation)(loc.source, loc.start));
          const originalExtensions = (0, _isObjectLike.isObjectLike)(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, GraphQLError);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
          }
          return output;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
      exports.GraphQLError = GraphQLError;
      function undefinedIfEmpty(array) {
        return array === void 0 || array.length === 0 ? void 0 : array;
      }
      function printError(error) {
        return error.toString();
      }
      function formatError(error) {
        return error.toJSON();
      }
    }
  });

  // node_modules/graphql/error/syntaxError.js
  var require_syntaxError = __commonJS({
    "node_modules/graphql/error/syntaxError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.syntaxError = syntaxError;
      var _GraphQLError = require_GraphQLError();
      function syntaxError(source, position, description) {
        return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
          source,
          positions: [position]
        });
      }
    }
  });

  // node_modules/graphql/language/ast.js
  var require_ast = __commonJS({
    "node_modules/graphql/language/ast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
      exports.isNode = isNode;
      var Location = class {
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      exports.Location = Location;
      var Token2 = class {
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      exports.Token = Token2;
      var QueryDocumentKeys = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      exports.QueryDocumentKeys = QueryDocumentKeys;
      var kindValues = new Set(Object.keys(QueryDocumentKeys));
      function isNode(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === "string" && kindValues.has(maybeKind);
      }
      var OperationTypeNode;
      exports.OperationTypeNode = OperationTypeNode;
      (function(OperationTypeNode2) {
        OperationTypeNode2["QUERY"] = "query";
        OperationTypeNode2["MUTATION"] = "mutation";
        OperationTypeNode2["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode || (exports.OperationTypeNode = OperationTypeNode = {}));
    }
  });

  // node_modules/graphql/language/directiveLocation.js
  var require_directiveLocation = __commonJS({
    "node_modules/graphql/language/directiveLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DirectiveLocation = void 0;
      var DirectiveLocation;
      exports.DirectiveLocation = DirectiveLocation;
      (function(DirectiveLocation2) {
        DirectiveLocation2["QUERY"] = "QUERY";
        DirectiveLocation2["MUTATION"] = "MUTATION";
        DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation2["FIELD"] = "FIELD";
        DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation2["SCHEMA"] = "SCHEMA";
        DirectiveLocation2["SCALAR"] = "SCALAR";
        DirectiveLocation2["OBJECT"] = "OBJECT";
        DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation2["INTERFACE"] = "INTERFACE";
        DirectiveLocation2["UNION"] = "UNION";
        DirectiveLocation2["ENUM"] = "ENUM";
        DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation || (exports.DirectiveLocation = DirectiveLocation = {}));
    }
  });

  // node_modules/graphql/language/kinds.js
  var require_kinds = __commonJS({
    "node_modules/graphql/language/kinds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Kind = void 0;
      var Kind;
      exports.Kind = Kind;
      (function(Kind2) {
        Kind2["NAME"] = "Name";
        Kind2["DOCUMENT"] = "Document";
        Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind2["SELECTION_SET"] = "SelectionSet";
        Kind2["FIELD"] = "Field";
        Kind2["ARGUMENT"] = "Argument";
        Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind2["INLINE_FRAGMENT"] = "InlineFragment";
        Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind2["VARIABLE"] = "Variable";
        Kind2["INT"] = "IntValue";
        Kind2["FLOAT"] = "FloatValue";
        Kind2["STRING"] = "StringValue";
        Kind2["BOOLEAN"] = "BooleanValue";
        Kind2["NULL"] = "NullValue";
        Kind2["ENUM"] = "EnumValue";
        Kind2["LIST"] = "ListValue";
        Kind2["OBJECT"] = "ObjectValue";
        Kind2["OBJECT_FIELD"] = "ObjectField";
        Kind2["DIRECTIVE"] = "Directive";
        Kind2["NAMED_TYPE"] = "NamedType";
        Kind2["LIST_TYPE"] = "ListType";
        Kind2["NON_NULL_TYPE"] = "NonNullType";
        Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind2["FIELD_DEFINITION"] = "FieldDefinition";
        Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind || (exports.Kind = Kind = {}));
    }
  });

  // node_modules/graphql/language/characterClasses.js
  var require_characterClasses = __commonJS({
    "node_modules/graphql/language/characterClasses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isDigit = isDigit;
      exports.isLetter = isLetter;
      exports.isNameContinue = isNameContinue;
      exports.isNameStart = isNameStart;
      exports.isWhiteSpace = isWhiteSpace;
      function isWhiteSpace(code) {
        return code === 9 || code === 32;
      }
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isLetter(code) {
        return code >= 97 && code <= 122 || code >= 65 && code <= 90;
      }
      function isNameStart(code) {
        return isLetter(code) || code === 95;
      }
      function isNameContinue(code) {
        return isLetter(code) || isDigit(code) || code === 95;
      }
    }
  });

  // node_modules/graphql/language/blockString.js
  var require_blockString = __commonJS({
    "node_modules/graphql/language/blockString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dedentBlockStringLines = dedentBlockStringLines;
      exports.isPrintableAsBlockString = isPrintableAsBlockString;
      exports.printBlockString = printBlockString;
      var _characterClasses = require_characterClasses();
      function dedentBlockStringLines(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for (let i = 0; i < lines.length; ++i) {
          var _firstNonEmptyLine;
          const line = lines[i];
          const indent = leadingWhitespace(line);
          if (indent === line.length) {
            continue;
          }
          firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
          lastNonEmptyLine = i;
          if (i !== 0 && indent < commonIndent) {
            commonIndent = indent;
          }
        }
        return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
      }
      function leadingWhitespace(str) {
        let i = 0;
        while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
          ++i;
        }
        return i;
      }
      function isPrintableAsBlockString(value) {
        if (value === "") {
          return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for (let i = 0; i < value.length; ++i) {
          switch (value.codePointAt(i)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 11:
            case 12:
            case 14:
            case 15:
              return false;
            case 13:
              return false;
            case 10:
              if (isEmptyLine && !seenNonEmptyLine) {
                return false;
              }
              seenNonEmptyLine = true;
              isEmptyLine = true;
              hasIndent = false;
              break;
            case 9:
            case 32:
              hasIndent || (hasIndent = isEmptyLine);
              break;
            default:
              hasCommonIndent && (hasCommonIndent = hasIndent);
              isEmptyLine = false;
          }
        }
        if (isEmptyLine) {
          return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
          return false;
        }
        return true;
      }
      function printBlockString(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0)));
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith("\\");
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = "";
        const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
        if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
          result += "\n";
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
          result += "\n";
        }
        return '"""' + result + '"""';
      }
    }
  });

  // node_modules/graphql/language/tokenKind.js
  var require_tokenKind = __commonJS({
    "node_modules/graphql/language/tokenKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TokenKind = void 0;
      var TokenKind;
      exports.TokenKind = TokenKind;
      (function(TokenKind2) {
        TokenKind2["SOF"] = "<SOF>";
        TokenKind2["EOF"] = "<EOF>";
        TokenKind2["BANG"] = "!";
        TokenKind2["DOLLAR"] = "$";
        TokenKind2["AMP"] = "&";
        TokenKind2["PAREN_L"] = "(";
        TokenKind2["PAREN_R"] = ")";
        TokenKind2["SPREAD"] = "...";
        TokenKind2["COLON"] = ":";
        TokenKind2["EQUALS"] = "=";
        TokenKind2["AT"] = "@";
        TokenKind2["BRACKET_L"] = "[";
        TokenKind2["BRACKET_R"] = "]";
        TokenKind2["BRACE_L"] = "{";
        TokenKind2["PIPE"] = "|";
        TokenKind2["BRACE_R"] = "}";
        TokenKind2["NAME"] = "Name";
        TokenKind2["INT"] = "Int";
        TokenKind2["FLOAT"] = "Float";
        TokenKind2["STRING"] = "String";
        TokenKind2["BLOCK_STRING"] = "BlockString";
        TokenKind2["COMMENT"] = "Comment";
      })(TokenKind || (exports.TokenKind = TokenKind = {}));
    }
  });

  // node_modules/graphql/language/lexer.js
  var require_lexer = __commonJS({
    "node_modules/graphql/language/lexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Lexer = void 0;
      exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _blockString = require_blockString();
      var _characterClasses = require_characterClasses();
      var _tokenKind = require_tokenKind();
      var Lexer = class {
        constructor(source) {
          const startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0);
          this.source = source;
          this.lastToken = startOfFileToken;
          this.token = startOfFileToken;
          this.line = 1;
          this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
          return "Lexer";
        }
        advance() {
          this.lastToken = this.token;
          const token = this.token = this.lookahead();
          return token;
        }
        lookahead() {
          let token = this.token;
          if (token.kind !== _tokenKind.TokenKind.EOF) {
            do {
              if (token.next) {
                token = token.next;
              } else {
                const nextToken = readNextToken(this, token.end);
                token.next = nextToken;
                nextToken.prev = token;
                token = nextToken;
              }
            } while (token.kind === _tokenKind.TokenKind.COMMENT);
          }
          return token;
        }
      };
      exports.Lexer = Lexer;
      function isPunctuatorTokenKind(kind) {
        return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
      }
      function isUnicodeScalarValue(code) {
        return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
      }
      function isSupplementaryCodePoint(body, location) {
        return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
      }
      function isLeadingSurrogate(code) {
        return code >= 55296 && code <= 56319;
      }
      function isTrailingSurrogate(code) {
        return code >= 56320 && code <= 57343;
      }
      function printCodePointAt(lexer, location) {
        const code = lexer.source.body.codePointAt(location);
        if (code === void 0) {
          return _tokenKind.TokenKind.EOF;
        } else if (code >= 32 && code <= 126) {
          const char = String.fromCodePoint(code);
          return char === '"' ? `'"'` : `"${char}"`;
        }
        return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
      }
      function createToken(lexer, kind, start, end, value) {
        const line = lexer.line;
        const col = 1 + start - lexer.lineStart;
        return new _ast.Token(kind, start, end, line, col, value);
      }
      function readNextToken(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          switch (code) {
            case 65279:
            case 9:
            case 32:
            case 44:
              ++position;
              continue;
            case 10:
              ++position;
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 13:
              if (body.charCodeAt(position + 1) === 10) {
                position += 2;
              } else {
                ++position;
              }
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 35:
              return readComment(lexer, position);
            case 33:
              return createToken(lexer, _tokenKind.TokenKind.BANG, position, position + 1);
            case 36:
              return createToken(lexer, _tokenKind.TokenKind.DOLLAR, position, position + 1);
            case 38:
              return createToken(lexer, _tokenKind.TokenKind.AMP, position, position + 1);
            case 40:
              return createToken(lexer, _tokenKind.TokenKind.PAREN_L, position, position + 1);
            case 41:
              return createToken(lexer, _tokenKind.TokenKind.PAREN_R, position, position + 1);
            case 46:
              if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
                return createToken(lexer, _tokenKind.TokenKind.SPREAD, position, position + 3);
              }
              break;
            case 58:
              return createToken(lexer, _tokenKind.TokenKind.COLON, position, position + 1);
            case 61:
              return createToken(lexer, _tokenKind.TokenKind.EQUALS, position, position + 1);
            case 64:
              return createToken(lexer, _tokenKind.TokenKind.AT, position, position + 1);
            case 91:
              return createToken(lexer, _tokenKind.TokenKind.BRACKET_L, position, position + 1);
            case 93:
              return createToken(lexer, _tokenKind.TokenKind.BRACKET_R, position, position + 1);
            case 123:
              return createToken(lexer, _tokenKind.TokenKind.BRACE_L, position, position + 1);
            case 124:
              return createToken(lexer, _tokenKind.TokenKind.PIPE, position, position + 1);
            case 125:
              return createToken(lexer, _tokenKind.TokenKind.BRACE_R, position, position + 1);
            case 34:
              if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
                return readBlockString(lexer, position);
              }
              return readString(lexer, position);
          }
          if ((0, _characterClasses.isDigit)(code) || code === 45) {
            return readNumber(lexer, position, code);
          }
          if ((0, _characterClasses.isNameStart)(code)) {
            return readName(lexer, position);
          }
          throw (0, _syntaxError.syntaxError)(lexer.source, position, code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
        }
        return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
      }
      function readComment(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            break;
          }
        }
        return createToken(lexer, _tokenKind.TokenKind.COMMENT, start, position, body.slice(start + 1, position));
      }
      function readNumber(lexer, start, firstCode) {
        const body = lexer.source.body;
        let position = start;
        let code = firstCode;
        let isFloat = false;
        if (code === 45) {
          code = body.charCodeAt(++position);
        }
        if (code === 48) {
          code = body.charCodeAt(++position);
          if ((0, _characterClasses.isDigit)(code)) {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
          }
        } else {
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46) {
          isFloat = true;
          code = body.charCodeAt(++position);
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 69 || code === 101) {
          isFloat = true;
          code = body.charCodeAt(++position);
          if (code === 43 || code === 45) {
            code = body.charCodeAt(++position);
          }
          position = readDigits(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
          throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
        }
        return createToken(lexer, isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, body.slice(start, position));
      }
      function readDigits(lexer, start, firstCode) {
        if (!(0, _characterClasses.isDigit)(firstCode)) {
          throw (0, _syntaxError.syntaxError)(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
        }
        const body = lexer.source.body;
        let position = start + 1;
        while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
          ++position;
        }
        return position;
      }
      function readString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        let chunkStart = position;
        let value = "";
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34) {
            value += body.slice(chunkStart, position);
            return createToken(lexer, _tokenKind.TokenKind.STRING, start, position + 1, value);
          }
          if (code === 92) {
            value += body.slice(chunkStart, position);
            const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
            value += escape.value;
            position += escape.size;
            chunkStart = position;
            continue;
          }
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
      }
      function readEscapedUnicodeVariableWidth(lexer, position) {
        const body = lexer.source.body;
        let point = 0;
        let size = 3;
        while (size < 12) {
          const code = body.charCodeAt(position + size++);
          if (code === 125) {
            if (size < 5 || !isUnicodeScalarValue(point)) {
              break;
            }
            return {
              value: String.fromCodePoint(point),
              size
            };
          }
          point = point << 4 | readHexDigit(code);
          if (point < 0) {
            break;
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
      }
      function readEscapedUnicodeFixedWidth(lexer, position) {
        const body = lexer.source.body;
        const code = read16BitHexCode(body, position + 2);
        if (isUnicodeScalarValue(code)) {
          return {
            value: String.fromCodePoint(code),
            size: 6
          };
        }
        if (isLeadingSurrogate(code)) {
          if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
            const trailingCode = read16BitHexCode(body, position + 8);
            if (isTrailingSurrogate(trailingCode)) {
              return {
                value: String.fromCodePoint(code, trailingCode),
                size: 12
              };
            }
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
      }
      function read16BitHexCode(body, position) {
        return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
      }
      function readHexDigit(code) {
        return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
      }
      function readEscapedCharacter(lexer, position) {
        const body = lexer.source.body;
        const code = body.charCodeAt(position + 1);
        switch (code) {
          case 34:
            return {
              value: '"',
              size: 2
            };
          case 92:
            return {
              value: "\\",
              size: 2
            };
          case 47:
            return {
              value: "/",
              size: 2
            };
          case 98:
            return {
              value: "\b",
              size: 2
            };
          case 102:
            return {
              value: "\f",
              size: 2
            };
          case 110:
            return {
              value: "\n",
              size: 2
            };
          case 114:
            return {
              value: "\r",
              size: 2
            };
          case 116:
            return {
              value: "	",
              size: 2
            };
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
      }
      function readBlockString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let lineStart = lexer.lineStart;
        let position = start + 3;
        let chunkStart = position;
        let currentLine = "";
        const blockLines = [];
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            const token = createToken(lexer, _tokenKind.TokenKind.BLOCK_STRING, start, position + 3, (0, _blockString.dedentBlockStringLines)(blockLines).join("\n"));
            lexer.line += blockLines.length - 1;
            lexer.lineStart = lineStart;
            return token;
          }
          if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
            currentLine += body.slice(chunkStart, position);
            chunkStart = position + 1;
            position += 4;
            continue;
          }
          if (code === 10 || code === 13) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            if (code === 13 && body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            currentLine = "";
            chunkStart = position;
            lineStart = position;
            continue;
          }
          if (isUnicodeScalarValue(code)) {
            ++position;
          } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
          }
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
      }
      function readName(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if ((0, _characterClasses.isNameContinue)(code)) {
            ++position;
          } else {
            break;
          }
        }
        return createToken(lexer, _tokenKind.TokenKind.NAME, start, position, body.slice(start, position));
      }
    }
  });

  // node_modules/graphql/jsutils/inspect.js
  var require_inspect = __commonJS({
    "node_modules/graphql/jsutils/inspect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inspect = inspect;
      var MAX_ARRAY_LENGTH = 10;
      var MAX_RECURSIVE_DEPTH = 2;
      function inspect(value) {
        return formatValue(value, []);
      }
      function formatValue(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatObjectValue(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray(value, seenValues);
        }
        return formatObject(value, seenValues);
      }
      function isJSONable(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject(object, seenValues) {
        const entries = Object.entries(object);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[" + getObjectTag(object) + "]";
        }
        const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray(array, seenValues) {
        if (array.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[Array]";
        }
        const len = Math.min(MAX_ARRAY_LENGTH, array.length);
        const remaining = array.length - len;
        const items = [];
        for (let i = 0; i < len; ++i) {
          items.push(formatValue(array[i], seenValues));
        }
        if (remaining === 1) {
          items.push("... 1 more item");
        } else if (remaining > 1) {
          items.push(`... ${remaining} more items`);
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag(object) {
        const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object.constructor === "function") {
          const name = object.constructor.name;
          if (typeof name === "string" && name !== "") {
            return name;
          }
        }
        return tag;
      }
    }
  });

  // node_modules/graphql/jsutils/instanceOf.js
  var require_instanceOf = __commonJS({
    "node_modules/graphql/jsutils/instanceOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.instanceOf = void 0;
      var _inspect = require_inspect();
      var instanceOf = false ? function instanceOf2(value, constructor) {
        return value instanceof constructor;
      } : function instanceOf2(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (typeof value === "object" && value !== null) {
          var _value$constructor;
          const className = constructor.prototype[Symbol.toStringTag];
          const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
          if (className === valueClassName) {
            const stringifiedValue = (0, _inspect.inspect)(value);
            throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
          }
        }
        return false;
      };
      exports.instanceOf = instanceOf;
    }
  });

  // node_modules/graphql/language/source.js
  var require_source = __commonJS({
    "node_modules/graphql/language/source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Source = void 0;
      exports.isSource = isSource;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var Source = class {
        constructor(body, name = "GraphQL request", locationOffset = {
          line: 1,
          column: 1
        }) {
          typeof body === "string" || (0, _devAssert.devAssert)(false, `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`);
          this.body = body;
          this.name = name;
          this.locationOffset = locationOffset;
          this.locationOffset.line > 0 || (0, _devAssert.devAssert)(false, "line in locationOffset is 1-indexed and must be positive.");
          this.locationOffset.column > 0 || (0, _devAssert.devAssert)(false, "column in locationOffset is 1-indexed and must be positive.");
        }
        get [Symbol.toStringTag]() {
          return "Source";
        }
      };
      exports.Source = Source;
      function isSource(source) {
        return (0, _instanceOf.instanceOf)(source, Source);
      }
    }
  });

  // node_modules/graphql/language/parser.js
  var require_parser = __commonJS({
    "node_modules/graphql/language/parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Parser = void 0;
      exports.parse = parse;
      exports.parseConstValue = parseConstValue;
      exports.parseType = parseType;
      exports.parseValue = parseValue;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function parse(source, options) {
        const parser = new Parser(source, options);
        return parser.parseDocument();
      }
      function parseValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseValueLiteral(false);
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseConstValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseConstValueLiteral();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseType(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const type = parser.parseTypeReference();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return type;
      }
      var Parser = class {
        constructor(source, options = {}) {
          const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
          this._lexer = new _lexer.Lexer(sourceObj);
          this._options = options;
          this._tokenCounter = 0;
        }
        parseName() {
          const token = this.expectToken(_tokenKind.TokenKind.NAME);
          return this.node(token, {
            kind: _kinds.Kind.NAME,
            value: token.value
          });
        }
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.DOCUMENT,
            definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)
          });
        }
        parseDefinition() {
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
          }
          const hasDescription = this.peekDescription();
          const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaDefinition();
              case "scalar":
                return this.parseScalarTypeDefinition();
              case "type":
                return this.parseObjectTypeDefinition();
              case "interface":
                return this.parseInterfaceTypeDefinition();
              case "union":
                return this.parseUnionTypeDefinition();
              case "enum":
                return this.parseEnumTypeDefinition();
              case "input":
                return this.parseInputObjectTypeDefinition();
              case "directive":
                return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
              throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
            }
            switch (keywordToken.value) {
              case "query":
              case "mutation":
              case "subscription":
                return this.parseOperationDefinition();
              case "fragment":
                return this.parseFragmentDefinition();
              case "extend":
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        parseOperationDefinition() {
          const start = this._lexer.token;
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.node(start, {
              kind: _kinds.Kind.OPERATION_DEFINITION,
              operation: _ast.OperationTypeNode.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet()
            });
          }
          const operation = this.parseOperationType();
          let name;
          if (this.peek(_tokenKind.TokenKind.NAME)) {
            name = this.parseName();
          }
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation,
            name,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseOperationType() {
          const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
          switch (operationToken.value) {
            case "query":
              return _ast.OperationTypeNode.QUERY;
            case "mutation":
              return _ast.OperationTypeNode.MUTATION;
            case "subscription":
              return _ast.OperationTypeNode.SUBSCRIPTION;
          }
          throw this.unexpected(operationToken);
        }
        parseVariableDefinitions() {
          return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
        }
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
            directives: this.parseConstDirectives()
          });
        }
        parseVariable() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.DOLLAR);
          return this.node(start, {
            kind: _kinds.Kind.VARIABLE,
            name: this.parseName()
          });
        }
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.SELECTION_SET,
            selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)
          });
        }
        parseSelection() {
          return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        parseField() {
          const start = this._lexer.token;
          const nameOrAlias = this.parseName();
          let alias;
          let name;
          if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
            alias = nameOrAlias;
            name = this.parseName();
          } else {
            name = nameOrAlias;
          }
          return this.node(start, {
            kind: _kinds.Kind.FIELD,
            alias,
            name,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
          });
        }
        parseArguments(isConst) {
          const item = isConst ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
        }
        parseArgument(isConst = false) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.ARGUMENT,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseConstArgument() {
          return this.parseArgument(true);
        }
        parseFragment() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.SPREAD);
          const hasTypeCondition = this.expectOptionalKeyword("on");
          if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(false)
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseFragmentDefinition() {
          const start = this._lexer.token;
          this.expectKeyword("fragment");
          if (this._options.allowLegacyFragmentVariables === true) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              variableDefinitions: this.parseVariableDefinitions(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        parseFragmentName() {
          if (this._lexer.token.value === "on") {
            throw this.unexpected();
          }
          return this.parseName();
        }
        parseValueLiteral(isConst) {
          const token = this._lexer.token;
          switch (token.kind) {
            case _tokenKind.TokenKind.BRACKET_L:
              return this.parseList(isConst);
            case _tokenKind.TokenKind.BRACE_L:
              return this.parseObject(isConst);
            case _tokenKind.TokenKind.INT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.INT,
                value: token.value
              });
            case _tokenKind.TokenKind.FLOAT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.FLOAT,
                value: token.value
              });
            case _tokenKind.TokenKind.STRING:
            case _tokenKind.TokenKind.BLOCK_STRING:
              return this.parseStringLiteral();
            case _tokenKind.TokenKind.NAME:
              this.advanceLexer();
              switch (token.value) {
                case "true":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: true
                  });
                case "false":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: false
                  });
                case "null":
                  return this.node(token, {
                    kind: _kinds.Kind.NULL
                  });
                default:
                  return this.node(token, {
                    kind: _kinds.Kind.ENUM,
                    value: token.value
                  });
              }
            case _tokenKind.TokenKind.DOLLAR:
              if (isConst) {
                this.expectToken(_tokenKind.TokenKind.DOLLAR);
                if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                  const varName = this._lexer.token.value;
                  throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
                } else {
                  throw this.unexpected(token);
                }
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
          const token = this._lexer.token;
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.STRING,
            value: token.value,
            block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
          });
        }
        parseList(isConst) {
          const item = () => this.parseValueLiteral(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.LIST,
            values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)
          });
        }
        parseObject(isConst) {
          const item = () => this.parseObjectField(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.OBJECT,
            fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)
          });
        }
        parseObjectField(isConst) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_FIELD,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseDirectives(isConst) {
          const directives = [];
          while (this.peek(_tokenKind.TokenKind.AT)) {
            directives.push(this.parseDirective(isConst));
          }
          return directives;
        }
        parseConstDirectives() {
          return this.parseDirectives(true);
        }
        parseDirective(isConst) {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.AT);
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
          });
        }
        parseTypeReference() {
          const start = this._lexer.token;
          let type;
          if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(_tokenKind.TokenKind.BRACKET_R);
            type = this.node(start, {
              kind: _kinds.Kind.LIST_TYPE,
              type: innerType
            });
          } else {
            type = this.parseNamedType();
          }
          if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
            return this.node(start, {
              kind: _kinds.Kind.NON_NULL_TYPE,
              type
            });
          }
          return type;
        }
        parseNamedType() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.NAMED_TYPE,
            name: this.parseName()
          });
        }
        peekDescription() {
          return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
        }
        parseDescription() {
          if (this.peekDescription()) {
            return this.parseStringLiteral();
          }
        }
        parseSchemaDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
          });
        }
        parseOperationTypeDefinition() {
          const start = this._lexer.token;
          const operation = this.parseOperationType();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseNamedType();
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type
          });
        }
        parseScalarTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
            description,
            name,
            directives
          });
        }
        parseObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
        }
        parseFieldsDefinition() {
          return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
        }
        parseFieldDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.FIELD_DEFINITION,
            description,
            name,
            arguments: args,
            type,
            directives
          });
        }
        parseArgumentDefs() {
          return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
        }
        parseInputValueDef() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type = this.parseTypeReference();
          let defaultValue;
          if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
          }
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
            description,
            name,
            type,
            defaultValue,
            directives
          });
        }
        parseInterfaceTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseUnionTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_DEFINITION,
            description,
            name,
            directives,
            types
          });
        }
        parseUnionMemberTypes() {
          return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
        }
        parseEnumTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
            description,
            name,
            directives,
            values
          });
        }
        parseEnumValuesDefinition() {
          return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
        }
        parseEnumValueDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseEnumValueName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
            description,
            name,
            directives
          });
        }
        parseEnumValueName() {
          if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
          }
          return this.parseName();
        }
        parseInputObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name,
            directives,
            fields
          });
        }
        parseInputFieldsDefinition() {
          return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
        }
        parseTypeSystemExtension() {
          const keywordToken = this._lexer.lookahead();
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        parseSchemaExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
          if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
          });
        }
        parseScalarTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          if (directives.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
            name,
            directives
          });
        }
        parseObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseInterfaceTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        parseUnionTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          if (directives.length === 0 && types.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_EXTENSION,
            name,
            directives,
            types
          });
        }
        parseEnumTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
            name,
            directives,
            values
          });
        }
        parseInputObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name,
            directives,
            fields
          });
        }
        parseDirectiveDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("directive");
          this.expectToken(_tokenKind.TokenKind.AT);
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          const repeatable = this.expectOptionalKeyword("repeatable");
          this.expectKeyword("on");
          const locations = this.parseDirectiveLocations();
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE_DEFINITION,
            description,
            name,
            arguments: args,
            repeatable,
            locations
          });
        }
        parseDirectiveLocations() {
          return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
        }
        parseDirectiveLocation() {
          const start = this._lexer.token;
          const name = this.parseName();
          if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {
            return name;
          }
          throw this.unexpected(start);
        }
        node(startToken, node) {
          if (this._options.noLocation !== true) {
            node.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
          }
          return node;
        }
        peek(kind) {
          return this._lexer.token.kind === kind;
        }
        expectToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return token;
          }
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
        }
        expectOptionalToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        expectKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
          } else {
            throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
          }
        }
        expectOptionalKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        unexpected(atToken) {
          const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
          return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
        }
        any(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          while (!this.expectOptionalToken(closeKind)) {
            nodes.push(parseFn.call(this));
          }
          return nodes;
        }
        optionalMany(openKind, parseFn, closeKind) {
          if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          return [];
        }
        many(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        delimitedMany(delimiterKind, parseFn) {
          this.expectOptionalToken(delimiterKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (this.expectOptionalToken(delimiterKind));
          return nodes;
        }
        advanceLexer() {
          const { maxTokens } = this._options;
          const token = this._lexer.advance();
          if (maxTokens !== void 0 && token.kind !== _tokenKind.TokenKind.EOF) {
            ++this._tokenCounter;
            if (this._tokenCounter > maxTokens) {
              throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
            }
          }
        }
      };
      exports.Parser = Parser;
      function getTokenDesc(token) {
        const value = token.value;
        return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
      }
      function getTokenKindDesc(kind) {
        return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
      }
    }
  });

  // node_modules/graphql/jsutils/didYouMean.js
  var require_didYouMean = __commonJS({
    "node_modules/graphql/jsutils/didYouMean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.didYouMean = didYouMean;
      var MAX_SUGGESTIONS = 5;
      function didYouMean(firstArg, secondArg) {
        const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
        let message = " Did you mean ";
        if (subMessage) {
          message += subMessage + " ";
        }
        const suggestions = suggestionsArg.map((x) => `"${x}"`);
        switch (suggestions.length) {
          case 0:
            return "";
          case 1:
            return message + suggestions[0] + "?";
          case 2:
            return message + suggestions[0] + " or " + suggestions[1] + "?";
        }
        const selected = suggestions.slice(0, MAX_SUGGESTIONS);
        const lastItem = selected.pop();
        return message + selected.join(", ") + ", or " + lastItem + "?";
      }
    }
  });

  // node_modules/graphql/jsutils/identityFunc.js
  var require_identityFunc = __commonJS({
    "node_modules/graphql/jsutils/identityFunc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.identityFunc = identityFunc;
      function identityFunc(x) {
        return x;
      }
    }
  });

  // node_modules/graphql/jsutils/keyMap.js
  var require_keyMap = __commonJS({
    "node_modules/graphql/jsutils/keyMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyMap = keyMap;
      function keyMap(list, keyFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = item;
        }
        return result;
      }
    }
  });

  // node_modules/graphql/jsutils/keyValMap.js
  var require_keyValMap = __commonJS({
    "node_modules/graphql/jsutils/keyValMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keyValMap = keyValMap;
      function keyValMap(list, keyFn, valFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = valFn(item);
        }
        return result;
      }
    }
  });

  // node_modules/graphql/jsutils/mapValue.js
  var require_mapValue = __commonJS({
    "node_modules/graphql/jsutils/mapValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapValue = mapValue;
      function mapValue(map, fn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map)) {
          result[key] = fn(map[key], key);
        }
        return result;
      }
    }
  });

  // node_modules/graphql/jsutils/naturalCompare.js
  var require_naturalCompare = __commonJS({
    "node_modules/graphql/jsutils/naturalCompare.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.naturalCompare = naturalCompare;
      function naturalCompare(aStr, bStr) {
        let aIndex = 0;
        let bIndex = 0;
        while (aIndex < aStr.length && bIndex < bStr.length) {
          let aChar = aStr.charCodeAt(aIndex);
          let bChar = bStr.charCodeAt(bIndex);
          if (isDigit(aChar) && isDigit(bChar)) {
            let aNum = 0;
            do {
              ++aIndex;
              aNum = aNum * 10 + aChar - DIGIT_0;
              aChar = aStr.charCodeAt(aIndex);
            } while (isDigit(aChar) && aNum > 0);
            let bNum = 0;
            do {
              ++bIndex;
              bNum = bNum * 10 + bChar - DIGIT_0;
              bChar = bStr.charCodeAt(bIndex);
            } while (isDigit(bChar) && bNum > 0);
            if (aNum < bNum) {
              return -1;
            }
            if (aNum > bNum) {
              return 1;
            }
          } else {
            if (aChar < bChar) {
              return -1;
            }
            if (aChar > bChar) {
              return 1;
            }
            ++aIndex;
            ++bIndex;
          }
        }
        return aStr.length - bStr.length;
      }
      var DIGIT_0 = 48;
      var DIGIT_9 = 57;
      function isDigit(code) {
        return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
      }
    }
  });

  // node_modules/graphql/jsutils/suggestionList.js
  var require_suggestionList = __commonJS({
    "node_modules/graphql/jsutils/suggestionList.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.suggestionList = suggestionList;
      var _naturalCompare = require_naturalCompare();
      function suggestionList(input, options) {
        const optionsByDistance = /* @__PURE__ */ Object.create(null);
        const lexicalDistance = new LexicalDistance(input);
        const threshold = Math.floor(input.length * 0.4) + 1;
        for (const option of options) {
          const distance = lexicalDistance.measure(option, threshold);
          if (distance !== void 0) {
            optionsByDistance[option] = distance;
          }
        }
        return Object.keys(optionsByDistance).sort((a, b) => {
          const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
          return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
        });
      }
      var LexicalDistance = class {
        constructor(input) {
          this._input = input;
          this._inputLowerCase = input.toLowerCase();
          this._inputArray = stringToArray(this._inputLowerCase);
          this._rows = [
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0)
          ];
        }
        measure(option, threshold) {
          if (this._input === option) {
            return 0;
          }
          const optionLowerCase = option.toLowerCase();
          if (this._inputLowerCase === optionLowerCase) {
            return 1;
          }
          let a = stringToArray(optionLowerCase);
          let b = this._inputArray;
          if (a.length < b.length) {
            const tmp = a;
            a = b;
            b = tmp;
          }
          const aLength = a.length;
          const bLength = b.length;
          if (aLength - bLength > threshold) {
            return void 0;
          }
          const rows = this._rows;
          for (let j = 0; j <= bLength; j++) {
            rows[0][j] = j;
          }
          for (let i = 1; i <= aLength; i++) {
            const upRow = rows[(i - 1) % 3];
            const currentRow = rows[i % 3];
            let smallestCell = currentRow[0] = i;
            for (let j = 1; j <= bLength; j++) {
              const cost = a[i - 1] === b[j - 1] ? 0 : 1;
              let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
              if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
                currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
              }
              if (currentCell < smallestCell) {
                smallestCell = currentCell;
              }
              currentRow[j] = currentCell;
            }
            if (smallestCell > threshold) {
              return void 0;
            }
          }
          const distance = rows[aLength % 3][bLength];
          return distance <= threshold ? distance : void 0;
        }
      };
      function stringToArray(str) {
        const strLength = str.length;
        const array = new Array(strLength);
        for (let i = 0; i < strLength; ++i) {
          array[i] = str.charCodeAt(i);
        }
        return array;
      }
    }
  });

  // node_modules/graphql/jsutils/toObjMap.js
  var require_toObjMap = __commonJS({
    "node_modules/graphql/jsutils/toObjMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toObjMap = toObjMap;
      function toObjMap(obj) {
        if (obj == null) {
          return /* @__PURE__ */ Object.create(null);
        }
        if (Object.getPrototypeOf(obj) === null) {
          return obj;
        }
        const map = /* @__PURE__ */ Object.create(null);
        for (const [key, value] of Object.entries(obj)) {
          map[key] = value;
        }
        return map;
      }
    }
  });

  // node_modules/graphql/language/printString.js
  var require_printString = __commonJS({
    "node_modules/graphql/language/printString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printString = printString;
      function printString(str) {
        return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
      }
      var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      function escapedReplacer(str) {
        return escapeSequences[str.charCodeAt(0)];
      }
      var escapeSequences = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // node_modules/graphql/language/visitor.js
  var require_visitor = __commonJS({
    "node_modules/graphql/language/visitor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BREAK = void 0;
      exports.getEnterLeaveForKind = getEnterLeaveForKind;
      exports.getVisitFn = getVisitFn;
      exports.visit = visit;
      exports.visitInParallel = visitInParallel;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var BREAK = Object.freeze({});
      exports.BREAK = BREAK;
      function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
        const enterLeaveMap = /* @__PURE__ */ new Map();
        for (const kind of Object.values(_kinds.Kind)) {
          enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
        }
        let stack = void 0;
        let inArray = Array.isArray(root);
        let keys = [root];
        let index = -1;
        let edits = [];
        let node = root;
        let key = void 0;
        let parent = void 0;
        const path = [];
        const ancestors = [];
        do {
          index++;
          const isLeaving = index === keys.length;
          const isEdited = isLeaving && edits.length !== 0;
          if (isLeaving) {
            key = ancestors.length === 0 ? void 0 : path[path.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
              if (inArray) {
                node = node.slice();
                let editOffset = 0;
                for (const [editKey, editValue] of edits) {
                  const arrayKey = editKey - editOffset;
                  if (editValue === null) {
                    node.splice(arrayKey, 1);
                    editOffset++;
                  } else {
                    node[arrayKey] = editValue;
                  }
                }
              } else {
                node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
                for (const [editKey, editValue] of edits) {
                  node[editKey] = editValue;
                }
              }
            }
            index = stack.index;
            keys = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
          } else if (parent) {
            key = inArray ? index : keys[index];
            node = parent[key];
            if (node === null || node === void 0) {
              continue;
            }
            path.push(key);
          }
          let result;
          if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(false, `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`);
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
          if (result === void 0 && isEdited) {
            edits.push([key, node]);
          }
          if (isLeaving) {
            path.pop();
          } else {
            var _node$kind;
            stack = {
              inArray,
              index,
              keys,
              edits,
              prev: stack
            };
            inArray = Array.isArray(node);
            keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
              ancestors.push(parent);
            }
            parent = node;
          }
        } while (stack !== void 0);
        if (edits.length !== 0) {
          return edits[edits.length - 1][1];
        }
        return root;
      }
      function visitInParallel(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = /* @__PURE__ */ Object.create(null);
        for (const kind of Object.values(_kinds.Kind)) {
          let hasVisitor = false;
          const enterList = new Array(visitors.length).fill(void 0);
          const leaveList = new Array(visitors.length).fill(void 0);
          for (let i = 0; i < visitors.length; ++i) {
            const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i] = enter;
            leaveList[i] = leave;
          }
          if (!hasVisitor) {
            continue;
          }
          const mergedEnterLeave = {
            enter(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _enterList$i;
                  const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                  if (result === false) {
                    skipping[i] = node;
                  } else if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0) {
                    return result;
                  }
                }
              }
            },
            leave(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _leaveList$i;
                  const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                  if (result === BREAK) {
                    skipping[i] = BREAK;
                  } else if (result !== void 0 && result !== false) {
                    return result;
                  }
                } else if (skipping[i] === node) {
                  skipping[i] = null;
                }
              }
            }
          };
          mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
      }
      function getEnterLeaveForKind(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === "object") {
          return kindVisitor;
        } else if (typeof kindVisitor === "function") {
          return {
            enter: kindVisitor,
            leave: void 0
          };
        }
        return {
          enter: visitor.enter,
          leave: visitor.leave
        };
      }
      function getVisitFn(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind(visitor, kind);
        return isLeaving ? leave : enter;
      }
    }
  });

  // node_modules/graphql/language/printer.js
  var require_printer = __commonJS({
    "node_modules/graphql/language/printer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.print = print;
      var _blockString = require_blockString();
      var _printString = require_printString();
      var _visitor = require_visitor();
      function print(ast) {
        return (0, _visitor.visit)(ast, printDocASTReducer);
      }
      var MAX_LINE_LENGTH = 80;
      var printDocASTReducer = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        Document: {
          leave: (node) => join(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
            const prefix = join([
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ], " ");
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block(selections)
        },
        Field: {
          leave({ alias, name, arguments: args, directives, selectionSet }) {
            const prefix = wrap("", alias, ": ") + name;
            let argsLine = prefix + wrap("(", join(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
              argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
            }
            return join([argsLine, join(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name, value }) => name + ": " + value
        },
        FragmentSpread: {
          leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join([
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ], " ")
        },
        FragmentDefinition: {
          leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        },
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name, value }) => name + ": " + value
        },
        Directive: {
          leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
        },
        NamedType: {
          leave: ({ name }) => name
        },
        ListType: {
          leave: ({ type }) => "[" + type + "]"
        },
        NonNullType: {
          leave: ({ type }) => type + "!"
        },
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type }) => operation + ": " + type
        },
        ScalarTypeDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        FieldDefinition: {
          leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        UnionTypeDefinition: {
          leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
        },
        EnumTypeDefinition: {
          leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
        },
        ScalarTypeExtension: {
          leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join([
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        InterfaceTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join([
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ], " ")
        },
        UnionTypeExtension: {
          leave: ({ name, directives, types }) => join([
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ], " ")
        },
        EnumTypeExtension: {
          leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
        }
      };
      function join(maybeArray, separator = "") {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
      }
      function block(array) {
        return wrap("{\n", indent(join(array, "\n")), "\n}");
      }
      function wrap(start, maybeString, end = "") {
        return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
      }
      function indent(str) {
        return wrap("  ", str.replace(/\n/g, "\n  "));
      }
      function hasMultilineItems(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
      }
    }
  });

  // node_modules/graphql/utilities/valueFromASTUntyped.js
  var require_valueFromASTUntyped = __commonJS({
    "node_modules/graphql/utilities/valueFromASTUntyped.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromASTUntyped = valueFromASTUntyped;
      var _keyValMap = require_keyValMap();
      var _kinds = require_kinds();
      function valueFromASTUntyped(valueNode, variables) {
        switch (valueNode.kind) {
          case _kinds.Kind.NULL:
            return null;
          case _kinds.Kind.INT:
            return parseInt(valueNode.value, 10);
          case _kinds.Kind.FLOAT:
            return parseFloat(valueNode.value);
          case _kinds.Kind.STRING:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.BOOLEAN:
            return valueNode.value;
          case _kinds.Kind.LIST:
            return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
          case _kinds.Kind.OBJECT:
            return (0, _keyValMap.keyValMap)(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
          case _kinds.Kind.VARIABLE:
            return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
        }
      }
    }
  });

  // node_modules/graphql/type/assertName.js
  var require_assertName = __commonJS({
    "node_modules/graphql/type/assertName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertEnumValueName = assertEnumValueName;
      exports.assertName = assertName;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _characterClasses = require_characterClasses();
      function assertName(name) {
        name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.length === 0) {
          throw new _GraphQLError.GraphQLError("Expected name to be a non-empty string.");
        }
        for (let i = 1; i < name.length; ++i) {
          if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
            throw new _GraphQLError.GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
          }
        }
        if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
          throw new _GraphQLError.GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
        }
        return name;
      }
      function assertEnumValueName(name) {
        if (name === "true" || name === "false" || name === "null") {
          throw new _GraphQLError.GraphQLError(`Enum values cannot be named: ${name}`);
        }
        return assertName(name);
      }
    }
  });

  // node_modules/graphql/type/definition.js
  var require_definition = __commonJS({
    "node_modules/graphql/type/definition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = void 0;
      exports.argsToArgsConfig = argsToArgsConfig;
      exports.assertAbstractType = assertAbstractType;
      exports.assertCompositeType = assertCompositeType;
      exports.assertEnumType = assertEnumType;
      exports.assertInputObjectType = assertInputObjectType;
      exports.assertInputType = assertInputType;
      exports.assertInterfaceType = assertInterfaceType;
      exports.assertLeafType = assertLeafType;
      exports.assertListType = assertListType;
      exports.assertNamedType = assertNamedType;
      exports.assertNonNullType = assertNonNullType;
      exports.assertNullableType = assertNullableType;
      exports.assertObjectType = assertObjectType;
      exports.assertOutputType = assertOutputType;
      exports.assertScalarType = assertScalarType;
      exports.assertType = assertType;
      exports.assertUnionType = assertUnionType;
      exports.assertWrappingType = assertWrappingType;
      exports.defineArguments = defineArguments;
      exports.getNamedType = getNamedType;
      exports.getNullableType = getNullableType;
      exports.isAbstractType = isAbstractType;
      exports.isCompositeType = isCompositeType;
      exports.isEnumType = isEnumType;
      exports.isInputObjectType = isInputObjectType;
      exports.isInputType = isInputType;
      exports.isInterfaceType = isInterfaceType;
      exports.isLeafType = isLeafType;
      exports.isListType = isListType;
      exports.isNamedType = isNamedType;
      exports.isNonNullType = isNonNullType;
      exports.isNullableType = isNullableType;
      exports.isObjectType = isObjectType;
      exports.isOutputType = isOutputType;
      exports.isRequiredArgument = isRequiredArgument;
      exports.isRequiredInputField = isRequiredInputField;
      exports.isScalarType = isScalarType;
      exports.isType = isType;
      exports.isUnionType = isUnionType;
      exports.isWrappingType = isWrappingType;
      exports.resolveObjMapThunk = resolveObjMapThunk;
      exports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
      var _devAssert = require_devAssert();
      var _didYouMean = require_didYouMean();
      var _identityFunc = require_identityFunc();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _keyMap = require_keyMap();
      var _keyValMap = require_keyValMap();
      var _mapValue = require_mapValue();
      var _suggestionList = require_suggestionList();
      var _toObjMap = require_toObjMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _assertName = require_assertName();
      function isType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
      }
      function assertType(type) {
        if (!isType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`);
        }
        return type;
      }
      function isScalarType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);
      }
      function assertScalarType(type) {
        if (!isScalarType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`);
        }
        return type;
      }
      function isObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);
      }
      function assertObjectType(type) {
        if (!isObjectType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`);
        }
        return type;
      }
      function isInterfaceType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);
      }
      function assertInterfaceType(type) {
        if (!isInterfaceType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`);
        }
        return type;
      }
      function isUnionType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);
      }
      function assertUnionType(type) {
        if (!isUnionType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`);
        }
        return type;
      }
      function isEnumType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);
      }
      function assertEnumType(type) {
        if (!isEnumType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`);
        }
        return type;
      }
      function isInputObjectType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);
      }
      function assertInputObjectType(type) {
        if (!isInputObjectType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Input Object type.`);
        }
        return type;
      }
      function isListType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLList);
      }
      function assertListType(type) {
        if (!isListType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`);
        }
        return type;
      }
      function isNonNullType(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);
      }
      function assertNonNullType(type) {
        if (!isNonNullType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`);
        }
        return type;
      }
      function isInputType(type) {
        return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
      }
      function assertInputType(type) {
        if (!isInputType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`);
        }
        return type;
      }
      function isOutputType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
      }
      function assertOutputType(type) {
        if (!isOutputType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`);
        }
        return type;
      }
      function isLeafType(type) {
        return isScalarType(type) || isEnumType(type);
      }
      function assertLeafType(type) {
        if (!isLeafType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`);
        }
        return type;
      }
      function isCompositeType(type) {
        return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
      }
      function assertCompositeType(type) {
        if (!isCompositeType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`);
        }
        return type;
      }
      function isAbstractType(type) {
        return isInterfaceType(type) || isUnionType(type);
      }
      function assertAbstractType(type) {
        if (!isAbstractType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`);
        }
        return type;
      }
      var GraphQLList = class {
        constructor(ofType) {
          isType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`);
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLList";
        }
        toString() {
          return "[" + String(this.ofType) + "]";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLList = GraphQLList;
      var GraphQLNonNull = class {
        constructor(ofType) {
          isNullableType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL nullable type.`);
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLNonNull";
        }
        toString() {
          return String(this.ofType) + "!";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLNonNull = GraphQLNonNull;
      function isWrappingType(type) {
        return isListType(type) || isNonNullType(type);
      }
      function assertWrappingType(type) {
        if (!isWrappingType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`);
        }
        return type;
      }
      function isNullableType(type) {
        return isType(type) && !isNonNullType(type);
      }
      function assertNullableType(type) {
        if (!isNullableType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`);
        }
        return type;
      }
      function getNullableType(type) {
        if (type) {
          return isNonNullType(type) ? type.ofType : type;
        }
      }
      function isNamedType(type) {
        return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
      }
      function assertNamedType(type) {
        if (!isNamedType(type)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`);
        }
        return type;
      }
      function getNamedType(type) {
        if (type) {
          let unwrappedType = type;
          while (isWrappingType(unwrappedType)) {
            unwrappedType = unwrappedType.ofType;
          }
          return unwrappedType;
        }
      }
      function resolveReadonlyArrayThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      function resolveObjMapThunk(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      var GraphQLScalarType = class {
        constructor(config) {
          var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
          const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.specifiedByURL = config.specifiedByURL;
          this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
          this.parseValue = parseValue;
          this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(false, `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`);
          config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
          if (config.parseLiteral) {
            typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLScalarType";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            specifiedByURL: this.specifiedByURL,
            serialize: this.serialize,
            parseValue: this.parseValue,
            parseLiteral: this.parseLiteral,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLScalarType = GraphQLScalarType;
      var GraphQLObjectType = class {
        constructor(config) {
          var _config$extensionASTN2;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.isTypeOf = config.isTypeOf;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
          this._fields = () => defineFieldMap(config);
          this._interfaces = () => defineInterfaces(config);
          config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            isTypeOf: this.isTypeOf,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLObjectType = GraphQLObjectType;
      function defineInterfaces(config) {
        var _config$interfaces;
        const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);
        Array.isArray(interfaces) || (0, _devAssert.devAssert)(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
        return interfaces;
      }
      function defineFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          var _fieldConfig$args;
          isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field config must be an object.`);
          fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`);
          const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
          isPlainObj(argsConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            args: defineArguments(argsConfig),
            resolve: fieldConfig.resolve,
            subscribe: fieldConfig.subscribe,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function defineArguments(config) {
        return Object.entries(config).map(([argName, argConfig]) => ({
          name: (0, _assertName.assertName)(argName),
          description: argConfig.description,
          type: argConfig.type,
          defaultValue: argConfig.defaultValue,
          deprecationReason: argConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
          astNode: argConfig.astNode
        }));
      }
      function isPlainObj(obj) {
        return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
      }
      function fieldsToFieldsConfig(fields) {
        return (0, _mapValue.mapValue)(fields, (field) => ({
          description: field.description,
          type: field.type,
          args: argsToArgsConfig(field.args),
          resolve: field.resolve,
          subscribe: field.subscribe,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
      }
      function argsToArgsConfig(args) {
        return (0, _keyValMap.keyValMap)(args, (arg) => arg.name, (arg) => ({
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        }));
      }
      function isRequiredArgument(arg) {
        return isNonNullType(arg.type) && arg.defaultValue === void 0;
      }
      var GraphQLInterfaceType = class {
        constructor(config) {
          var _config$extensionASTN3;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
          this._fields = defineFieldMap.bind(void 0, config);
          this._interfaces = defineInterfaces.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInterfaceType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInterfaceType = GraphQLInterfaceType;
      var GraphQLUnionType = class {
        constructor(config) {
          var _config$extensionASTN4;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.resolveType = config.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
          this._types = defineTypes.bind(void 0, config);
          config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLUnionType";
        }
        getTypes() {
          if (typeof this._types === "function") {
            this._types = this._types();
          }
          return this._types;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            types: this.getTypes(),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLUnionType = GraphQLUnionType;
      function defineTypes(config) {
        const types = resolveReadonlyArrayThunk(config.types);
        Array.isArray(types) || (0, _devAssert.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
        return types;
      }
      var GraphQLEnumType = class {
        constructor(config) {
          var _config$extensionASTN5;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
          this._values = defineEnumValues(this.name, config.values);
          this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
          this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLEnumType";
        }
        getValues() {
          return this._values;
        }
        getValue(name) {
          return this._nameLookup[name];
        }
        serialize(outputValue) {
          const enumValue = this._valueLookup.get(outputValue);
          if (enumValue === void 0) {
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
          }
          return enumValue.name;
        }
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            const valueStr = (0, _inspect.inspect)(inputValue);
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
          }
          const enumValue = this.getValue(inputValue);
          if (enumValue == null) {
            throw new _GraphQLError.GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
          }
          return enumValue.value;
        }
        parseLiteral(valueNode, _variables) {
          if (valueNode.kind !== _kinds.Kind.ENUM) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
              nodes: valueNode
            });
          }
          const enumValue = this.getValue(valueNode.value);
          if (enumValue == null) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
              nodes: valueNode
            });
          }
          return enumValue.value;
        }
        toConfig() {
          const values = (0, _keyValMap.keyValMap)(this.getValues(), (value) => value.name, (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            values,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLEnumType = GraphQLEnumType;
      function didYouMeanEnumValue(enumType, unknownValueStr) {
        const allNames = enumType.getValues().map((value) => value.name);
        const suggestedValues = (0, _suggestionList.suggestionList)(unknownValueStr, allNames);
        return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
      }
      function defineEnumValues(typeName, valueMap) {
        isPlainObj(valueMap) || (0, _devAssert.devAssert)(false, `${typeName} values must be an object with value names as keys.`);
        return Object.entries(valueMap).map(([valueName, valueConfig]) => {
          isPlainObj(valueConfig) || (0, _devAssert.devAssert)(false, `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(valueConfig)}.`);
          return {
            name: (0, _assertName.assertEnumValueName)(valueName),
            description: valueConfig.description,
            value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
            deprecationReason: valueConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
            astNode: valueConfig.astNode
          };
        });
      }
      var GraphQLInputObjectType = class {
        constructor(config) {
          var _config$extensionASTN6;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
          this._fields = defineInputFieldMap.bind(void 0, config);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInputObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        toConfig() {
          const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            fields,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLInputObjectType = GraphQLInputObjectType;
      function defineInputFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            defaultValue: fieldConfig.defaultValue,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function isRequiredInputField(field) {
        return isNonNullType(field.type) && field.defaultValue === void 0;
      }
    }
  });

  // node_modules/graphql/utilities/typeComparators.js
  var require_typeComparators = __commonJS({
    "node_modules/graphql/utilities/typeComparators.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.doTypesOverlap = doTypesOverlap;
      exports.isEqualType = isEqualType;
      exports.isTypeSubTypeOf = isTypeSubTypeOf;
      var _definition = require_definition();
      function isEqualType(typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
          return isEqualType(typeA.ofType, typeB.ofType);
        }
        return false;
      }
      function isTypeSubTypeOf(schema, maybeSubType, superType) {
        if (maybeSubType === superType) {
          return true;
        }
        if ((0, _definition.isNonNullType)(superType)) {
          if ((0, _definition.isNonNullType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
        }
        if ((0, _definition.isListType)(superType)) {
          if ((0, _definition.isListType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isListType)(maybeSubType)) {
          return false;
        }
        return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
      }
      function doTypesOverlap(schema, typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isAbstractType)(typeA)) {
          if ((0, _definition.isAbstractType)(typeB)) {
            return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
          }
          return schema.isSubType(typeA, typeB);
        }
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.isSubType(typeB, typeA);
        }
        return false;
      }
    }
  });

  // node_modules/graphql/type/scalars.js
  var require_scalars = __commonJS({
    "node_modules/graphql/type/scalars.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLString = exports.GraphQLInt = exports.GraphQLID = exports.GraphQLFloat = exports.GraphQLBoolean = exports.GRAPHQL_MIN_INT = exports.GRAPHQL_MAX_INT = void 0;
      exports.isSpecifiedScalarType = isSpecifiedScalarType;
      exports.specifiedScalarTypes = void 0;
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var GRAPHQL_MAX_INT = 2147483647;
      exports.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
      var GRAPHQL_MIN_INT = -2147483648;
      exports.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
      var GraphQLInt = new _definition.GraphQLScalarType({
        name: "Int",
        description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isInteger(num)) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(coercedValue)}`);
          }
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue));
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _printer.print)(valueNode)}`, {
              nodes: valueNode
            });
          }
          const num = parseInt(valueNode.value, 10);
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
              nodes: valueNode
            });
          }
          return num;
        }
      });
      exports.GraphQLInt = GraphQLInt;
      var GraphQLFloat = new _definition.GraphQLScalarType({
        name: "Float",
        description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isFinite(num)) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(coercedValue)}`);
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _printer.print)(valueNode)}`, valueNode);
          }
          return parseFloat(valueNode.value);
        }
      });
      exports.GraphQLFloat = GraphQLFloat;
      var GraphQLString = new _definition.GraphQLScalarType({
        name: "String",
        description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (typeof coercedValue === "boolean") {
            return coercedValue ? "true" : "false";
          }
          if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
            return coercedValue.toString();
          }
          throw new _GraphQLError.GraphQLError(`String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING) {
            throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _printer.print)(valueNode)}`, {
              nodes: valueNode
            });
          }
          return valueNode.value;
        }
      });
      exports.GraphQLString = GraphQLString;
      var GraphQLBoolean = new _definition.GraphQLScalarType({
        name: "Boolean",
        description: "The `Boolean` scalar type represents `true` or `false`.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue;
          }
          if (Number.isFinite(coercedValue)) {
            return coercedValue !== 0;
          }
          throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(coercedValue)}`);
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "boolean") {
            throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(inputValue)}`);
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
            throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _printer.print)(valueNode)}`, {
              nodes: valueNode
            });
          }
          return valueNode.value;
        }
      });
      exports.GraphQLBoolean = GraphQLBoolean;
      var GraphQLID = new _definition.GraphQLScalarType({
        name: "ID",
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (Number.isInteger(coercedValue)) {
            return String(coercedValue);
          }
          throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
        },
        parseValue(inputValue) {
          if (typeof inputValue === "string") {
            return inputValue;
          }
          if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
            return inputValue.toString();
          }
          throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`);
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), {
              nodes: valueNode
            });
          }
          return valueNode.value;
        }
      });
      exports.GraphQLID = GraphQLID;
      var specifiedScalarTypes = Object.freeze([
        GraphQLString,
        GraphQLInt,
        GraphQLFloat,
        GraphQLBoolean,
        GraphQLID
      ]);
      exports.specifiedScalarTypes = specifiedScalarTypes;
      function isSpecifiedScalarType(type) {
        return specifiedScalarTypes.some(({ name }) => type.name === name);
      }
      function serializeObject(outputValue) {
        if ((0, _isObjectLike.isObjectLike)(outputValue)) {
          if (typeof outputValue.valueOf === "function") {
            const valueOfResult = outputValue.valueOf();
            if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
              return valueOfResult;
            }
          }
          if (typeof outputValue.toJSON === "function") {
            return outputValue.toJSON();
          }
        }
        return outputValue;
      }
    }
  });

  // node_modules/graphql/type/directives.js
  var require_directives = __commonJS({
    "node_modules/graphql/type/directives.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSpecifiedByDirective = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = void 0;
      exports.assertDirective = assertDirective;
      exports.isDirective = isDirective;
      exports.isSpecifiedDirective = isSpecifiedDirective;
      exports.specifiedDirectives = void 0;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _directiveLocation = require_directiveLocation();
      var _assertName = require_assertName();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function isDirective(directive) {
        return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
      }
      function assertDirective(directive) {
        if (!isDirective(directive)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`);
        }
        return directive;
      }
      var GraphQLDirective = class {
        constructor(config) {
          var _config$isRepeatable, _config$args;
          this.name = (0, _assertName.assertName)(config.name);
          this.description = config.description;
          this.locations = config.locations;
          this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          Array.isArray(config.locations) || (0, _devAssert.devAssert)(false, `@${config.name} locations must be an Array.`);
          const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
          (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(false, `@${config.name} args must be an object with argument names as keys.`);
          this.args = (0, _definition.defineArguments)(args);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLDirective";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            locations: this.locations,
            args: (0, _definition.argsToArgsConfig)(this.args),
            isRepeatable: this.isRepeatable,
            extensions: this.extensions,
            astNode: this.astNode
          };
        }
        toString() {
          return "@" + this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports.GraphQLDirective = GraphQLDirective;
      var GraphQLIncludeDirective = new GraphQLDirective({
        name: "include",
        description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Included when true."
          }
        }
      });
      exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
      var GraphQLSkipDirective = new GraphQLDirective({
        name: "skip",
        description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Skipped when true."
          }
        }
      });
      exports.GraphQLSkipDirective = GraphQLSkipDirective;
      var DEFAULT_DEPRECATION_REASON = "No longer supported";
      exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
      var GraphQLDeprecatedDirective = new GraphQLDirective({
        name: "deprecated",
        description: "Marks an element of a GraphQL schema as no longer supported.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ENUM_VALUE
        ],
        args: {
          reason: {
            type: _scalars.GraphQLString,
            description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
            defaultValue: DEFAULT_DEPRECATION_REASON
          }
        }
      });
      exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
      var GraphQLSpecifiedByDirective = new GraphQLDirective({
        name: "specifiedBy",
        description: "Exposes a URL that specifies the behavior of this scalar.",
        locations: [_directiveLocation.DirectiveLocation.SCALAR],
        args: {
          url: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            description: "The URL that specifies the behavior of this scalar."
          }
        }
      });
      exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
      var specifiedDirectives = Object.freeze([
        GraphQLIncludeDirective,
        GraphQLSkipDirective,
        GraphQLDeprecatedDirective,
        GraphQLSpecifiedByDirective
      ]);
      exports.specifiedDirectives = specifiedDirectives;
      function isSpecifiedDirective(directive) {
        return specifiedDirectives.some(({ name }) => name === directive.name);
      }
    }
  });

  // node_modules/graphql/jsutils/isIterableObject.js
  var require_isIterableObject = __commonJS({
    "node_modules/graphql/jsutils/isIterableObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIterableObject = isIterableObject;
      function isIterableObject(maybeIterable) {
        return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
      }
    }
  });

  // node_modules/graphql/utilities/astFromValue.js
  var require_astFromValue = __commonJS({
    "node_modules/graphql/utilities/astFromValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.astFromValue = astFromValue;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function astFromValue(value, type) {
        if ((0, _definition.isNonNullType)(type)) {
          const astValue = astFromValue(value, type.ofType);
          if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
            return null;
          }
          return astValue;
        }
        if (value === null) {
          return {
            kind: _kinds.Kind.NULL
          };
        }
        if (value === void 0) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(value)) {
            const valuesNodes = [];
            for (const item of value) {
              const itemNode = astFromValue(item, itemType);
              if (itemNode != null) {
                valuesNodes.push(itemNode);
              }
            }
            return {
              kind: _kinds.Kind.LIST,
              values: valuesNodes
            };
          }
          return astFromValue(value, itemType);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(value)) {
            return null;
          }
          const fieldNodes = [];
          for (const field of Object.values(type.getFields())) {
            const fieldValue = astFromValue(value[field.name], field.type);
            if (fieldValue) {
              fieldNodes.push({
                kind: _kinds.Kind.OBJECT_FIELD,
                name: {
                  kind: _kinds.Kind.NAME,
                  value: field.name
                },
                value: fieldValue
              });
            }
          }
          return {
            kind: _kinds.Kind.OBJECT,
            fields: fieldNodes
          };
        }
        if ((0, _definition.isLeafType)(type)) {
          const serialized = type.serialize(value);
          if (serialized == null) {
            return null;
          }
          if (typeof serialized === "boolean") {
            return {
              kind: _kinds.Kind.BOOLEAN,
              value: serialized
            };
          }
          if (typeof serialized === "number" && Number.isFinite(serialized)) {
            const stringNum = String(serialized);
            return integerStringRegExp.test(stringNum) ? {
              kind: _kinds.Kind.INT,
              value: stringNum
            } : {
              kind: _kinds.Kind.FLOAT,
              value: stringNum
            };
          }
          if (typeof serialized === "string") {
            if ((0, _definition.isEnumType)(type)) {
              return {
                kind: _kinds.Kind.ENUM,
                value: serialized
              };
            }
            if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
              return {
                kind: _kinds.Kind.INT,
                value: serialized
              };
            }
            return {
              kind: _kinds.Kind.STRING,
              value: serialized
            };
          }
          throw new TypeError(`Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`);
        }
        (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
      }
      var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // node_modules/graphql/type/introspection.js
  var require_introspection = __commonJS({
    "node_modules/graphql/type/introspection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionTypes = exports.__TypeKind = exports.__Type = exports.__Schema = exports.__InputValue = exports.__Field = exports.__EnumValue = exports.__DirectiveLocation = exports.__Directive = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.TypeKind = exports.SchemaMetaFieldDef = void 0;
      exports.isIntrospectionType = isIntrospectionType;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _directiveLocation = require_directiveLocation();
      var _printer = require_printer();
      var _astFromValue = require_astFromValue();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var __Schema = new _definition.GraphQLObjectType({
        name: "__Schema",
        description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
        fields: () => ({
          description: {
            type: _scalars.GraphQLString,
            resolve: (schema) => schema.description
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
            resolve(schema) {
              return Object.values(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (schema) => schema.getQueryType()
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getMutationType()
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getSubscriptionType()
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
            resolve: (schema) => schema.getDirectives()
          }
        })
      });
      exports.__Schema = __Schema;
      var __Directive = new _definition.GraphQLObjectType({
        name: "__Directive",
        description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (directive) => directive.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (directive) => directive.description
          },
          isRepeatable: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (directive) => directive.isRepeatable
          },
          locations: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
            resolve: (directive) => directive.locations
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          }
        })
      });
      exports.__Directive = __Directive;
      var __DirectiveLocation = new _definition.GraphQLEnumType({
        name: "__DirectiveLocation",
        description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
        values: {
          QUERY: {
            value: _directiveLocation.DirectiveLocation.QUERY,
            description: "Location adjacent to a query operation."
          },
          MUTATION: {
            value: _directiveLocation.DirectiveLocation.MUTATION,
            description: "Location adjacent to a mutation operation."
          },
          SUBSCRIPTION: {
            value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
            description: "Location adjacent to a subscription operation."
          },
          FIELD: {
            value: _directiveLocation.DirectiveLocation.FIELD,
            description: "Location adjacent to a field."
          },
          FRAGMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
            description: "Location adjacent to a fragment definition."
          },
          FRAGMENT_SPREAD: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
            description: "Location adjacent to a fragment spread."
          },
          INLINE_FRAGMENT: {
            value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
            description: "Location adjacent to an inline fragment."
          },
          VARIABLE_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
            description: "Location adjacent to a variable definition."
          },
          SCHEMA: {
            value: _directiveLocation.DirectiveLocation.SCHEMA,
            description: "Location adjacent to a schema definition."
          },
          SCALAR: {
            value: _directiveLocation.DirectiveLocation.SCALAR,
            description: "Location adjacent to a scalar definition."
          },
          OBJECT: {
            value: _directiveLocation.DirectiveLocation.OBJECT,
            description: "Location adjacent to an object type definition."
          },
          FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
            description: "Location adjacent to a field definition."
          },
          ARGUMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
            description: "Location adjacent to an argument definition."
          },
          INTERFACE: {
            value: _directiveLocation.DirectiveLocation.INTERFACE,
            description: "Location adjacent to an interface definition."
          },
          UNION: {
            value: _directiveLocation.DirectiveLocation.UNION,
            description: "Location adjacent to a union definition."
          },
          ENUM: {
            value: _directiveLocation.DirectiveLocation.ENUM,
            description: "Location adjacent to an enum definition."
          },
          ENUM_VALUE: {
            value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
            description: "Location adjacent to an enum value definition."
          },
          INPUT_OBJECT: {
            value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
            description: "Location adjacent to an input object type definition."
          },
          INPUT_FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
            description: "Location adjacent to an input object field definition."
          }
        }
      });
      exports.__DirectiveLocation = __DirectiveLocation;
      var __Type = new _definition.GraphQLObjectType({
        name: "__Type",
        description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
        fields: () => ({
          kind: {
            type: new _definition.GraphQLNonNull(__TypeKind),
            resolve(type) {
              if ((0, _definition.isScalarType)(type)) {
                return TypeKind.SCALAR;
              }
              if ((0, _definition.isObjectType)(type)) {
                return TypeKind.OBJECT;
              }
              if ((0, _definition.isInterfaceType)(type)) {
                return TypeKind.INTERFACE;
              }
              if ((0, _definition.isUnionType)(type)) {
                return TypeKind.UNION;
              }
              if ((0, _definition.isEnumType)(type)) {
                return TypeKind.ENUM;
              }
              if ((0, _definition.isInputObjectType)(type)) {
                return TypeKind.INPUT_OBJECT;
              }
              if ((0, _definition.isListType)(type)) {
                return TypeKind.LIST;
              }
              if ((0, _definition.isNonNullType)(type)) {
                return TypeKind.NON_NULL;
              }
              (0, _invariant.invariant)(false, `Unexpected type: "${(0, _inspect.inspect)(type)}".`);
            }
          },
          name: {
            type: _scalars.GraphQLString,
            resolve: (type) => "name" in type ? type.name : void 0
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (type) => "description" in type ? type.description : void 0
          },
          specifiedByURL: {
            type: _scalars.GraphQLString,
            resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
          },
          fields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                const fields = Object.values(type.getFields());
                return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
              }
            }
          },
          interfaces: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve(type, _args, _context, { schema }) {
              if ((0, _definition.isAbstractType)(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isEnumType)(type)) {
                const values = type.getValues();
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          inputFields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isInputObjectType)(type)) {
                const values = Object.values(type.getFields());
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: (type) => "ofType" in type ? type.ofType : void 0
          }
        })
      });
      exports.__Type = __Type;
      var __Field = new _definition.GraphQLObjectType({
        name: "__Field",
        description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (field) => field.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.description
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (field) => field.type
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.deprecationReason
          }
        })
      });
      exports.__Field = __Field;
      var __InputValue = new _definition.GraphQLObjectType({
        name: "__InputValue",
        description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (inputValue) => inputValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (inputValue) => inputValue.description
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: (inputValue) => inputValue.type
          },
          defaultValue: {
            type: _scalars.GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve(inputValue) {
              const { type, defaultValue } = inputValue;
              const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
              return valueAST ? (0, _printer.print)(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (obj) => obj.deprecationReason
          }
        })
      });
      exports.__InputValue = __InputValue;
      var __EnumValue = new _definition.GraphQLObjectType({
        name: "__EnumValue",
        description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (enumValue) => enumValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.description
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (enumValue) => enumValue.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.deprecationReason
          }
        })
      });
      exports.__EnumValue = __EnumValue;
      var TypeKind;
      exports.TypeKind = TypeKind;
      (function(TypeKind2) {
        TypeKind2["SCALAR"] = "SCALAR";
        TypeKind2["OBJECT"] = "OBJECT";
        TypeKind2["INTERFACE"] = "INTERFACE";
        TypeKind2["UNION"] = "UNION";
        TypeKind2["ENUM"] = "ENUM";
        TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
        TypeKind2["LIST"] = "LIST";
        TypeKind2["NON_NULL"] = "NON_NULL";
      })(TypeKind || (exports.TypeKind = TypeKind = {}));
      var __TypeKind = new _definition.GraphQLEnumType({
        name: "__TypeKind",
        description: "An enum describing what kind of type a given `__Type` is.",
        values: {
          SCALAR: {
            value: TypeKind.SCALAR,
            description: "Indicates this type is a scalar."
          },
          OBJECT: {
            value: TypeKind.OBJECT,
            description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
          },
          INTERFACE: {
            value: TypeKind.INTERFACE,
            description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
          },
          UNION: {
            value: TypeKind.UNION,
            description: "Indicates this type is a union. `possibleTypes` is a valid field."
          },
          ENUM: {
            value: TypeKind.ENUM,
            description: "Indicates this type is an enum. `enumValues` is a valid field."
          },
          INPUT_OBJECT: {
            value: TypeKind.INPUT_OBJECT,
            description: "Indicates this type is an input object. `inputFields` is a valid field."
          },
          LIST: {
            value: TypeKind.LIST,
            description: "Indicates this type is a list. `ofType` is a valid field."
          },
          NON_NULL: {
            value: TypeKind.NON_NULL,
            description: "Indicates this type is a non-null. `ofType` is a valid field."
          }
        }
      });
      exports.__TypeKind = __TypeKind;
      var SchemaMetaFieldDef = {
        name: "__schema",
        type: new _definition.GraphQLNonNull(__Schema),
        description: "Access the current type schema of this server.",
        args: [],
        resolve: (_source, _args, _context, { schema }) => schema,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
      var TypeMetaFieldDef = {
        name: "__type",
        type: __Type,
        description: "Request the type information of a single type.",
        args: [
          {
            name: "name",
            description: void 0,
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            defaultValue: void 0,
            deprecationReason: void 0,
            extensions: /* @__PURE__ */ Object.create(null),
            astNode: void 0
          }
        ],
        resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeMetaFieldDef = TypeMetaFieldDef;
      var TypeNameMetaFieldDef = {
        name: "__typename",
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The name of the current Object type at runtime.",
        args: [],
        resolve: (_source, _args, _context, { parentType }) => parentType.name,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
      var introspectionTypes = Object.freeze([
        __Schema,
        __Directive,
        __DirectiveLocation,
        __Type,
        __Field,
        __InputValue,
        __EnumValue,
        __TypeKind
      ]);
      exports.introspectionTypes = introspectionTypes;
      function isIntrospectionType(type) {
        return introspectionTypes.some(({ name }) => type.name === name);
      }
    }
  });

  // node_modules/graphql/type/schema.js
  var require_schema = __commonJS({
    "node_modules/graphql/type/schema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLSchema = void 0;
      exports.assertSchema = assertSchema;
      exports.isSchema = isSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _ast = require_ast();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      function isSchema(schema) {
        return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
      }
      function assertSchema(schema) {
        if (!isSchema(schema)) {
          throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);
        }
        return schema;
      }
      var GraphQLSchema = class {
        constructor(config) {
          var _config$extensionASTN, _config$directives;
          this.__validationErrors = config.assumeValid === true ? [] : void 0;
          (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
          !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(false, `"types" must be Array if provided but got: ${(0, _inspect.inspect)(config.types)}.`);
          !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(false, `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config.directives)}.`);
          this.description = config.description;
          this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
          this.astNode = config.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          this._queryType = config.query;
          this._mutationType = config.mutation;
          this._subscriptionType = config.subscription;
          this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
          const allReferencedTypes = new Set(config.types);
          if (config.types != null) {
            for (const type of config.types) {
              allReferencedTypes.delete(type);
              collectReferencedTypes(type, allReferencedTypes);
            }
          }
          if (this._queryType != null) {
            collectReferencedTypes(this._queryType, allReferencedTypes);
          }
          if (this._mutationType != null) {
            collectReferencedTypes(this._mutationType, allReferencedTypes);
          }
          if (this._subscriptionType != null) {
            collectReferencedTypes(this._subscriptionType, allReferencedTypes);
          }
          for (const directive of this._directives) {
            if ((0, _directives.isDirective)(directive)) {
              for (const arg of directive.args) {
                collectReferencedTypes(arg.type, allReferencedTypes);
              }
            }
          }
          collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
          this._typeMap = /* @__PURE__ */ Object.create(null);
          this._subTypeMap = /* @__PURE__ */ Object.create(null);
          this._implementationsMap = /* @__PURE__ */ Object.create(null);
          for (const namedType of allReferencedTypes) {
            if (namedType == null) {
              continue;
            }
            const typeName = namedType.name;
            typeName || (0, _devAssert.devAssert)(false, "One of the provided types for building the Schema is missing a name.");
            if (this._typeMap[typeName] !== void 0) {
              throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
            }
            this._typeMap[typeName] = namedType;
            if ((0, _definition.isInterfaceType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.interfaces.push(namedType);
                }
              }
            } else if ((0, _definition.isObjectType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.objects.push(namedType);
                }
              }
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLSchema";
        }
        getQueryType() {
          return this._queryType;
        }
        getMutationType() {
          return this._mutationType;
        }
        getSubscriptionType() {
          return this._subscriptionType;
        }
        getRootType(operation) {
          switch (operation) {
            case _ast.OperationTypeNode.QUERY:
              return this.getQueryType();
            case _ast.OperationTypeNode.MUTATION:
              return this.getMutationType();
            case _ast.OperationTypeNode.SUBSCRIPTION:
              return this.getSubscriptionType();
          }
        }
        getTypeMap() {
          return this._typeMap;
        }
        getType(name) {
          return this.getTypeMap()[name];
        }
        getPossibleTypes(abstractType) {
          return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
        }
        getImplementations(interfaceType) {
          const implementations = this._implementationsMap[interfaceType.name];
          return implementations !== null && implementations !== void 0 ? implementations : {
            objects: [],
            interfaces: []
          };
        }
        isSubType(abstractType, maybeSubType) {
          let map = this._subTypeMap[abstractType.name];
          if (map === void 0) {
            map = /* @__PURE__ */ Object.create(null);
            if ((0, _definition.isUnionType)(abstractType)) {
              for (const type of abstractType.getTypes()) {
                map[type.name] = true;
              }
            } else {
              const implementations = this.getImplementations(abstractType);
              for (const type of implementations.objects) {
                map[type.name] = true;
              }
              for (const type of implementations.interfaces) {
                map[type.name] = true;
              }
            }
            this._subTypeMap[abstractType.name] = map;
          }
          return map[maybeSubType.name] !== void 0;
        }
        getDirectives() {
          return this._directives;
        }
        getDirective(name) {
          return this.getDirectives().find((directive) => directive.name === name);
        }
        toConfig() {
          return {
            description: this.description,
            query: this.getQueryType(),
            mutation: this.getMutationType(),
            subscription: this.getSubscriptionType(),
            types: Object.values(this.getTypeMap()),
            directives: this.getDirectives(),
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            assumeValid: this.__validationErrors !== void 0
          };
        }
      };
      exports.GraphQLSchema = GraphQLSchema;
      function collectReferencedTypes(type, typeSet) {
        const namedType = (0, _definition.getNamedType)(type);
        if (!typeSet.has(namedType)) {
          typeSet.add(namedType);
          if ((0, _definition.isUnionType)(namedType)) {
            for (const memberType of namedType.getTypes()) {
              collectReferencedTypes(memberType, typeSet);
            }
          } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
            for (const interfaceType of namedType.getInterfaces()) {
              collectReferencedTypes(interfaceType, typeSet);
            }
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
              for (const arg of field.args) {
                collectReferencedTypes(arg.type, typeSet);
              }
            }
          } else if ((0, _definition.isInputObjectType)(namedType)) {
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes(field.type, typeSet);
            }
          }
        }
        return typeSet;
      }
    }
  });

  // node_modules/graphql/type/validate.js
  var require_validate = __commonJS({
    "node_modules/graphql/type/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSchema = assertValidSchema;
      exports.validateSchema = validateSchema;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _typeComparators = require_typeComparators();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function validateSchema(schema) {
        (0, _schema.assertSchema)(schema);
        if (schema.__validationErrors) {
          return schema.__validationErrors;
        }
        const context = new SchemaValidationContext(schema);
        validateRootTypes(context);
        validateDirectives(context);
        validateTypes(context);
        const errors = context.getErrors();
        schema.__validationErrors = errors;
        return errors;
      }
      function assertValidSchema(schema) {
        const errors = validateSchema(schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      var SchemaValidationContext = class {
        constructor(schema) {
          this._errors = [];
          this.schema = schema;
        }
        reportError(message, nodes) {
          const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
          this._errors.push(new _GraphQLError.GraphQLError(message, {
            nodes: _nodes
          }));
        }
        getErrors() {
          return this._errors;
        }
      };
      function validateRootTypes(context) {
        const schema = context.schema;
        const queryType = schema.getQueryType();
        if (!queryType) {
          context.reportError("Query root type must be provided.", schema.astNode);
        } else if (!(0, _definition.isObjectType)(queryType)) {
          var _getOperationTypeNode;
          context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
        }
        const mutationType = schema.getMutationType();
        if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
          var _getOperationTypeNode2;
          context.reportError(`Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
          var _getOperationTypeNode3;
          context.reportError(`Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
        }
      }
      function getOperationTypeNode(schema, operation) {
        var _flatMap$find;
        return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap((schemaNode) => {
          var _schemaNode$operation;
          return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];
        }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
      }
      function validateDirectives(context) {
        for (const directive of context.schema.getDirectives()) {
          if (!(0, _directives.isDirective)(directive)) {
            context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);
            continue;
          }
          validateName(context, directive);
          for (const arg of directive.args) {
            validateName(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode;
              context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
              ]);
            }
          }
        }
      }
      function validateName(context, node) {
        if (node.name.startsWith("__")) {
          context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
        }
      }
      function validateTypes(context) {
        const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
        const typeMap = context.schema.getTypeMap();
        for (const type of Object.values(typeMap)) {
          if (!(0, _definition.isNamedType)(type)) {
            context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`, type.astNode);
            continue;
          }
          if (!(0, _introspection.isIntrospectionType)(type)) {
            validateName(context, type);
          }
          if ((0, _definition.isObjectType)(type)) {
            validateFields(context, type);
            validateInterfaces(context, type);
          } else if ((0, _definition.isInterfaceType)(type)) {
            validateFields(context, type);
            validateInterfaces(context, type);
          } else if ((0, _definition.isUnionType)(type)) {
            validateUnionMembers(context, type);
          } else if ((0, _definition.isEnumType)(type)) {
            validateEnumValues(context, type);
          } else if ((0, _definition.isInputObjectType)(type)) {
            validateInputFields(context, type);
            validateInputObjectCircularRefs(type);
          }
        }
      }
      function validateFields(context, type) {
        const fields = Object.values(type.getFields());
        if (fields.length === 0) {
          context.reportError(`Type ${type.name} must define one or more fields.`, [
            type.astNode,
            ...type.extensionASTNodes
          ]);
        }
        for (const field of fields) {
          validateName(context, field);
          if (!(0, _definition.isOutputType)(field.type)) {
            var _field$astNode;
            context.reportError(`The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
          }
          for (const arg of field.args) {
            const argName = arg.name;
            validateName(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              var _arg$astNode2;
              context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode3;
              context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
              ]);
            }
          }
        }
      }
      function validateInterfaces(context, type) {
        const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
        for (const iface of type.getInterfaces()) {
          if (!(0, _definition.isInterfaceType)(iface)) {
            context.reportError(`Type ${(0, _inspect.inspect)(type)} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
          }
          if (type === iface) {
            context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
          }
          if (ifaceTypeNames[iface.name]) {
            context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
          }
          ifaceTypeNames[iface.name] = true;
          validateTypeImplementsAncestors(context, type, iface);
          validateTypeImplementsInterface(context, type, iface);
        }
      }
      function validateTypeImplementsInterface(context, type, iface) {
        const typeFieldMap = type.getFields();
        for (const ifaceField of Object.values(iface.getFields())) {
          const fieldName = ifaceField.name;
          const typeField = typeFieldMap[fieldName];
          if (!typeField) {
            context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
            continue;
          }
          if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
            var _ifaceField$astNode, _typeField$astNode;
            context.reportError(`Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`, [
              (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
              (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
            ]);
          }
          for (const ifaceArg of ifaceField.args) {
            const argName = ifaceArg.name;
            const typeArg = typeField.args.find((arg) => arg.name === argName);
            if (!typeArg) {
              context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
              continue;
            }
            if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
              var _ifaceArg$astNode, _typeArg$astNode;
              context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`, [
                (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
              ]);
            }
          }
          for (const typeArg of typeField.args) {
            const argName = typeArg.name;
            const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
            if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
              context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
            }
          }
        }
      }
      function validateTypeImplementsAncestors(context, type, iface) {
        const ifaceInterfaces = type.getInterfaces();
        for (const transitive of iface.getInterfaces()) {
          if (!ifaceInterfaces.includes(transitive)) {
            context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
              ...getAllImplementsInterfaceNodes(iface, transitive),
              ...getAllImplementsInterfaceNodes(type, iface)
            ]);
          }
        }
      }
      function validateUnionMembers(context, union) {
        const memberTypes = union.getTypes();
        if (memberTypes.length === 0) {
          context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
        }
        const includedTypeNames = /* @__PURE__ */ Object.create(null);
        for (const memberType of memberTypes) {
          if (includedTypeNames[memberType.name]) {
            context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
            continue;
          }
          includedTypeNames[memberType.name] = true;
          if (!(0, _definition.isObjectType)(memberType)) {
            context.reportError(`Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
          }
        }
      }
      function validateEnumValues(context, enumType) {
        const enumValues = enumType.getValues();
        if (enumValues.length === 0) {
          context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
        }
        for (const enumValue of enumValues) {
          validateName(context, enumValue);
        }
      }
      function validateInputFields(context, inputObj) {
        const fields = Object.values(inputObj.getFields());
        if (fields.length === 0) {
          context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
        }
        for (const field of fields) {
          validateName(context, field);
          if (!(0, _definition.isInputType)(field.type)) {
            var _field$astNode2;
            context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
          }
          if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
            var _field$astNode3;
            context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
              getDeprecatedDirectiveNode(field.astNode),
              (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
            ]);
          }
        }
      }
      function createInputObjectCircularRefsValidator(context) {
        const visitedTypes = /* @__PURE__ */ Object.create(null);
        const fieldPath = [];
        const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
        return detectCycleRecursive;
        function detectCycleRecursive(inputObj) {
          if (visitedTypes[inputObj.name]) {
            return;
          }
          visitedTypes[inputObj.name] = true;
          fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
          const fields = Object.values(inputObj.getFields());
          for (const field of fields) {
            if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
              const fieldType = field.type.ofType;
              const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
              fieldPath.push(field);
              if (cycleIndex === void 0) {
                detectCycleRecursive(fieldType);
              } else {
                const cyclePath = fieldPath.slice(cycleIndex);
                const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
                context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
              }
              fieldPath.pop();
            }
          }
          fieldPathIndexByTypeName[inputObj.name] = void 0;
        }
      }
      function getAllImplementsInterfaceNodes(type, iface) {
        const { astNode, extensionASTNodes } = type;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((typeNode) => {
          var _typeNode$interfaces;
          return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];
        }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
      }
      function getUnionMemberTypeNodes(union, typeName) {
        const { astNode, extensionASTNodes } = union;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((unionNode) => {
          var _unionNode$types;
          return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];
        }).filter((typeNode) => typeNode.name.value === typeName);
      }
      function getDeprecatedDirectiveNode(definitionNode) {
        var _definitionNode$direc;
        return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find((node) => node.name.value === _directives.GraphQLDeprecatedDirective.name);
      }
    }
  });

  // node_modules/graphql/utilities/typeFromAST.js
  var require_typeFromAST = __commonJS({
    "node_modules/graphql/utilities/typeFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typeFromAST = typeFromAST;
      var _kinds = require_kinds();
      var _definition = require_definition();
      function typeFromAST(schema, typeNode) {
        switch (typeNode.kind) {
          case _kinds.Kind.LIST_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLList(innerType);
          }
          case _kinds.Kind.NON_NULL_TYPE: {
            const innerType = typeFromAST(schema, typeNode.type);
            return innerType && new _definition.GraphQLNonNull(innerType);
          }
          case _kinds.Kind.NAMED_TYPE:
            return schema.getType(typeNode.name.value);
        }
      }
    }
  });

  // node_modules/graphql/utilities/TypeInfo.js
  var require_TypeInfo = __commonJS({
    "node_modules/graphql/utilities/TypeInfo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TypeInfo = void 0;
      exports.visitWithTypeInfo = visitWithTypeInfo;
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _typeFromAST = require_typeFromAST();
      var TypeInfo = class {
        constructor(schema, initialType, getFieldDefFn) {
          this._schema = schema;
          this._typeStack = [];
          this._parentTypeStack = [];
          this._inputTypeStack = [];
          this._fieldDefStack = [];
          this._defaultValueStack = [];
          this._directive = null;
          this._argument = null;
          this._enumValue = null;
          this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
          if (initialType) {
            if ((0, _definition.isInputType)(initialType)) {
              this._inputTypeStack.push(initialType);
            }
            if ((0, _definition.isCompositeType)(initialType)) {
              this._parentTypeStack.push(initialType);
            }
            if ((0, _definition.isOutputType)(initialType)) {
              this._typeStack.push(initialType);
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "TypeInfo";
        }
        getType() {
          if (this._typeStack.length > 0) {
            return this._typeStack[this._typeStack.length - 1];
          }
        }
        getParentType() {
          if (this._parentTypeStack.length > 0) {
            return this._parentTypeStack[this._parentTypeStack.length - 1];
          }
        }
        getInputType() {
          if (this._inputTypeStack.length > 0) {
            return this._inputTypeStack[this._inputTypeStack.length - 1];
          }
        }
        getParentInputType() {
          if (this._inputTypeStack.length > 1) {
            return this._inputTypeStack[this._inputTypeStack.length - 2];
          }
        }
        getFieldDef() {
          if (this._fieldDefStack.length > 0) {
            return this._fieldDefStack[this._fieldDefStack.length - 1];
          }
        }
        getDefaultValue() {
          if (this._defaultValueStack.length > 0) {
            return this._defaultValueStack[this._defaultValueStack.length - 1];
          }
        }
        getDirective() {
          return this._directive;
        }
        getArgument() {
          return this._argument;
        }
        getEnumValue() {
          return this._enumValue;
        }
        enter(node) {
          const schema = this._schema;
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET: {
              const namedType = (0, _definition.getNamedType)(this.getType());
              this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : void 0);
              break;
            }
            case _kinds.Kind.FIELD: {
              const parentType = this.getParentType();
              let fieldDef;
              let fieldType;
              if (parentType) {
                fieldDef = this._getFieldDef(schema, parentType, node);
                if (fieldDef) {
                  fieldType = fieldDef.type;
                }
              }
              this._fieldDefStack.push(fieldDef);
              this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : void 0);
              break;
            }
            case _kinds.Kind.DIRECTIVE:
              this._directive = schema.getDirective(node.name.value);
              break;
            case _kinds.Kind.OPERATION_DEFINITION: {
              const rootType = schema.getRootType(node.operation);
              this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : void 0);
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION: {
              const typeConditionAST = node.typeCondition;
              const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
              this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : void 0);
              break;
            }
            case _kinds.Kind.VARIABLE_DEFINITION: {
              const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
              this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : void 0);
              break;
            }
            case _kinds.Kind.ARGUMENT: {
              var _this$getDirective;
              let argDef;
              let argType;
              const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
              if (fieldOrDirective) {
                argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
                if (argDef) {
                  argType = argDef.type;
                }
              }
              this._argument = argDef;
              this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
              this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : void 0);
              break;
            }
            case _kinds.Kind.LIST: {
              const listType = (0, _definition.getNullableType)(this.getInputType());
              const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
              this._defaultValueStack.push(void 0);
              this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : void 0);
              break;
            }
            case _kinds.Kind.OBJECT_FIELD: {
              const objectType = (0, _definition.getNamedType)(this.getInputType());
              let inputFieldType;
              let inputField;
              if ((0, _definition.isInputObjectType)(objectType)) {
                inputField = objectType.getFields()[node.name.value];
                if (inputField) {
                  inputFieldType = inputField.type;
                }
              }
              this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
              this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0);
              break;
            }
            case _kinds.Kind.ENUM: {
              const enumType = (0, _definition.getNamedType)(this.getInputType());
              let enumValue;
              if ((0, _definition.isEnumType)(enumType)) {
                enumValue = enumType.getValue(node.value);
              }
              this._enumValue = enumValue;
              break;
            }
            default:
          }
        }
        leave(node) {
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET:
              this._parentTypeStack.pop();
              break;
            case _kinds.Kind.FIELD:
              this._fieldDefStack.pop();
              this._typeStack.pop();
              break;
            case _kinds.Kind.DIRECTIVE:
              this._directive = null;
              break;
            case _kinds.Kind.OPERATION_DEFINITION:
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION:
              this._typeStack.pop();
              break;
            case _kinds.Kind.VARIABLE_DEFINITION:
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ARGUMENT:
              this._argument = null;
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.LIST:
            case _kinds.Kind.OBJECT_FIELD:
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ENUM:
              this._enumValue = null;
              break;
            default:
          }
        }
      };
      exports.TypeInfo = TypeInfo;
      function getFieldDef(schema, parentType, fieldNode) {
        const name = fieldNode.name.value;
        if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        }
        if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        }
        if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
          return _introspection.TypeNameMetaFieldDef;
        }
        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
          return parentType.getFields()[name];
        }
      }
      function visitWithTypeInfo(typeInfo, visitor) {
        return {
          enter(...args) {
            const node = args[0];
            typeInfo.enter(node);
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
            if (fn) {
              const result = fn.apply(visitor, args);
              if (result !== void 0) {
                typeInfo.leave(node);
                if ((0, _ast.isNode)(result)) {
                  typeInfo.enter(result);
                }
              }
              return result;
            }
          },
          leave(...args) {
            const node = args[0];
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
            let result;
            if (fn) {
              result = fn.apply(visitor, args);
            }
            typeInfo.leave(node);
            return result;
          }
        };
      }
    }
  });

  // node_modules/graphql/language/predicates.js
  var require_predicates = __commonJS({
    "node_modules/graphql/language/predicates.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isConstValueNode = isConstValueNode;
      exports.isDefinitionNode = isDefinitionNode;
      exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
      exports.isSelectionNode = isSelectionNode;
      exports.isTypeDefinitionNode = isTypeDefinitionNode;
      exports.isTypeExtensionNode = isTypeExtensionNode;
      exports.isTypeNode = isTypeNode;
      exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
      exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
      exports.isValueNode = isValueNode;
      var _kinds = require_kinds();
      function isDefinitionNode(node) {
        return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
      }
      function isExecutableDefinitionNode(node) {
        return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
      }
      function isSelectionNode(node) {
        return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
      }
      function isValueNode(node) {
        return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
      }
      function isConstValueNode(node) {
        return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
      }
      function isTypeNode(node) {
        return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
      }
      function isTypeSystemDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
      }
      function isTypeDefinitionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
      }
      function isTypeSystemExtensionNode(node) {
        return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
      }
      function isTypeExtensionNode(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
    }
  });

  // node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
  var require_ExecutableDefinitionsRule = __commonJS({
    "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      function ExecutableDefinitionsRule(context) {
        return {
          Document(node) {
            for (const definition of node.definitions) {
              if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
                const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
                context.reportError(new _GraphQLError.GraphQLError(`The ${defName} definition is not executable.`, {
                  nodes: definition
                }));
              }
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
  var require_FieldsOnCorrectTypeRule = __commonJS({
    "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _naturalCompare = require_naturalCompare();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function FieldsOnCorrectTypeRule(context) {
        return {
          Field(node) {
            const type = context.getParentType();
            if (type) {
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                const schema = context.getSchema();
                const fieldName = node.name.value;
                let suggestion = (0, _didYouMean.didYouMean)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName));
                if (suggestion === "") {
                  suggestion = (0, _didYouMean.didYouMean)(getSuggestedFieldNames(type, fieldName));
                }
                context.reportError(new _GraphQLError.GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
                  nodes: node
                }));
              }
            }
          }
        };
      }
      function getSuggestedTypeNames(schema, type, fieldName) {
        if (!(0, _definition.isAbstractType)(type)) {
          return [];
        }
        const suggestedTypes = /* @__PURE__ */ new Set();
        const usageCount = /* @__PURE__ */ Object.create(null);
        for (const possibleType of schema.getPossibleTypes(type)) {
          if (!possibleType.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleType);
          usageCount[possibleType.name] = 1;
          for (const possibleInterface of possibleType.getInterfaces()) {
            var _usageCount$possibleI;
            if (!possibleInterface.getFields()[fieldName]) {
              continue;
            }
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
          }
        }
        return [...suggestedTypes].sort((typeA, typeB) => {
          const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
          if (usageCountDiff !== 0) {
            return usageCountDiff;
          }
          if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
          }
          if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
          }
          return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
        }).map((x) => x.name);
      }
      function getSuggestedFieldNames(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
          const possibleFieldNames = Object.keys(type.getFields());
          return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
        }
        return [];
      }
    }
  });

  // node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
  var require_FragmentsOnCompositeTypesRule = __commonJS({
    "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function FragmentsOnCompositeTypesRule(context) {
        return {
          InlineFragment(node) {
            const typeCondition = node.typeCondition;
            if (typeCondition) {
              const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
              if (type && !(0, _definition.isCompositeType)(type)) {
                const typeStr = (0, _printer.print)(typeCondition);
                context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
                  nodes: typeCondition
                }));
              }
            }
          },
          FragmentDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(node.typeCondition);
              context.reportError(new _GraphQLError.GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
                nodes: node.typeCondition
              }));
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
  var require_KnownArgumentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
      exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownArgumentNamesRule(context) {
        return {
          ...KnownArgumentNamesOnDirectivesRule(context),
          Argument(argNode) {
            const argDef = context.getArgument();
            const fieldDef = context.getFieldDef();
            const parentType = context.getParentType();
            if (!argDef && fieldDef && parentType) {
              const argName = argNode.name.value;
              const knownArgsNames = fieldDef.args.map((arg) => arg.name);
              const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgsNames);
              context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
                nodes: argNode
              }));
            }
          }
        };
      }
      function KnownArgumentNamesOnDirectivesRule(context) {
        const directiveArgs = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
          }
        }
        return {
          Directive(directiveNode) {
            const directiveName = directiveNode.name.value;
            const knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
              for (const argNode of directiveNode.arguments) {
                const argName = argNode.name.value;
                if (!knownArgs.includes(argName)) {
                  const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgs);
                  context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions), {
                    nodes: argNode
                  }));
                }
              }
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownDirectivesRule.js
  var require_KnownDirectivesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownDirectivesRule = KnownDirectivesRule;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownDirectivesRule(context) {
        const locationsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          locationsMap[directive.name] = directive.locations;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map((name) => name.value);
          }
        }
        return {
          Directive(node, _key, _parent, _path, ancestors) {
            const name = node.name.value;
            const locations = locationsMap[name];
            if (!locations) {
              context.reportError(new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                nodes: node
              }));
              return;
            }
            const candidateLocation = getDirectiveLocationForASTPath(ancestors);
            if (candidateLocation && !locations.includes(candidateLocation)) {
              context.reportError(new _GraphQLError.GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
                nodes: node
              }));
            }
          }
        };
      }
      function getDirectiveLocationForASTPath(ancestors) {
        const appliedTo = ancestors[ancestors.length - 1];
        "kind" in appliedTo || (0, _invariant.invariant)(false);
        switch (appliedTo.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            return getDirectiveLocationForOperation(appliedTo.operation);
          case _kinds.Kind.FIELD:
            return _directiveLocation.DirectiveLocation.FIELD;
          case _kinds.Kind.FRAGMENT_SPREAD:
            return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
          case _kinds.Kind.INLINE_FRAGMENT:
            return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
          case _kinds.Kind.VARIABLE_DEFINITION:
            return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
          case _kinds.Kind.SCHEMA_DEFINITION:
          case _kinds.Kind.SCHEMA_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCHEMA;
          case _kinds.Kind.SCALAR_TYPE_DEFINITION:
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCALAR;
          case _kinds.Kind.OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.OBJECT;
          case _kinds.Kind.FIELD_DEFINITION:
            return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INTERFACE;
          case _kinds.Kind.UNION_TYPE_DEFINITION:
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.UNION;
          case _kinds.Kind.ENUM_TYPE_DEFINITION:
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.ENUM;
          case _kinds.Kind.ENUM_VALUE_DEFINITION:
            return _directiveLocation.DirectiveLocation.ENUM_VALUE;
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
          case _kinds.Kind.INPUT_VALUE_DEFINITION: {
            const parentNode = ancestors[ancestors.length - 3];
            "kind" in parentNode || (0, _invariant.invariant)(false);
            return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
          }
          default:
            (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind));
        }
      }
      function getDirectiveLocationForOperation(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return _directiveLocation.DirectiveLocation.QUERY;
          case _ast.OperationTypeNode.MUTATION:
            return _directiveLocation.DirectiveLocation.MUTATION;
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
  var require_KnownFragmentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function KnownFragmentNamesRule(context) {
        return {
          FragmentSpread(node) {
            const fragmentName = node.name.value;
            const fragment = context.getFragment(fragmentName);
            if (!fragment) {
              context.reportError(new _GraphQLError.GraphQLError(`Unknown fragment "${fragmentName}".`, {
                nodes: node.name
              }));
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/KnownTypeNamesRule.js
  var require_KnownTypeNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.KnownTypeNamesRule = KnownTypeNamesRule;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _predicates = require_predicates();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      function KnownTypeNamesRule(context) {
        const schema = context.getSchema();
        const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = true;
          }
        }
        const typeNames = [
          ...Object.keys(existingTypesMap),
          ...Object.keys(definedTypes)
        ];
        return {
          NamedType(node, _1, parent, _2, ancestors) {
            const typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
              var _ancestors$;
              const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
              const isSDL = definitionNode != null && isSDLNode(definitionNode);
              if (isSDL && standardTypeNames.includes(typeName)) {
                return;
              }
              const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
              context.reportError(new _GraphQLError.GraphQLError(`Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes), {
                nodes: node
              }));
            }
          }
        };
      }
      var standardTypeNames = [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ].map((type) => type.name);
      function isSDLNode(value) {
        return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
      }
    }
  });

  // node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
  var require_LoneAnonymousOperationRule = __commonJS({
    "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      function LoneAnonymousOperationRule(context) {
        let operationCount = 0;
        return {
          Document(node) {
            operationCount = node.definitions.filter((definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION).length;
          },
          OperationDefinition(node) {
            if (!node.name && operationCount > 1) {
              context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", {
                nodes: node
              }));
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
  var require_LoneSchemaDefinitionRule = __commonJS({
    "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
      var _GraphQLError = require_GraphQLError();
      function LoneSchemaDefinitionRule(context) {
        var _ref, _ref2, _oldSchema$astNode;
        const oldSchema = context.getSchema();
        const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
        let schemaDefinitionsCount = 0;
        return {
          SchemaDefinition(node) {
            if (alreadyDefined) {
              context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", {
                nodes: node
              }));
              return;
            }
            if (schemaDefinitionsCount > 0) {
              context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", {
                nodes: node
              }));
            }
            ++schemaDefinitionsCount;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
  var require_NoFragmentCyclesRule = __commonJS({
    "node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
      var _GraphQLError = require_GraphQLError();
      function NoFragmentCyclesRule(context) {
        const visitedFrags = /* @__PURE__ */ Object.create(null);
        const spreadPath = [];
        const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            detectCycleRecursive(node);
            return false;
          }
        };
        function detectCycleRecursive(fragment) {
          if (visitedFrags[fragment.name.value]) {
            return;
          }
          const fragmentName = fragment.name.value;
          visitedFrags[fragmentName] = true;
          const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
          if (spreadNodes.length === 0) {
            return;
          }
          spreadPathIndexByName[fragmentName] = spreadPath.length;
          for (const spreadNode of spreadNodes) {
            const spreadName = spreadNode.name.value;
            const cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === void 0) {
              const spreadFragment = context.getFragment(spreadName);
              if (spreadFragment) {
                detectCycleRecursive(spreadFragment);
              }
            } else {
              const cyclePath = spreadPath.slice(cycleIndex);
              const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
              context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
                nodes: cyclePath
              }));
            }
            spreadPath.pop();
          }
          spreadPathIndexByName[fragmentName] = void 0;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
  var require_NoUndefinedVariablesRule = __commonJS({
    "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUndefinedVariablesRule(context) {
        let variableNameDefined = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              variableNameDefined = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                const varName = node.name.value;
                if (variableNameDefined[varName] !== true) {
                  context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`, {
                    nodes: [node, operation]
                  }));
                }
              }
            }
          },
          VariableDefinition(node) {
            variableNameDefined[node.variable.name.value] = true;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
  var require_NoUnusedFragmentsRule = __commonJS({
    "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedFragmentsRule(context) {
        const operationDefs = [];
        const fragmentDefs = [];
        return {
          OperationDefinition(node) {
            operationDefs.push(node);
            return false;
          },
          FragmentDefinition(node) {
            fragmentDefs.push(node);
            return false;
          },
          Document: {
            leave() {
              const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
              for (const operation of operationDefs) {
                for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
                  fragmentNameUsed[fragment.name.value] = true;
                }
              }
              for (const fragmentDef of fragmentDefs) {
                const fragName = fragmentDef.name.value;
                if (fragmentNameUsed[fragName] !== true) {
                  context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" is never used.`, {
                    nodes: fragmentDef
                  }));
                }
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
  var require_NoUnusedVariablesRule = __commonJS({
    "node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedVariablesRule(context) {
        let variableDefs = [];
        return {
          OperationDefinition: {
            enter() {
              variableDefs = [];
            },
            leave(operation) {
              const variableNameUsed = /* @__PURE__ */ Object.create(null);
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                variableNameUsed[node.name.value] = true;
              }
              for (const variableDef of variableDefs) {
                const variableName = variableDef.variable.name.value;
                if (variableNameUsed[variableName] !== true) {
                  context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`, {
                    nodes: variableDef
                  }));
                }
              }
            }
          },
          VariableDefinition(def) {
            variableDefs.push(def);
          }
        };
      }
    }
  });

  // node_modules/graphql/utilities/sortValueNode.js
  var require_sortValueNode = __commonJS({
    "node_modules/graphql/utilities/sortValueNode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sortValueNode = sortValueNode;
      var _naturalCompare = require_naturalCompare();
      var _kinds = require_kinds();
      function sortValueNode(valueNode) {
        switch (valueNode.kind) {
          case _kinds.Kind.OBJECT:
            return { ...valueNode, fields: sortFields(valueNode.fields) };
          case _kinds.Kind.LIST:
            return { ...valueNode, values: valueNode.values.map(sortValueNode) };
          case _kinds.Kind.INT:
          case _kinds.Kind.FLOAT:
          case _kinds.Kind.STRING:
          case _kinds.Kind.BOOLEAN:
          case _kinds.Kind.NULL:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.VARIABLE:
            return valueNode;
        }
      }
      function sortFields(fields) {
        return fields.map((fieldNode) => ({
          ...fieldNode,
          value: sortValueNode(fieldNode.value)
        })).sort((fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value));
      }
    }
  });

  // node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
  var require_OverlappingFieldsCanBeMergedRule = __commonJS({
    "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _sortValueNode = require_sortValueNode();
      var _typeFromAST = require_typeFromAST();
      function reasonMessage(reason) {
        if (Array.isArray(reason)) {
          return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
        }
        return reason;
      }
      function OverlappingFieldsCanBeMergedRule(context) {
        const comparedFragmentPairs = new PairSet();
        const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
        return {
          SelectionSet(selectionSet) {
            const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
            for (const [[responseName, reason], fields1, fields2] of conflicts) {
              const reasonMsg = reasonMessage(reason);
              context.reportError(new _GraphQLError.GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
                nodes: fields1.concat(fields2)
              }));
            }
          }
        };
      }
      function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
        const conflicts = [];
        const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
        collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
        if (fragmentNames.length !== 0) {
          for (let i = 0; i < fragmentNames.length; i++) {
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
            for (let j = i + 1; j < fragmentNames.length; j++) {
              collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
            }
          }
        }
        return conflicts;
      }
      function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          return;
        }
        const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
        if (fieldMap === fieldMap2) {
          return;
        }
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
        for (const referencedFragmentName of referencedFragmentNames) {
          if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
            continue;
          }
          comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
        }
      }
      function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
        if (fragmentName1 === fragmentName2) {
          return;
        }
        if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
          return;
        }
        comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
        const fragment1 = context.getFragment(fragmentName1);
        const fragment2 = context.getFragment(fragmentName2);
        if (!fragment1 || !fragment2) {
          return;
        }
        const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
        const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
        for (const referencedFragmentName2 of referencedFragmentNames2) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
        }
        for (const referencedFragmentName1 of referencedFragmentNames1) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
        }
      }
      function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
        const conflicts = [];
        const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
        const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
        }
        for (const fragmentName1 of fragmentNames1) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
        }
        for (const fragmentName1 of fragmentNames1) {
          for (const fragmentName2 of fragmentNames2) {
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
          }
        }
        return conflicts;
      }
      function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
        for (const [responseName, fields] of Object.entries(fieldMap)) {
          if (fields.length > 1) {
            for (let i = 0; i < fields.length; i++) {
              for (let j = i + 1; j < fields.length; j++) {
                const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
        for (const [responseName, fields1] of Object.entries(fieldMap1)) {
          const fields2 = fieldMap2[responseName];
          if (fields2) {
            for (const field1 of fields1) {
              for (const field2 of fields2) {
                const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
        const [parentType1, node1, def1] = field1;
        const [parentType2, node2, def2] = field2;
        const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
        if (!areMutuallyExclusive) {
          const name1 = node1.name.value;
          const name2 = node2.name.value;
          if (name1 !== name2) {
            return [
              [responseName, `"${name1}" and "${name2}" are different fields`],
              [node1],
              [node2]
            ];
          }
          if (stringifyArguments(node1) !== stringifyArguments(node2)) {
            return [
              [responseName, "they have differing arguments"],
              [node1],
              [node2]
            ];
          }
        }
        const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
        const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
        if (type1 && type2 && doTypesConflict(type1, type2)) {
          return [
            [
              responseName,
              `they return conflicting types "${(0, _inspect.inspect)(type1)}" and "${(0, _inspect.inspect)(type2)}"`
            ],
            [node1],
            [node2]
          ];
        }
        const selectionSet1 = node1.selectionSet;
        const selectionSet2 = node2.selectionSet;
        if (selectionSet1 && selectionSet2) {
          const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
          return subfieldConflicts(conflicts, responseName, node1, node2);
        }
      }
      function stringifyArguments(fieldNode) {
        var _fieldNode$arguments;
        const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
        const inputObjectWithArgs = {
          kind: _kinds.Kind.OBJECT,
          fields: args.map((argNode) => ({
            kind: _kinds.Kind.OBJECT_FIELD,
            name: argNode.name,
            value: argNode.value
          }))
        };
        return (0, _printer.print)((0, _sortValueNode.sortValueNode)(inputObjectWithArgs));
      }
      function doTypesConflict(type1, type2) {
        if ((0, _definition.isListType)(type1)) {
          return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isListType)(type2)) {
          return true;
        }
        if ((0, _definition.isNonNullType)(type1)) {
          return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isNonNullType)(type2)) {
          return true;
        }
        if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
          return type1 !== type2;
        }
        return false;
      }
      function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
        const cached = cachedFieldsAndFragmentNames.get(selectionSet);
        if (cached) {
          return cached;
        }
        const nodeAndDefs = /* @__PURE__ */ Object.create(null);
        const fragmentNames = /* @__PURE__ */ Object.create(null);
        _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
        const result = [nodeAndDefs, Object.keys(fragmentNames)];
        cachedFieldsAndFragmentNames.set(selectionSet, result);
        return result;
      }
      function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
        const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
        if (cached) {
          return cached;
        }
        const fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
        return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
      }
      function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              const fieldName = selection.name.value;
              let fieldDef;
              if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
                fieldDef = parentType.getFields()[fieldName];
              }
              const responseName = selection.alias ? selection.alias.value : fieldName;
              if (!nodeAndDefs[responseName]) {
                nodeAndDefs[responseName] = [];
              }
              nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD:
              fragmentNames[selection.name.value] = true;
              break;
            case _kinds.Kind.INLINE_FRAGMENT: {
              const typeCondition = selection.typeCondition;
              const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
              _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
              break;
            }
          }
        }
      }
      function subfieldConflicts(conflicts, responseName, node1, node2) {
        if (conflicts.length > 0) {
          return [
            [responseName, conflicts.map(([reason]) => reason)],
            [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
            [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
          ];
        }
      }
      var PairSet = class {
        constructor() {
          this._data = /* @__PURE__ */ new Map();
        }
        has(a, b, areMutuallyExclusive) {
          var _this$_data$get;
          const [key1, key2] = a < b ? [a, b] : [b, a];
          const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
          if (result === void 0) {
            return false;
          }
          return areMutuallyExclusive ? true : areMutuallyExclusive === result;
        }
        add(a, b, areMutuallyExclusive) {
          const [key1, key2] = a < b ? [a, b] : [b, a];
          const map = this._data.get(key1);
          if (map === void 0) {
            this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
          } else {
            map.set(key2, areMutuallyExclusive);
          }
        }
      };
    }
  });

  // node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
  var require_PossibleFragmentSpreadsRule = __commonJS({
    "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function PossibleFragmentSpreadsRule(context) {
        return {
          InlineFragment(node) {
            const fragType = context.getType();
            const parentType = context.getParentType();
            if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                nodes: node
              }));
            }
          },
          FragmentSpread(node) {
            const fragName = node.name.value;
            const fragType = getFragmentType(context, fragName);
            const parentType = context.getParentType();
            if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                nodes: node
              }));
            }
          }
        };
      }
      function getFragmentType(context, name) {
        const frag = context.getFragment(name);
        if (frag) {
          const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
          if ((0, _definition.isCompositeType)(type)) {
            return type;
          }
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
  var require_PossibleTypeExtensionsRule = __commonJS({
    "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      function PossibleTypeExtensionsRule(context) {
        const schema = context.getSchema();
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = def;
          }
        }
        return {
          ScalarTypeExtension: checkExtension,
          ObjectTypeExtension: checkExtension,
          InterfaceTypeExtension: checkExtension,
          UnionTypeExtension: checkExtension,
          EnumTypeExtension: checkExtension,
          InputObjectTypeExtension: checkExtension
        };
        function checkExtension(node) {
          const typeName = node.name.value;
          const defNode = definedTypes[typeName];
          const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
          let expectedKind;
          if (defNode) {
            expectedKind = defKindToExtKind[defNode.kind];
          } else if (existingType) {
            expectedKind = typeToExtKind(existingType);
          }
          if (expectedKind) {
            if (expectedKind !== node.kind) {
              const kindStr = extensionKindToTypeName(node.kind);
              context.reportError(new _GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
                nodes: defNode ? [defNode, node] : node
              }));
            }
          } else {
            const allTypeNames = Object.keys({
              ...definedTypes,
              ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
            });
            const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, allTypeNames);
            context.reportError(new _GraphQLError.GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes), {
              nodes: node.name
            }));
          }
        }
      }
      var defKindToExtKind = {
        [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
        [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
        [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
      };
      function typeToExtKind(type) {
        if ((0, _definition.isScalarType)(type)) {
          return _kinds.Kind.SCALAR_TYPE_EXTENSION;
        }
        if ((0, _definition.isObjectType)(type)) {
          return _kinds.Kind.OBJECT_TYPE_EXTENSION;
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
        }
        if ((0, _definition.isUnionType)(type)) {
          return _kinds.Kind.UNION_TYPE_EXTENSION;
        }
        if ((0, _definition.isEnumType)(type)) {
          return _kinds.Kind.ENUM_TYPE_EXTENSION;
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
      function extensionKindToTypeName(kind) {
        switch (kind) {
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return "scalar";
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return "object";
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return "interface";
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return "union";
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return "enum";
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object";
          default:
            (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(kind));
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
  var require_ProvidedRequiredArgumentsRule = __commonJS({
    "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
      exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      function ProvidedRequiredArgumentsRule(context) {
        return {
          ...ProvidedRequiredArgumentsOnDirectivesRule(context),
          Field: {
            leave(fieldNode) {
              var _fieldNode$arguments;
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                return false;
              }
              const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value));
              for (const argDef of fieldDef.args) {
                if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                  const argTypeStr = (0, _inspect.inspect)(argDef.type);
                  context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
                    nodes: fieldNode
                  }));
                }
              }
            }
          }
        };
      }
      function ProvidedRequiredArgumentsOnDirectivesRule(context) {
        var _schema$getDirectives;
        const requiredArgsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(directive.args.filter(_definition.isRequiredArgument), (arg) => arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
          }
        }
        return {
          Directive: {
            leave(directiveNode) {
              const directiveName = directiveNode.name.value;
              const requiredArgs = requiredArgsMap[directiveName];
              if (requiredArgs) {
                var _directiveNode$argume;
                const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
                for (const [argName, argDef] of Object.entries(requiredArgs)) {
                  if (!argNodeMap.has(argName)) {
                    const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                    context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                      nodes: directiveNode
                    }));
                  }
                }
              }
            }
          }
        };
      }
      function isRequiredArgumentNode(arg) {
        return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
      }
    }
  });

  // node_modules/graphql/validation/rules/ScalarLeafsRule.js
  var require_ScalarLeafsRule = __commonJS({
    "node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ScalarLeafsRule = ScalarLeafsRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function ScalarLeafsRule(context) {
        return {
          Field(node) {
            const type = context.getType();
            const selectionSet = node.selectionSet;
            if (type) {
              if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
                if (selectionSet) {
                  const fieldName = node.name.value;
                  const typeStr = (0, _inspect.inspect)(type);
                  context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
                    nodes: selectionSet
                  }));
                }
              } else if (!selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
                  nodes: node
                }));
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/jsutils/printPathArray.js
  var require_printPathArray = __commonJS({
    "node_modules/graphql/jsutils/printPathArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printPathArray = printPathArray;
      function printPathArray(path) {
        return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
      }
    }
  });

  // node_modules/graphql/jsutils/Path.js
  var require_Path = __commonJS({
    "node_modules/graphql/jsutils/Path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addPath = addPath;
      exports.pathToArray = pathToArray;
      function addPath(prev, key, typename) {
        return {
          prev,
          key,
          typename
        };
      }
      function pathToArray(path) {
        const flattened = [];
        let curr = path;
        while (curr) {
          flattened.push(curr.key);
          curr = curr.prev;
        }
        return flattened.reverse();
      }
    }
  });

  // node_modules/graphql/utilities/coerceInputValue.js
  var require_coerceInputValue = __commonJS({
    "node_modules/graphql/utilities/coerceInputValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.coerceInputValue = coerceInputValue;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _Path = require_Path();
      var _printPathArray = require_printPathArray();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function coerceInputValue(inputValue, type, onError = defaultOnError) {
        return coerceInputValueImpl(inputValue, type, onError, void 0);
      }
      function defaultOnError(path, invalidValue, error) {
        let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
        if (path.length > 0) {
          errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
        }
        error.message = errorPrefix + ": " + error.message;
        throw error;
      }
      function coerceInputValueImpl(inputValue, type, onError, path) {
        if ((0, _definition.isNonNullType)(type)) {
          if (inputValue != null) {
            return coerceInputValueImpl(inputValue, type.ofType, onError, path);
          }
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected non-nullable type "${(0, _inspect.inspect)(type)}" not to be null.`));
          return;
        }
        if (inputValue == null) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(inputValue)) {
            return Array.from(inputValue, (itemValue, index) => {
              const itemPath = (0, _Path.addPath)(path, index, void 0);
              return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
            });
          }
          return [coerceInputValueImpl(inputValue, itemType, onError, path)];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}" to be an object.`));
            return;
          }
          const coercedValue = {};
          const fieldDefs = type.getFields();
          for (const field of Object.values(fieldDefs)) {
            const fieldValue = inputValue[field.name];
            if (fieldValue === void 0) {
              if (field.defaultValue !== void 0) {
                coercedValue[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                const typeStr = (0, _inspect.inspect)(field.type);
                onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
              }
              continue;
            }
            coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
          }
          for (const fieldName of Object.keys(inputValue)) {
            if (!fieldDefs[fieldName]) {
              const suggestions = (0, _suggestionList.suggestionList)(fieldName, Object.keys(type.getFields()));
              onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)));
            }
          }
          return coercedValue;
        }
        if ((0, _definition.isLeafType)(type)) {
          let parseResult;
          try {
            parseResult = type.parseValue(inputValue);
          } catch (error) {
            if (error instanceof _GraphQLError.GraphQLError) {
              onError((0, _Path.pathToArray)(path), inputValue, error);
            } else {
              onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}". ` + error.message, {
                originalError: error
              }));
            }
            return;
          }
          if (parseResult === void 0) {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}".`));
          }
          return parseResult;
        }
        (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
      }
    }
  });

  // node_modules/graphql/utilities/valueFromAST.js
  var require_valueFromAST = __commonJS({
    "node_modules/graphql/utilities/valueFromAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.valueFromAST = valueFromAST;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _kinds = require_kinds();
      var _definition = require_definition();
      function valueFromAST(valueNode, type, variables) {
        if (!valueNode) {
          return;
        }
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variables == null || variables[variableName] === void 0) {
            return;
          }
          const variableValue = variables[variableName];
          if (variableValue === null && (0, _definition.isNonNullType)(type)) {
            return;
          }
          return variableValue;
        }
        if ((0, _definition.isNonNullType)(type)) {
          if (valueNode.kind === _kinds.Kind.NULL) {
            return;
          }
          return valueFromAST(valueNode, type.ofType, variables);
        }
        if (valueNode.kind === _kinds.Kind.NULL) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if (valueNode.kind === _kinds.Kind.LIST) {
            const coercedValues = [];
            for (const itemNode of valueNode.values) {
              if (isMissingVariable(itemNode, variables)) {
                if ((0, _definition.isNonNullType)(itemType)) {
                  return;
                }
                coercedValues.push(null);
              } else {
                const itemValue = valueFromAST(itemNode, itemType, variables);
                if (itemValue === void 0) {
                  return;
                }
                coercedValues.push(itemValue);
              }
            }
            return coercedValues;
          }
          const coercedValue = valueFromAST(valueNode, itemType, variables);
          if (coercedValue === void 0) {
            return;
          }
          return [coercedValue];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (valueNode.kind !== _kinds.Kind.OBJECT) {
            return;
          }
          const coercedObj = /* @__PURE__ */ Object.create(null);
          const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, (field) => field.name.value);
          for (const field of Object.values(type.getFields())) {
            const fieldNode = fieldNodes[field.name];
            if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
              if (field.defaultValue !== void 0) {
                coercedObj[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                return;
              }
              continue;
            }
            const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
            if (fieldValue === void 0) {
              return;
            }
            coercedObj[field.name] = fieldValue;
          }
          return coercedObj;
        }
        if ((0, _definition.isLeafType)(type)) {
          let result;
          try {
            result = type.parseLiteral(valueNode, variables);
          } catch (_error) {
            return;
          }
          if (result === void 0) {
            return;
          }
          return result;
        }
        (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
      }
      function isMissingVariable(valueNode, variables) {
        return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
      }
    }
  });

  // node_modules/graphql/execution/values.js
  var require_values = __commonJS({
    "node_modules/graphql/execution/values.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getArgumentValues = getArgumentValues;
      exports.getDirectiveValues = getDirectiveValues;
      exports.getVariableValues = getVariableValues;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _printPathArray = require_printPathArray();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _coerceInputValue = require_coerceInputValue();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      function getVariableValues(schema, varDefNodes, inputs, options) {
        const errors = [];
        const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
        try {
          const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error) => {
            if (maxErrors != null && errors.length >= maxErrors) {
              throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
            }
            errors.push(error);
          });
          if (errors.length === 0) {
            return {
              coerced
            };
          }
        } catch (error) {
          errors.push(error);
        }
        return {
          errors
        };
      }
      function coerceVariableValues(schema, varDefNodes, inputs, onError) {
        const coercedValues = {};
        for (const varDefNode of varDefNodes) {
          const varName = varDefNode.variable.name.value;
          const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
          if (!(0, _definition.isInputType)(varType)) {
            const varTypeStr = (0, _printer.print)(varDefNode.type);
            onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
              nodes: varDefNode.type
            }));
            continue;
          }
          if (!hasOwnProperty(inputs, varName)) {
            if (varDefNode.defaultValue) {
              coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
            } else if ((0, _definition.isNonNullType)(varType)) {
              const varTypeStr = (0, _inspect.inspect)(varType);
              onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
                nodes: varDefNode
              }));
            }
            continue;
          }
          const value = inputs[varName];
          if (value === null && (0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
              nodes: varDefNode
            }));
            continue;
          }
          coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error) => {
            let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
            if (path.length > 0) {
              prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(path)}"`;
            }
            onError(new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
              nodes: varDefNode,
              originalError: error.originalError
            }));
          });
        }
        return coercedValues;
      }
      function getArgumentValues(def, node, variableValues) {
        var _node$arguments;
        const coercedValues = {};
        const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
        const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, (arg) => arg.name.value);
        for (const argDef of def.args) {
          const name = argDef.name;
          const argType = argDef.type;
          const argumentNode = argNodeMap[name];
          if (!argumentNode) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" was not provided.`, {
                nodes: node
              });
            }
            continue;
          }
          const valueNode = argumentNode.value;
          let isNull = valueNode.kind === _kinds.Kind.NULL;
          if (valueNode.kind === _kinds.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
              if (argDef.defaultValue !== void 0) {
                coercedValues[name] = argDef.defaultValue;
              } else if ((0, _definition.isNonNullType)(argType)) {
                throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                  nodes: valueNode
                });
              }
              continue;
            }
            isNull = variableValues[variableName] == null;
          }
          if (isNull && (0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" of non-null type "${(0, _inspect.inspect)(argType)}" must not be null.`, {
              nodes: valueNode
            });
          }
          const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
          if (coercedValue === void 0) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" has invalid value ${(0, _printer.print)(valueNode)}.`, {
              nodes: valueNode
            });
          }
          coercedValues[name] = coercedValue;
        }
        return coercedValues;
      }
      function getDirectiveValues(directiveDef, node, variableValues) {
        var _node$directives;
        const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive) => directive.name.value === directiveDef.name);
        if (directiveNode) {
          return getArgumentValues(directiveDef, directiveNode, variableValues);
        }
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }
  });

  // node_modules/graphql/execution/collectFields.js
  var require_collectFields = __commonJS({
    "node_modules/graphql/execution/collectFields.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.collectFields = collectFields;
      exports.collectSubfields = collectSubfields;
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _directives = require_directives();
      var _typeFromAST = require_typeFromAST();
      var _values = require_values();
      function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
        const fields = /* @__PURE__ */ new Map();
        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, /* @__PURE__ */ new Set());
        return fields;
      }
      function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
        const subFieldNodes = /* @__PURE__ */ new Map();
        const visitedFragmentNames = /* @__PURE__ */ new Set();
        for (const node of fieldNodes) {
          if (node.selectionSet) {
            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
          }
        }
        return subFieldNodes;
      }
      function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              if (!shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              const name = getFieldEntryKey(selection);
              const fieldList = fields.get(name);
              if (fieldList !== void 0) {
                fieldList.push(selection);
              } else {
                fields.set(name, [selection]);
              }
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT: {
              if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                continue;
              }
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD: {
              const fragName = selection.name.value;
              if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
                continue;
              }
              visitedFragmentNames.add(fragName);
              const fragment = fragments[fragName];
              if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                continue;
              }
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
              break;
            }
          }
        }
      }
      function shouldIncludeNode(variableValues, node) {
        const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, variableValues);
        if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
          return false;
        }
        const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, variableValues);
        if ((include === null || include === void 0 ? void 0 : include.if) === false) {
          return false;
        }
        return true;
      }
      function doesFragmentConditionMatch(schema, fragment, type) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode) {
          return true;
        }
        const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);
        if (conditionalType === type) {
          return true;
        }
        if ((0, _definition.isAbstractType)(conditionalType)) {
          return schema.isSubType(conditionalType, type);
        }
        return false;
      }
      function getFieldEntryKey(node) {
        return node.alias ? node.alias.value : node.name.value;
      }
    }
  });

  // node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
  var require_SingleFieldSubscriptionsRule = __commonJS({
    "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _collectFields = require_collectFields();
      function SingleFieldSubscriptionsRule(context) {
        return {
          OperationDefinition(node) {
            if (node.operation === "subscription") {
              const schema = context.getSchema();
              const subscriptionType = schema.getSubscriptionType();
              if (subscriptionType) {
                const operationName = node.name ? node.name.value : null;
                const variableValues = /* @__PURE__ */ Object.create(null);
                const document2 = context.getDocument();
                const fragments = /* @__PURE__ */ Object.create(null);
                for (const definition of document2.definitions) {
                  if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                    fragments[definition.name.value] = definition;
                  }
                }
                const fields = (0, _collectFields.collectFields)(schema, fragments, variableValues, subscriptionType, node.selectionSet);
                if (fields.size > 1) {
                  const fieldSelectionLists = [...fields.values()];
                  const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                  const extraFieldSelections = extraFieldSelectionLists.flat();
                  context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
                    nodes: extraFieldSelections
                  }));
                }
                for (const fieldNodes of fields.values()) {
                  const field = fieldNodes[0];
                  const fieldName = field.name.value;
                  if (fieldName.startsWith("__")) {
                    context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                      nodes: fieldNodes
                    }));
                  }
                }
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/jsutils/groupBy.js
  var require_groupBy = __commonJS({
    "node_modules/graphql/jsutils/groupBy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.groupBy = groupBy;
      function groupBy(list, keyFn) {
        const result = /* @__PURE__ */ new Map();
        for (const item of list) {
          const key = keyFn(item);
          const group2 = result.get(key);
          if (group2 === void 0) {
            result.set(key, [item]);
          } else {
            group2.push(item);
          }
        }
        return result;
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
  var require_UniqueArgumentDefinitionNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentDefinitionNamesRule(context) {
        return {
          DirectiveDefinition(directiveNode) {
            var _directiveNode$argume;
            const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
          },
          InterfaceTypeDefinition: checkArgUniquenessPerField,
          InterfaceTypeExtension: checkArgUniquenessPerField,
          ObjectTypeDefinition: checkArgUniquenessPerField,
          ObjectTypeExtension: checkArgUniquenessPerField
        };
        function checkArgUniquenessPerField(typeNode) {
          var _typeNode$fields;
          const typeName = typeNode.name.value;
          const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
          for (const fieldDef of fieldNodes) {
            var _fieldDef$arguments;
            const fieldName = fieldDef.name.value;
            const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
            checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
          }
          return false;
        }
        function checkArgUniqueness(parentName, argumentNodes) {
          const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(new _GraphQLError.GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
                nodes: argNodes.map((node) => node.name)
              }));
            }
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
  var require_UniqueArgumentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentNamesRule(context) {
        return {
          Field: checkArgUniqueness,
          Directive: checkArgUniqueness
        };
        function checkArgUniqueness(parentNode) {
          var _parentNode$arguments;
          const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
          const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one argument named "${argName}".`, {
                nodes: argNodes.map((node) => node.name)
              }));
            }
          }
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
  var require_UniqueDirectiveNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueDirectiveNamesRule(context) {
        const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          DirectiveDefinition(node) {
            const directiveName = node.name.value;
            if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
              context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
                nodes: node.name
              }));
              return;
            }
            if (knownDirectiveNames[directiveName]) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one directive named "@${directiveName}".`, {
                nodes: [knownDirectiveNames[directiveName], node.name]
              }));
            } else {
              knownDirectiveNames[directiveName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
  var require_UniqueDirectivesPerLocationRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _directives = require_directives();
      function UniqueDirectivesPerLocationRule(context) {
        const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
          }
        }
        const schemaDirectives = /* @__PURE__ */ Object.create(null);
        const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
        return {
          enter(node) {
            if (!("directives" in node) || !node.directives) {
              return;
            }
            let seenDirectives;
            if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
              seenDirectives = schemaDirectives;
            } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
              const typeName = node.name.value;
              seenDirectives = typeDirectivesMap[typeName];
              if (seenDirectives === void 0) {
                typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
              }
            } else {
              seenDirectives = /* @__PURE__ */ Object.create(null);
            }
            for (const directive of node.directives) {
              const directiveName = directive.name.value;
              if (uniqueDirectiveMap[directiveName]) {
                if (seenDirectives[directiveName]) {
                  context.reportError(new _GraphQLError.GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                    nodes: [seenDirectives[directiveName], directive]
                  }));
                } else {
                  seenDirectives[directiveName] = directive;
                }
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
  var require_UniqueEnumValueNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueEnumValueNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownValueNames = /* @__PURE__ */ Object.create(null);
        return {
          EnumTypeDefinition: checkValueUniqueness,
          EnumTypeExtension: checkValueUniqueness
        };
        function checkValueUniqueness(node) {
          var _node$values;
          const typeName = node.name.value;
          if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          const valueNames = knownValueNames[typeName];
          for (const valueDef of valueNodes) {
            const valueName = valueDef.name.value;
            const existingType = existingTypeMap[typeName];
            if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
              context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                nodes: valueDef.name
              }));
            } else if (valueNames[valueName]) {
              context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
                nodes: [valueNames[valueName], valueDef.name]
              }));
            } else {
              valueNames[valueName] = valueDef.name;
            }
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
  var require_UniqueFieldDefinitionNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueFieldDefinitionNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownFieldNames = /* @__PURE__ */ Object.create(null);
        return {
          InputObjectTypeDefinition: checkFieldUniqueness,
          InputObjectTypeExtension: checkFieldUniqueness,
          InterfaceTypeDefinition: checkFieldUniqueness,
          InterfaceTypeExtension: checkFieldUniqueness,
          ObjectTypeDefinition: checkFieldUniqueness,
          ObjectTypeExtension: checkFieldUniqueness
        };
        function checkFieldUniqueness(node) {
          var _node$fields;
          const typeName = node.name.value;
          if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          const fieldNames = knownFieldNames[typeName];
          for (const fieldDef of fieldNodes) {
            const fieldName = fieldDef.name.value;
            if (hasField(existingTypeMap[typeName], fieldName)) {
              context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                nodes: fieldDef.name
              }));
            } else if (fieldNames[fieldName]) {
              context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
                nodes: [fieldNames[fieldName], fieldDef.name]
              }));
            } else {
              fieldNames[fieldName] = fieldDef.name;
            }
          }
          return false;
        }
      }
      function hasField(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
          return type.getFields()[fieldName] != null;
        }
        return false;
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
  var require_UniqueFragmentNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueFragmentNamesRule(context) {
        const knownFragmentNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            const fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
                nodes: [knownFragmentNames[fragmentName], node.name]
              }));
            } else {
              knownFragmentNames[fragmentName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
  var require_UniqueInputFieldNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      function UniqueInputFieldNamesRule(context) {
        const knownNameStack = [];
        let knownNames = /* @__PURE__ */ Object.create(null);
        return {
          ObjectValue: {
            enter() {
              knownNameStack.push(knownNames);
              knownNames = /* @__PURE__ */ Object.create(null);
            },
            leave() {
              const prevKnownNames = knownNameStack.pop();
              prevKnownNames || (0, _invariant.invariant)(false);
              knownNames = prevKnownNames;
            }
          },
          ObjectField(node) {
            const fieldName = node.name.value;
            if (knownNames[fieldName]) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one input field named "${fieldName}".`, {
                nodes: [knownNames[fieldName], node.name]
              }));
            } else {
              knownNames[fieldName] = node.name;
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
  var require_UniqueOperationNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationNamesRule(context) {
        const knownOperationNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition(node) {
            const operationName = node.name;
            if (operationName) {
              if (knownOperationNames[operationName.value]) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one operation named "${operationName.value}".`, {
                  nodes: [
                    knownOperationNames[operationName.value],
                    operationName
                  ]
                }));
              } else {
                knownOperationNames[operationName.value] = operationName;
              }
            }
            return false;
          },
          FragmentDefinition: () => false
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
  var require_UniqueOperationTypesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationTypesRule(context) {
        const schema = context.getSchema();
        const definedOperationTypes = /* @__PURE__ */ Object.create(null);
        const existingOperationTypes = schema ? {
          query: schema.getQueryType(),
          mutation: schema.getMutationType(),
          subscription: schema.getSubscriptionType()
        } : {};
        return {
          SchemaDefinition: checkOperationTypes,
          SchemaExtension: checkOperationTypes
        };
        function checkOperationTypes(node) {
          var _node$operationTypes;
          const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (const operationType of operationTypesNodes) {
            const operation = operationType.operation;
            const alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
              context.reportError(new _GraphQLError.GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
                nodes: operationType
              }));
            } else if (alreadyDefinedOperationType) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one ${operation} type in schema.`, {
                nodes: [alreadyDefinedOperationType, operationType]
              }));
            } else {
              definedOperationTypes[operation] = operationType;
            }
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
  var require_UniqueTypeNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
      var _GraphQLError = require_GraphQLError();
      function UniqueTypeNamesRule(context) {
        const knownTypeNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          ScalarTypeDefinition: checkTypeName,
          ObjectTypeDefinition: checkTypeName,
          InterfaceTypeDefinition: checkTypeName,
          UnionTypeDefinition: checkTypeName,
          EnumTypeDefinition: checkTypeName,
          InputObjectTypeDefinition: checkTypeName
        };
        function checkTypeName(node) {
          const typeName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
            context.reportError(new _GraphQLError.GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
              nodes: node.name
            }));
            return;
          }
          if (knownTypeNames[typeName]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one type named "${typeName}".`, {
              nodes: [knownTypeNames[typeName], node.name]
            }));
          } else {
            knownTypeNames[typeName] = node.name;
          }
          return false;
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
  var require_UniqueVariableNamesRule = __commonJS({
    "node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueVariableNamesRule(context) {
        return {
          OperationDefinition(operationNode) {
            var _operationNode$variab;
            const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
            const seenVariableDefinitions = (0, _groupBy.groupBy)(variableDefinitions, (node) => node.variable.name.value);
            for (const [variableName, variableNodes] of seenVariableDefinitions) {
              if (variableNodes.length > 1) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one variable named "$${variableName}".`, {
                  nodes: variableNodes.map((node) => node.variable.name)
                }));
              }
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
  var require_ValuesOfCorrectTypeRule = __commonJS({
    "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      function ValuesOfCorrectTypeRule(context) {
        return {
          ListValue(node) {
            const type = (0, _definition.getNullableType)(context.getParentInputType());
            if (!(0, _definition.isListType)(type)) {
              isValidValueNode(context, node);
              return false;
            }
          },
          ObjectValue(node) {
            const type = (0, _definition.getNamedType)(context.getInputType());
            if (!(0, _definition.isInputObjectType)(type)) {
              isValidValueNode(context, node);
              return false;
            }
            const fieldNodeMap = (0, _keyMap.keyMap)(node.fields, (field) => field.name.value);
            for (const fieldDef of Object.values(type.getFields())) {
              const fieldNode = fieldNodeMap[fieldDef.name];
              if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
                const typeStr = (0, _inspect.inspect)(fieldDef.type);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
                  nodes: node
                }));
              }
            }
          },
          ObjectField(node) {
            const parentType = (0, _definition.getNamedType)(context.getParentInputType());
            const fieldType = context.getInputType();
            if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
              const suggestions = (0, _suggestionList.suggestionList)(node.name.value, Object.keys(parentType.getFields()));
              context.reportError(new _GraphQLError.GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
                nodes: node
              }));
            }
          },
          NullValue(node) {
            const type = context.getInputType();
            if ((0, _definition.isNonNullType)(type)) {
              context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${(0, _inspect.inspect)(type)}", found ${(0, _printer.print)(node)}.`, {
                nodes: node
              }));
            }
          },
          EnumValue: (node) => isValidValueNode(context, node),
          IntValue: (node) => isValidValueNode(context, node),
          FloatValue: (node) => isValidValueNode(context, node),
          StringValue: (node) => isValidValueNode(context, node),
          BooleanValue: (node) => isValidValueNode(context, node)
        };
      }
      function isValidValueNode(context, node) {
        const locationType = context.getInputType();
        if (!locationType) {
          return;
        }
        const type = (0, _definition.getNamedType)(locationType);
        if (!(0, _definition.isLeafType)(type)) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
            nodes: node
          }));
          return;
        }
        try {
          const parseResult = type.parseLiteral(node, void 0);
          if (parseResult === void 0) {
            const typeStr = (0, _inspect.inspect)(locationType);
            context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
              nodes: node
            }));
          }
        } catch (error) {
          const typeStr = (0, _inspect.inspect)(locationType);
          if (error instanceof _GraphQLError.GraphQLError) {
            context.reportError(error);
          } else {
            context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}; ` + error.message, {
              nodes: node,
              originalError: error
            }));
          }
        }
      }
    }
  });

  // node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
  var require_VariablesAreInputTypesRule = __commonJS({
    "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function VariablesAreInputTypesRule(context) {
        return {
          VariableDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
            if (type !== void 0 && !(0, _definition.isInputType)(type)) {
              const variableName = node.variable.name.value;
              const typeName = (0, _printer.print)(node.type);
              context.reportError(new _GraphQLError.GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, {
                nodes: node.type
              }));
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
  var require_VariablesInAllowedPositionRule = __commonJS({
    "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function VariablesInAllowedPositionRule(context) {
        let varDefMap = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              varDefMap = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node, type, defaultValue } of usages) {
                const varName = node.name.value;
                const varDef = varDefMap[varName];
                if (varDef && type) {
                  const schema = context.getSchema();
                  const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                  if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                    const varTypeStr = (0, _inspect.inspect)(varType);
                    const typeStr = (0, _inspect.inspect)(type);
                    context.reportError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                      nodes: [varDef, node]
                    }));
                  }
                }
              }
            }
          },
          VariableDefinition(node) {
            varDefMap[node.variable.name.value] = node;
          }
        };
      }
      function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
        if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
          const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
          const hasLocationDefaultValue = locationDefaultValue !== void 0;
          if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
          }
          const nullableLocationType = locationType.ofType;
          return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
        }
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
      }
    }
  });

  // node_modules/graphql/validation/specifiedRules.js
  var require_specifiedRules = __commonJS({
    "node_modules/graphql/validation/specifiedRules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.specifiedSDLRules = exports.specifiedRules = void 0;
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var specifiedRules = Object.freeze([
        _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
        _UniqueOperationNamesRule.UniqueOperationNamesRule,
        _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
        _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
        _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
        _ScalarLeafsRule.ScalarLeafsRule,
        _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
        _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
        _KnownFragmentNamesRule.KnownFragmentNamesRule,
        _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
        _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
        _NoFragmentCyclesRule.NoFragmentCyclesRule,
        _UniqueVariableNamesRule.UniqueVariableNamesRule,
        _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
        _NoUnusedVariablesRule.NoUnusedVariablesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _KnownArgumentNamesRule.KnownArgumentNamesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
        _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
        _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
      ]);
      exports.specifiedRules = specifiedRules;
      var specifiedSDLRules = Object.freeze([
        _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
        _UniqueOperationTypesRule.UniqueOperationTypesRule,
        _UniqueTypeNamesRule.UniqueTypeNamesRule,
        _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
        _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
        _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
        _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
        _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
      ]);
      exports.specifiedSDLRules = specifiedSDLRules;
    }
  });

  // node_modules/graphql/validation/ValidationContext.js
  var require_ValidationContext = __commonJS({
    "node_modules/graphql/validation/ValidationContext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _TypeInfo = require_TypeInfo();
      var ASTValidationContext = class {
        constructor(ast, onError) {
          this._ast = ast;
          this._fragments = void 0;
          this._fragmentSpreads = /* @__PURE__ */ new Map();
          this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
          this._onError = onError;
        }
        get [Symbol.toStringTag]() {
          return "ASTValidationContext";
        }
        reportError(error) {
          this._onError(error);
        }
        getDocument() {
          return this._ast;
        }
        getFragment(name) {
          let fragments;
          if (this._fragments) {
            fragments = this._fragments;
          } else {
            fragments = /* @__PURE__ */ Object.create(null);
            for (const defNode of this.getDocument().definitions) {
              if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                fragments[defNode.name.value] = defNode;
              }
            }
            this._fragments = fragments;
          }
          return fragments[name];
        }
        getFragmentSpreads(node) {
          let spreads = this._fragmentSpreads.get(node);
          if (!spreads) {
            spreads = [];
            const setsToVisit = [node];
            let set;
            while (set = setsToVisit.pop()) {
              for (const selection of set.selections) {
                if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                  spreads.push(selection);
                } else if (selection.selectionSet) {
                  setsToVisit.push(selection.selectionSet);
                }
              }
            }
            this._fragmentSpreads.set(node, spreads);
          }
          return spreads;
        }
        getRecursivelyReferencedFragments(operation) {
          let fragments = this._recursivelyReferencedFragments.get(operation);
          if (!fragments) {
            fragments = [];
            const collectedNames = /* @__PURE__ */ Object.create(null);
            const nodesToVisit = [operation.selectionSet];
            let node;
            while (node = nodesToVisit.pop()) {
              for (const spread of this.getFragmentSpreads(node)) {
                const fragName = spread.name.value;
                if (collectedNames[fragName] !== true) {
                  collectedNames[fragName] = true;
                  const fragment = this.getFragment(fragName);
                  if (fragment) {
                    fragments.push(fragment);
                    nodesToVisit.push(fragment.selectionSet);
                  }
                }
              }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
          }
          return fragments;
        }
      };
      exports.ASTValidationContext = ASTValidationContext;
      var SDLValidationContext = class extends ASTValidationContext {
        constructor(ast, schema, onError) {
          super(ast, onError);
          this._schema = schema;
        }
        get [Symbol.toStringTag]() {
          return "SDLValidationContext";
        }
        getSchema() {
          return this._schema;
        }
      };
      exports.SDLValidationContext = SDLValidationContext;
      var ValidationContext = class extends ASTValidationContext {
        constructor(schema, ast, typeInfo, onError) {
          super(ast, onError);
          this._schema = schema;
          this._typeInfo = typeInfo;
          this._variableUsages = /* @__PURE__ */ new Map();
          this._recursiveVariableUsages = /* @__PURE__ */ new Map();
        }
        get [Symbol.toStringTag]() {
          return "ValidationContext";
        }
        getSchema() {
          return this._schema;
        }
        getVariableUsages(node) {
          let usages = this._variableUsages.get(node);
          if (!usages) {
            const newUsages = [];
            const typeInfo = new _TypeInfo.TypeInfo(this._schema);
            (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            }));
            usages = newUsages;
            this._variableUsages.set(node, usages);
          }
          return usages;
        }
        getRecursiveVariableUsages(operation) {
          let usages = this._recursiveVariableUsages.get(operation);
          if (!usages) {
            usages = this.getVariableUsages(operation);
            for (const frag of this.getRecursivelyReferencedFragments(operation)) {
              usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
          }
          return usages;
        }
        getType() {
          return this._typeInfo.getType();
        }
        getParentType() {
          return this._typeInfo.getParentType();
        }
        getInputType() {
          return this._typeInfo.getInputType();
        }
        getParentInputType() {
          return this._typeInfo.getParentInputType();
        }
        getFieldDef() {
          return this._typeInfo.getFieldDef();
        }
        getDirective() {
          return this._typeInfo.getDirective();
        }
        getArgument() {
          return this._typeInfo.getArgument();
        }
        getEnumValue() {
          return this._typeInfo.getEnumValue();
        }
      };
      exports.ValidationContext = ValidationContext;
    }
  });

  // node_modules/graphql/validation/validate.js
  var require_validate2 = __commonJS({
    "node_modules/graphql/validation/validate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidSDL = assertValidSDL;
      exports.assertValidSDLExtension = assertValidSDLExtension;
      exports.validate = validate;
      exports.validateSDL = validateSDL;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _visitor = require_visitor();
      var _validate = require_validate();
      var _TypeInfo = require_TypeInfo();
      var _specifiedRules = require_specifiedRules();
      var _ValidationContext = require_ValidationContext();
      function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
        var _options$maxErrors;
        const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
        documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        const abortObj = Object.freeze({});
        const errors = [];
        const context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, (error) => {
          if (errors.length >= maxErrors) {
            errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
            throw abortObj;
          }
          errors.push(error);
        });
        const visitor = (0, _visitor.visitInParallel)(rules.map((rule) => rule(context)));
        try {
          (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
        } catch (e) {
          if (e !== abortObj) {
            throw e;
          }
        }
        return errors;
      }
      function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
        const errors = [];
        const context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, (error) => {
          errors.push(error);
        });
        const visitors = rules.map((rule) => rule(context));
        (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
        return errors;
      }
      function assertValidSDL(documentAST) {
        const errors = validateSDL(documentAST);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      function assertValidSDLExtension(documentAST, schema) {
        const errors = validateSDL(documentAST, schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
    }
  });

  // node_modules/graphql/jsutils/memoize3.js
  var require_memoize3 = __commonJS({
    "node_modules/graphql/jsutils/memoize3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.memoize3 = memoize3;
      function memoize3(fn) {
        let cache0;
        return function memoized(a1, a2, a3) {
          if (cache0 === void 0) {
            cache0 = /* @__PURE__ */ new WeakMap();
          }
          let cache1 = cache0.get(a1);
          if (cache1 === void 0) {
            cache1 = /* @__PURE__ */ new WeakMap();
            cache0.set(a1, cache1);
          }
          let cache2 = cache1.get(a2);
          if (cache2 === void 0) {
            cache2 = /* @__PURE__ */ new WeakMap();
            cache1.set(a2, cache2);
          }
          let fnResult = cache2.get(a3);
          if (fnResult === void 0) {
            fnResult = fn(a1, a2, a3);
            cache2.set(a3, fnResult);
          }
          return fnResult;
        };
      }
    }
  });

  // node_modules/graphql/jsutils/promiseForObject.js
  var require_promiseForObject = __commonJS({
    "node_modules/graphql/jsutils/promiseForObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseForObject = promiseForObject;
      function promiseForObject(object) {
        return Promise.all(Object.values(object)).then((resolvedValues) => {
          const resolvedObject = /* @__PURE__ */ Object.create(null);
          for (const [i, key] of Object.keys(object).entries()) {
            resolvedObject[key] = resolvedValues[i];
          }
          return resolvedObject;
        });
      }
    }
  });

  // node_modules/graphql/jsutils/promiseReduce.js
  var require_promiseReduce = __commonJS({
    "node_modules/graphql/jsutils/promiseReduce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.promiseReduce = promiseReduce;
      var _isPromise = require_isPromise();
      function promiseReduce(values, callbackFn, initialValue) {
        let accumulator = initialValue;
        for (const value of values) {
          accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
        }
        return accumulator;
      }
    }
  });

  // node_modules/graphql/jsutils/toError.js
  var require_toError = __commonJS({
    "node_modules/graphql/jsutils/toError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toError = toError;
      var _inspect = require_inspect();
      function toError(thrownValue) {
        return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
      }
      var NonErrorThrown = class extends Error {
        constructor(thrownValue) {
          super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
          this.name = "NonErrorThrown";
          this.thrownValue = thrownValue;
        }
      };
    }
  });

  // node_modules/graphql/error/locatedError.js
  var require_locatedError = __commonJS({
    "node_modules/graphql/error/locatedError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.locatedError = locatedError;
      var _toError = require_toError();
      var _GraphQLError = require_GraphQLError();
      function locatedError(rawOriginalError, nodes, path) {
        var _nodes;
        const originalError = (0, _toError.toError)(rawOriginalError);
        if (isLocatedGraphQLError(originalError)) {
          return originalError;
        }
        return new _GraphQLError.GraphQLError(originalError.message, {
          nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
          source: originalError.source,
          positions: originalError.positions,
          path,
          originalError
        });
      }
      function isLocatedGraphQLError(error) {
        return Array.isArray(error.path);
      }
    }
  });

  // node_modules/graphql/execution/execute.js
  var require_execute = __commonJS({
    "node_modules/graphql/execution/execute.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidExecutionArguments = assertValidExecutionArguments;
      exports.buildExecutionContext = buildExecutionContext;
      exports.buildResolveInfo = buildResolveInfo;
      exports.defaultTypeResolver = exports.defaultFieldResolver = void 0;
      exports.execute = execute;
      exports.executeSync = executeSync;
      exports.getFieldDef = getFieldDef;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _isPromise = require_isPromise();
      var _memoize = require_memoize3();
      var _Path = require_Path();
      var _promiseForObject = require_promiseForObject();
      var _promiseReduce = require_promiseReduce();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _ast = require_ast();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _collectFields = require_collectFields();
      var _values = require_values();
      var collectSubfields = (0, _memoize.memoize3)((exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
      function execute(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
        const { schema, document: document2, variableValues, rootValue } = args;
        assertValidExecutionArguments(schema, document2, variableValues);
        const exeContext = buildExecutionContext(args);
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const { operation } = exeContext;
          const result = executeOperation(exeContext, operation, rootValue);
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((data) => buildResponse(data, exeContext.errors), (error) => {
              exeContext.errors.push(error);
              return buildResponse(null, exeContext.errors);
            });
          }
          return buildResponse(result, exeContext.errors);
        } catch (error) {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      }
      function executeSync(args) {
        const result = execute(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function buildResponse(data, errors) {
        return errors.length === 0 ? {
          data
        } : {
          errors,
          data
        };
      }
      function assertValidExecutionArguments(schema, document2, rawVariableValues) {
        document2 || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(false, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
      }
      function buildExecutionContext(args) {
        var _definition$name, _operation$variableDe;
        const {
          schema,
          document: document2,
          rootValue,
          contextValue,
          variableValues: rawVariableValues,
          operationName,
          fieldResolver,
          typeResolver,
          subscribeFieldResolver
        } = args;
        let operation;
        const fragments = /* @__PURE__ */ Object.create(null);
        for (const definition of document2.definitions) {
          switch (definition.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              if (operationName == null) {
                if (operation !== void 0) {
                  return [
                    new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")
                  ];
                }
                operation = definition;
              } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                operation = definition;
              }
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              fragments[definition.name.value] = definition;
              break;
            default:
          }
        }
        if (!operation) {
          if (operationName != null) {
            return [
              new _GraphQLError.GraphQLError(`Unknown operation named "${operationName}".`)
            ];
          }
          return [new _GraphQLError.GraphQLError("Must provide an operation.")];
        }
        const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
        const coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
          maxErrors: 50
        });
        if (coercedVariableValues.errors) {
          return coercedVariableValues.errors;
        }
        return {
          schema,
          fragments,
          rootValue,
          contextValue,
          operation,
          variableValues: coercedVariableValues.coerced,
          fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
          typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
          subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
          errors: []
        };
      }
      function executeOperation(exeContext, operation, rootValue) {
        const rootType = exeContext.schema.getRootType(operation.operation);
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
            nodes: operation
          });
        }
        const rootFields = (0, _collectFields.collectFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
        const path = void 0;
        switch (operation.operation) {
          case _ast.OperationTypeNode.QUERY:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
          case _ast.OperationTypeNode.MUTATION:
            return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
        }
      }
      function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
        return (0, _promiseReduce.promiseReduce)(fields.entries(), (results, [responseName, fieldNodes]) => {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
          if (result === void 0) {
            return results;
          }
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((resolvedResult) => {
              results[responseName] = resolvedResult;
              return results;
            });
          }
          results[responseName] = result;
          return results;
        }, /* @__PURE__ */ Object.create(null));
      }
      function executeFields(exeContext, parentType, sourceValue, path, fields) {
        const results = /* @__PURE__ */ Object.create(null);
        let containsPromise = false;
        for (const [responseName, fieldNodes] of fields.entries()) {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
          if (result !== void 0) {
            results[responseName] = result;
            if ((0, _isPromise.isPromise)(result)) {
              containsPromise = true;
            }
          }
        }
        if (!containsPromise) {
          return results;
        }
        return (0, _promiseForObject.promiseForObject)(results);
      }
      function executeField(exeContext, parentType, source, fieldNodes, path) {
        var _fieldDef$resolve;
        const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
        if (!fieldDef) {
          return;
        }
        const returnType = fieldDef.type;
        const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
        const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
        try {
          const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
          const contextValue = exeContext.contextValue;
          const result = resolveFn(source, args, contextValue, info);
          let completed;
          if ((0, _isPromise.isPromise)(result)) {
            completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
          } else {
            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
          }
          if ((0, _isPromise.isPromise)(completed)) {
            return completed.then(void 0, (rawError) => {
              const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
              return handleFieldError(error, returnType, exeContext);
            });
          }
          return completed;
        } catch (rawError) {
          const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
          return handleFieldError(error, returnType, exeContext);
        }
      }
      function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
        return {
          fieldName: fieldDef.name,
          fieldNodes,
          returnType: fieldDef.type,
          parentType,
          path,
          schema: exeContext.schema,
          fragments: exeContext.fragments,
          rootValue: exeContext.rootValue,
          operation: exeContext.operation,
          variableValues: exeContext.variableValues
        };
      }
      function handleFieldError(error, returnType, exeContext) {
        if ((0, _definition.isNonNullType)(returnType)) {
          throw error;
        }
        exeContext.errors.push(error);
        return null;
      }
      function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (result instanceof Error) {
          throw result;
        }
        if ((0, _definition.isNonNullType)(returnType)) {
          const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
          if (completed === null) {
            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
          }
          return completed;
        }
        if (result == null) {
          return null;
        }
        if ((0, _definition.isListType)(returnType)) {
          return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _definition.isLeafType)(returnType)) {
          return completeLeafValue(returnType, result);
        }
        if ((0, _definition.isAbstractType)(returnType)) {
          return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _definition.isObjectType)(returnType)) {
          return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        (0, _invariant.invariant)(false, "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType));
      }
      function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (!(0, _isIterableObject.isIterableObject)(result)) {
          throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
        }
        const itemType = returnType.ofType;
        let containsPromise = false;
        const completedResults = Array.from(result, (item, index) => {
          const itemPath = (0, _Path.addPath)(path, index, void 0);
          try {
            let completedItem;
            if ((0, _isPromise.isPromise)(item)) {
              completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
            } else {
              completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
            }
            if ((0, _isPromise.isPromise)(completedItem)) {
              containsPromise = true;
              return completedItem.then(void 0, (rawError) => {
                const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
                return handleFieldError(error, itemType, exeContext);
              });
            }
            return completedItem;
          } catch (rawError) {
            const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
            return handleFieldError(error, itemType, exeContext);
          }
        });
        return containsPromise ? Promise.all(completedResults) : completedResults;
      }
      function completeLeafValue(returnType, result) {
        const serializedResult = returnType.serialize(result);
        if (serializedResult == null) {
          throw new Error(`Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(serializedResult)}`);
        }
        return serializedResult;
      }
      function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
        var _returnType$resolveTy;
        const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
        const contextValue = exeContext.contextValue;
        const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
        if ((0, _isPromise.isPromise)(runtimeType)) {
          return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
        }
        return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
      }
      function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
        if (runtimeTypeName == null) {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
        }
        if ((0, _definition.isObjectType)(runtimeTypeName)) {
          throw new _GraphQLError.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
        }
        if (typeof runtimeTypeName !== "string") {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`);
        }
        const runtimeType = exeContext.schema.getType(runtimeTypeName);
        if (runtimeType == null) {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
            nodes: fieldNodes
          });
        }
        if (!(0, _definition.isObjectType)(runtimeType)) {
          throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
            nodes: fieldNodes
          });
        }
        if (!exeContext.schema.isSubType(returnType, runtimeType)) {
          throw new _GraphQLError.GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
            nodes: fieldNodes
          });
        }
        return runtimeType;
      }
      function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
        const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
        if (returnType.isTypeOf) {
          const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
          if ((0, _isPromise.isPromise)(isTypeOf)) {
            return isTypeOf.then((resolvedIsTypeOf) => {
              if (!resolvedIsTypeOf) {
                throw invalidReturnTypeError(returnType, result, fieldNodes);
              }
              return executeFields(exeContext, returnType, result, path, subFieldNodes);
            });
          }
          if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
        }
        return executeFields(exeContext, returnType, result, path, subFieldNodes);
      }
      function invalidReturnTypeError(returnType, result, fieldNodes) {
        return new _GraphQLError.GraphQLError(`Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`, {
          nodes: fieldNodes
        });
      }
      var defaultTypeResolver = function(value, contextValue, info, abstractType) {
        if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
          return value.__typename;
        }
        const possibleTypes = info.schema.getPossibleTypes(abstractType);
        const promisedIsTypeOfResults = [];
        for (let i = 0; i < possibleTypes.length; i++) {
          const type = possibleTypes[i];
          if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if ((0, _isPromise.isPromise)(isTypeOfResult)) {
              promisedIsTypeOfResults[i] = isTypeOfResult;
            } else if (isTypeOfResult) {
              return type.name;
            }
          }
        }
        if (promisedIsTypeOfResults.length) {
          return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
            for (let i = 0; i < isTypeOfResults.length; i++) {
              if (isTypeOfResults[i]) {
                return possibleTypes[i].name;
              }
            }
          });
        }
      };
      exports.defaultTypeResolver = defaultTypeResolver;
      var defaultFieldResolver = function(source, args, contextValue, info) {
        if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
          const property = source[info.fieldName];
          if (typeof property === "function") {
            return source[info.fieldName](args, contextValue, info);
          }
          return property;
        }
      };
      exports.defaultFieldResolver = defaultFieldResolver;
      function getFieldDef(schema, parentType, fieldNode) {
        const fieldName = fieldNode.name.value;
        if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
          return _introspection.TypeNameMetaFieldDef;
        }
        return parentType.getFields()[fieldName];
      }
    }
  });

  // node_modules/graphql/graphql.js
  var require_graphql = __commonJS({
    "node_modules/graphql/graphql.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.graphql = graphql;
      exports.graphqlSync = graphqlSync;
      var _devAssert = require_devAssert();
      var _isPromise = require_isPromise();
      var _parser = require_parser();
      var _validate = require_validate();
      var _validate2 = require_validate2();
      var _execute = require_execute();
      function graphql(args) {
        return new Promise((resolve2) => resolve2(graphqlImpl(args)));
      }
      function graphqlSync(args) {
        const result = graphqlImpl(args);
        if ((0, _isPromise.isPromise)(result)) {
          throw new Error("GraphQL execution failed to complete synchronously.");
        }
        return result;
      }
      function graphqlImpl(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
        const {
          schema,
          source,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        } = args;
        const schemaValidationErrors = (0, _validate.validateSchema)(schema);
        if (schemaValidationErrors.length > 0) {
          return {
            errors: schemaValidationErrors
          };
        }
        let document2;
        try {
          document2 = (0, _parser.parse)(source);
        } catch (syntaxError) {
          return {
            errors: [syntaxError]
          };
        }
        const validationErrors = (0, _validate2.validate)(schema, document2);
        if (validationErrors.length > 0) {
          return {
            errors: validationErrors
          };
        }
        return (0, _execute.execute)({
          schema,
          document: document2,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        });
      }
    }
  });

  // node_modules/graphql/type/index.js
  var require_type = __commonJS({
    "node_modules/graphql/type/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _directives.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _scalars.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _schema.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _directives.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _scalars.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _definition.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _introspection.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _introspection.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _introspection.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _introspection.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _introspection.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _introspection.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _introspection.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _introspection.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _introspection.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _directives.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _definition.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _assertName.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _definition.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _definition.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _definition.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _assertName.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _definition.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _definition.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _definition.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _definition.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _definition.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _schema.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _definition.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _definition.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _validate.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _definition.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _definition.getNullableType;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _introspection.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _definition.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _definition.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _directives.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _definition.isEnumType;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _definition.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _definition.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _introspection.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _definition.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _definition.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _definition.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _definition.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _definition.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _definition.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _definition.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _definition.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _definition.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _schema.isSchema;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _directives.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _scalars.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _definition.isType;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _definition.isUnionType;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _definition.isWrappingType;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _definition.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _directives.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _scalars.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _validate.validateSchema;
        }
      });
      var _schema = require_schema();
      var _definition = require_definition();
      var _directives = require_directives();
      var _scalars = require_scalars();
      var _introspection = require_introspection();
      var _validate = require_validate();
      var _assertName = require_assertName();
    }
  });

  // node_modules/graphql/language/index.js
  var require_language = __commonJS({
    "node_modules/graphql/language/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _visitor.BREAK;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _directiveLocation.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _kinds.Kind;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _lexer.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _ast.Location;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _ast.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _source.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _ast.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _tokenKind.TokenKind;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _visitor.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _location.getLocation;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _visitor.getVisitFn;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _predicates.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _predicates.isValueNode;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _parser.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _parser.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _parser.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _parser.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _printer.print;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printLocation;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _printLocation.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _visitor.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _visitor.visitInParallel;
        }
      });
      var _source = require_source();
      var _location = require_location();
      var _printLocation = require_printLocation();
      var _kinds = require_kinds();
      var _tokenKind = require_tokenKind();
      var _lexer = require_lexer();
      var _parser = require_parser();
      var _printer = require_printer();
      var _visitor = require_visitor();
      var _ast = require_ast();
      var _predicates = require_predicates();
      var _directiveLocation = require_directiveLocation();
    }
  });

  // node_modules/graphql/jsutils/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "node_modules/graphql/jsutils/isAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isAsyncIterable = isAsyncIterable;
      function isAsyncIterable(maybeAsyncIterable) {
        return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
      }
    }
  });

  // node_modules/graphql/execution/mapAsyncIterator.js
  var require_mapAsyncIterator = __commonJS({
    "node_modules/graphql/execution/mapAsyncIterator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapAsyncIterator = mapAsyncIterator;
      function mapAsyncIterator(iterable, callback) {
        const iterator = iterable[Symbol.asyncIterator]();
        async function mapResult(result) {
          if (result.done) {
            return result;
          }
          try {
            return {
              value: await callback(result.value),
              done: false
            };
          } catch (error) {
            if (typeof iterator.return === "function") {
              try {
                await iterator.return();
              } catch (_e) {
              }
            }
            throw error;
          }
        }
        return {
          async next() {
            return mapResult(await iterator.next());
          },
          async return() {
            return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
              value: void 0,
              done: true
            };
          },
          async throw(error) {
            if (typeof iterator.throw === "function") {
              return mapResult(await iterator.throw(error));
            }
            throw error;
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    }
  });

  // node_modules/graphql/execution/subscribe.js
  var require_subscribe = __commonJS({
    "node_modules/graphql/execution/subscribe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSourceEventStream = createSourceEventStream;
      exports.subscribe = subscribe;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isAsyncIterable = require_isAsyncIterable();
      var _Path = require_Path();
      var _GraphQLError = require_GraphQLError();
      var _locatedError = require_locatedError();
      var _collectFields = require_collectFields();
      var _execute = require_execute();
      var _mapAsyncIterator = require_mapAsyncIterator();
      var _values = require_values();
      async function subscribe(args) {
        arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
        const resultOrStream = await createSourceEventStream(args);
        if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
          return resultOrStream;
        }
        const mapSourceToResponse = (payload) => (0, _execute.execute)({ ...args, rootValue: payload });
        return (0, _mapAsyncIterator.mapAsyncIterator)(resultOrStream, mapSourceToResponse);
      }
      function toNormalizedArgs(args) {
        const firstArg = args[0];
        if (firstArg && "document" in firstArg) {
          return firstArg;
        }
        return {
          schema: firstArg,
          document: args[1],
          rootValue: args[2],
          contextValue: args[3],
          variableValues: args[4],
          operationName: args[5],
          subscribeFieldResolver: args[6]
        };
      }
      async function createSourceEventStream(...rawArgs) {
        const args = toNormalizedArgs(rawArgs);
        const { schema, document: document2, variableValues } = args;
        (0, _execute.assertValidExecutionArguments)(schema, document2, variableValues);
        const exeContext = (0, _execute.buildExecutionContext)(args);
        if (!("schema" in exeContext)) {
          return {
            errors: exeContext
          };
        }
        try {
          const eventStream = await executeSubscription(exeContext);
          if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
            throw new Error(`Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`);
          }
          return eventStream;
        } catch (error) {
          if (error instanceof _GraphQLError.GraphQLError) {
            return {
              errors: [error]
            };
          }
          throw error;
        }
      }
      async function executeSubscription(exeContext) {
        const { schema, fragments, operation, variableValues, rootValue } = exeContext;
        const rootType = schema.getSubscriptionType();
        if (rootType == null) {
          throw new _GraphQLError.GraphQLError("Schema is not configured to execute subscription operation.", {
            nodes: operation
          });
        }
        const rootFields = (0, _collectFields.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
        const [responseName, fieldNodes] = [...rootFields.entries()][0];
        const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
        if (!fieldDef) {
          const fieldName = fieldNodes[0].name.value;
          throw new _GraphQLError.GraphQLError(`The subscription field "${fieldName}" is not defined.`, {
            nodes: fieldNodes
          });
        }
        const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
        const info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, rootType, path);
        try {
          var _fieldDef$subscribe;
          const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
          const contextValue = exeContext.contextValue;
          const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
          const eventStream = await resolveFn(rootValue, args, contextValue, info);
          if (eventStream instanceof Error) {
            throw eventStream;
          }
          return eventStream;
        } catch (error) {
          throw (0, _locatedError.locatedError)(error, fieldNodes, (0, _Path.pathToArray)(path));
        }
      }
    }
  });

  // node_modules/graphql/execution/index.js
  var require_execution = __commonJS({
    "node_modules/graphql/execution/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _subscribe.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _execute.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _execute.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _execute.executeSync;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _values.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _values.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _values.getVariableValues;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _Path.pathToArray;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _subscribe.subscribe;
        }
      });
      var _Path = require_Path();
      var _execute = require_execute();
      var _subscribe = require_subscribe();
      var _values = require_values();
    }
  });

  // node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
  var require_NoDeprecatedCustomRule = __commonJS({
    "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function NoDeprecatedCustomRule(context) {
        return {
          Field(node) {
            const fieldDef = context.getFieldDef();
            const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
            if (fieldDef && deprecationReason != null) {
              const parentType = context.getParentType();
              parentType != null || (0, _invariant.invariant)(false);
              context.reportError(new _GraphQLError.GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, {
                nodes: node
              }));
            }
          },
          Argument(node) {
            const argDef = context.getArgument();
            const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
            if (argDef && deprecationReason != null) {
              const directiveDef = context.getDirective();
              if (directiveDef != null) {
                context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                  nodes: node
                }));
              } else {
                const parentType = context.getParentType();
                const fieldDef = context.getFieldDef();
                parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                  nodes: node
                }));
              }
            }
          },
          ObjectField(node) {
            const inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
            if ((0, _definition.isInputObjectType)(inputObjectDef)) {
              const inputFieldDef = inputObjectDef.getFields()[node.name.value];
              const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
              if (deprecationReason != null) {
                context.reportError(new _GraphQLError.GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, {
                  nodes: node
                }));
              }
            }
          },
          EnumValue(node) {
            const enumValueDef = context.getEnumValue();
            const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
            if (enumValueDef && deprecationReason != null) {
              const enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
              enumTypeDef != null || (0, _invariant.invariant)(false);
              context.reportError(new _GraphQLError.GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, {
                nodes: node
              }));
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
  var require_NoSchemaIntrospectionCustomRule = __commonJS({
    "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _introspection = require_introspection();
      function NoSchemaIntrospectionCustomRule(context) {
        return {
          Field(node) {
            const type = (0, _definition.getNamedType)(context.getType());
            if (type && (0, _introspection.isIntrospectionType)(type)) {
              context.reportError(new _GraphQLError.GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`, {
                nodes: node
              }));
            }
          }
        };
      }
    }
  });

  // node_modules/graphql/validation/index.js
  var require_validation = __commonJS({
    "node_modules/graphql/validation/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownArgumentNamesRule.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _KnownDirectivesRule.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownFragmentNamesRule.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _KnownTypeNamesRule.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _NoFragmentCyclesRule.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _NoUnusedVariablesRule.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _ScalarLeafsRule.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationNamesRule.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _UniqueOperationTypesRule.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueTypeNamesRule.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _UniqueVariableNamesRule.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _ValidationContext.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _specifiedRules.specifiedRules;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _validate.validate;
        }
      });
      var _validate = require_validate2();
      var _ValidationContext = require_ValidationContext();
      var _specifiedRules = require_specifiedRules();
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
      var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
    }
  });

  // node_modules/graphql/error/index.js
  var require_error = __commonJS({
    "node_modules/graphql/error/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.GraphQLError;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.formatError;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _locatedError.locatedError;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _GraphQLError.printError;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _syntaxError.syntaxError;
        }
      });
      var _GraphQLError = require_GraphQLError();
      var _syntaxError = require_syntaxError();
      var _locatedError = require_locatedError();
    }
  });

  // node_modules/graphql/utilities/getIntrospectionQuery.js
  var require_getIntrospectionQuery = __commonJS({
    "node_modules/graphql/utilities/getIntrospectionQuery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getIntrospectionQuery = getIntrospectionQuery;
      function getIntrospectionQuery(options) {
        const optionsWithDefault = {
          descriptions: true,
          specifiedByUrl: false,
          directiveIsRepeatable: false,
          schemaDescription: false,
          inputValueDeprecation: false,
          ...options
        };
        const descriptions = optionsWithDefault.descriptions ? "description" : "";
        const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
        const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
        const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
        function inputDeprecation(str) {
          return optionsWithDefault.inputValueDeprecation ? str : "";
        }
        return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
      }
    }
  });

  // node_modules/graphql/utilities/getOperationAST.js
  var require_getOperationAST = __commonJS({
    "node_modules/graphql/utilities/getOperationAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationAST = getOperationAST;
      var _kinds = require_kinds();
      function getOperationAST(documentAST, operationName) {
        let operation = null;
        for (const definition of documentAST.definitions) {
          if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
            var _definition$name;
            if (operationName == null) {
              if (operation) {
                return null;
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              return definition;
            }
          }
        }
        return operation;
      }
    }
  });

  // node_modules/graphql/utilities/getOperationRootType.js
  var require_getOperationRootType = __commonJS({
    "node_modules/graphql/utilities/getOperationRootType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getOperationRootType = getOperationRootType;
      var _GraphQLError = require_GraphQLError();
      function getOperationRootType(schema, operation) {
        if (operation.operation === "query") {
          const queryType = schema.getQueryType();
          if (!queryType) {
            throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", {
              nodes: operation
            });
          }
          return queryType;
        }
        if (operation.operation === "mutation") {
          const mutationType = schema.getMutationType();
          if (!mutationType) {
            throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", {
              nodes: operation
            });
          }
          return mutationType;
        }
        if (operation.operation === "subscription") {
          const subscriptionType = schema.getSubscriptionType();
          if (!subscriptionType) {
            throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", {
              nodes: operation
            });
          }
          return subscriptionType;
        }
        throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", {
          nodes: operation
        });
      }
    }
  });

  // node_modules/graphql/utilities/introspectionFromSchema.js
  var require_introspectionFromSchema = __commonJS({
    "node_modules/graphql/utilities/introspectionFromSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.introspectionFromSchema = introspectionFromSchema;
      var _invariant = require_invariant();
      var _parser = require_parser();
      var _execute = require_execute();
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      function introspectionFromSchema(schema, options) {
        const optionsWithDefaults = {
          specifiedByUrl: true,
          directiveIsRepeatable: true,
          schemaDescription: true,
          inputValueDeprecation: true,
          ...options
        };
        const document2 = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
        const result = (0, _execute.executeSync)({
          schema,
          document: document2
        });
        !result.errors && result.data || (0, _invariant.invariant)(false);
        return result.data;
      }
    }
  });

  // node_modules/graphql/utilities/buildClientSchema.js
  var require_buildClientSchema = __commonJS({
    "node_modules/graphql/utilities/buildClientSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildClientSchema = buildClientSchema;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _keyValMap = require_keyValMap();
      var _parser = require_parser();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _valueFromAST = require_valueFromAST();
      function buildClientSchema(introspection, options) {
        (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`);
        const schemaIntrospection = introspection.__schema;
        const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, (typeIntrospection) => typeIntrospection.name, (typeIntrospection) => buildType(typeIntrospection));
        for (const stdType of [
          ..._scalars.specifiedScalarTypes,
          ..._introspection.introspectionTypes
        ]) {
          if (typeMap[stdType.name]) {
            typeMap[stdType.name] = stdType;
          }
        }
        const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
        const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
        const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
        const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
        return new _schema.GraphQLSchema({
          description: schemaIntrospection.description,
          query: queryType,
          mutation: mutationType,
          subscription: subscriptionType,
          types: Object.values(typeMap),
          directives,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
        function getType(typeRef) {
          if (typeRef.kind === _introspection.TypeKind.LIST) {
            const itemRef = typeRef.ofType;
            if (!itemRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            return new _definition.GraphQLList(getType(itemRef));
          }
          if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
            const nullableRef = typeRef.ofType;
            if (!nullableRef) {
              throw new Error("Decorated type deeper than introspection query.");
            }
            const nullableType = getType(nullableRef);
            return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
          }
          return getNamedType(typeRef);
        }
        function getNamedType(typeRef) {
          const typeName = typeRef.name;
          if (!typeName) {
            throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);
          }
          const type = typeMap[typeName];
          if (!type) {
            throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
          }
          return type;
        }
        function getObjectType(typeRef) {
          return (0, _definition.assertObjectType)(getNamedType(typeRef));
        }
        function getInterfaceType(typeRef) {
          return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
        }
        function buildType(type) {
          if (type != null && type.name != null && type.kind != null) {
            switch (type.kind) {
              case _introspection.TypeKind.SCALAR:
                return buildScalarDef(type);
              case _introspection.TypeKind.OBJECT:
                return buildObjectDef(type);
              case _introspection.TypeKind.INTERFACE:
                return buildInterfaceDef(type);
              case _introspection.TypeKind.UNION:
                return buildUnionDef(type);
              case _introspection.TypeKind.ENUM:
                return buildEnumDef(type);
              case _introspection.TypeKind.INPUT_OBJECT:
                return buildInputObjectDef(type);
            }
          }
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
        }
        function buildScalarDef(scalarIntrospection) {
          return new _definition.GraphQLScalarType({
            name: scalarIntrospection.name,
            description: scalarIntrospection.description,
            specifiedByURL: scalarIntrospection.specifiedByURL
          });
        }
        function buildImplementationsList(implementingIntrospection) {
          if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
            return [];
          }
          if (!implementingIntrospection.interfaces) {
            const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);
            throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
          }
          return implementingIntrospection.interfaces.map(getInterfaceType);
        }
        function buildObjectDef(objectIntrospection) {
          return new _definition.GraphQLObjectType({
            name: objectIntrospection.name,
            description: objectIntrospection.description,
            interfaces: () => buildImplementationsList(objectIntrospection),
            fields: () => buildFieldDefMap(objectIntrospection)
          });
        }
        function buildInterfaceDef(interfaceIntrospection) {
          return new _definition.GraphQLInterfaceType({
            name: interfaceIntrospection.name,
            description: interfaceIntrospection.description,
            interfaces: () => buildImplementationsList(interfaceIntrospection),
            fields: () => buildFieldDefMap(interfaceIntrospection)
          });
        }
        function buildUnionDef(unionIntrospection) {
          if (!unionIntrospection.possibleTypes) {
            const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
            throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
          }
          return new _definition.GraphQLUnionType({
            name: unionIntrospection.name,
            description: unionIntrospection.description,
            types: () => unionIntrospection.possibleTypes.map(getObjectType)
          });
        }
        function buildEnumDef(enumIntrospection) {
          if (!enumIntrospection.enumValues) {
            const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
            throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
          }
          return new _definition.GraphQLEnumType({
            name: enumIntrospection.name,
            description: enumIntrospection.description,
            values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, (valueIntrospection) => valueIntrospection.name, (valueIntrospection) => ({
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            }))
          });
        }
        function buildInputObjectDef(inputObjectIntrospection) {
          if (!inputObjectIntrospection.inputFields) {
            const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);
            throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
          }
          return new _definition.GraphQLInputObjectType({
            name: inputObjectIntrospection.name,
            description: inputObjectIntrospection.description,
            fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
          });
        }
        function buildFieldDefMap(typeIntrospection) {
          if (!typeIntrospection.fields) {
            throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);
          }
          return (0, _keyValMap.keyValMap)(typeIntrospection.fields, (fieldIntrospection) => fieldIntrospection.name, buildField);
        }
        function buildField(fieldIntrospection) {
          const type = getType(fieldIntrospection.type);
          if (!(0, _definition.isOutputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
          }
          if (!fieldIntrospection.args) {
            const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
            throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
          }
          return {
            description: fieldIntrospection.description,
            deprecationReason: fieldIntrospection.deprecationReason,
            type,
            args: buildInputValueDefMap(fieldIntrospection.args)
          };
        }
        function buildInputValueDefMap(inputValueIntrospections) {
          return (0, _keyValMap.keyValMap)(inputValueIntrospections, (inputValue) => inputValue.name, buildInputValue);
        }
        function buildInputValue(inputValueIntrospection) {
          const type = getType(inputValueIntrospection.type);
          if (!(0, _definition.isInputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
          }
          const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : void 0;
          return {
            description: inputValueIntrospection.description,
            type,
            defaultValue,
            deprecationReason: inputValueIntrospection.deprecationReason
          };
        }
        function buildDirective(directiveIntrospection) {
          if (!directiveIntrospection.args) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
            throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
          }
          if (!directiveIntrospection.locations) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
            throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
          }
          return new _directives.GraphQLDirective({
            name: directiveIntrospection.name,
            description: directiveIntrospection.description,
            isRepeatable: directiveIntrospection.isRepeatable,
            locations: directiveIntrospection.locations.slice(),
            args: buildInputValueDefMap(directiveIntrospection.args)
          });
        }
      }
    }
  });

  // node_modules/graphql/utilities/extendSchema.js
  var require_extendSchema = __commonJS({
    "node_modules/graphql/utilities/extendSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.extendSchema = extendSchema;
      exports.extendSchemaImpl = extendSchemaImpl;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _mapValue = require_mapValue();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _values = require_values();
      var _valueFromAST = require_valueFromAST();
      function extendSchema(schema, documentAST, options) {
        (0, _schema.assertSchema)(schema);
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDLExtension)(documentAST, schema);
        }
        const schemaConfig = schema.toConfig();
        const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
        return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
      }
      function extendSchemaImpl(schemaConfig, documentAST, options) {
        var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
        const typeDefs = [];
        const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
        const directiveDefs = [];
        let schemaDef;
        const schemaExtensions = [];
        for (const def of documentAST.definitions) {
          if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
            schemaDef = def;
          } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(def);
          } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
            typeDefs.push(def);
          } else if ((0, _predicates.isTypeExtensionNode)(def)) {
            const extendedTypeName = def.name.value;
            const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
            typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
          } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            directiveDefs.push(def);
          }
        }
        if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
          return schemaConfig;
        }
        const typeMap = /* @__PURE__ */ Object.create(null);
        for (const existingType of schemaConfig.types) {
          typeMap[existingType.name] = extendNamedType(existingType);
        }
        for (const typeNode of typeDefs) {
          var _stdTypeMap$name;
          const name = typeNode.name.value;
          typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
        }
        const operationTypes = {
          query: schemaConfig.query && replaceNamedType(schemaConfig.query),
          mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
          subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
          ...schemaDef && getOperationTypes([schemaDef]),
          ...getOperationTypes(schemaExtensions)
        };
        return {
          description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
          ...operationTypes,
          types: Object.values(typeMap),
          directives: [
            ...schemaConfig.directives.map(replaceDirective),
            ...directiveDefs.map(buildDirective)
          ],
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
          extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
          assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
        };
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          }
          if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            args: (0, _mapValue.mapValue)(config.args, extendArg)
          });
        }
        function extendNamedType(type) {
          if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
            return type;
          }
          if ((0, _definition.isScalarType)(type)) {
            return extendScalarType(type);
          }
          if ((0, _definition.isObjectType)(type)) {
            return extendObjectType(type);
          }
          if ((0, _definition.isInterfaceType)(type)) {
            return extendInterfaceType(type);
          }
          if ((0, _definition.isUnionType)(type)) {
            return extendUnionType(type);
          }
          if ((0, _definition.isEnumType)(type)) {
            return extendEnumType(type);
          }
          if ((0, _definition.isInputObjectType)(type)) {
            return extendInputObjectType(type);
          }
          (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
        }
        function extendInputObjectType(type) {
          var _typeExtensionsMap$co;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
          return new _definition.GraphQLInputObjectType({
            ...config,
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, (field) => ({
                ...field,
                type: replaceType(field.type)
              })),
              ...buildInputFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendEnumType(type) {
          var _typeExtensionsMap$ty;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
          return new _definition.GraphQLEnumType({
            ...config,
            values: { ...config.values, ...buildEnumValueMap(extensions) },
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendScalarType(type) {
          var _typeExtensionsMap$co2;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
          let specifiedByURL = config.specifiedByURL;
          for (const extensionNode of extensions) {
            var _getSpecifiedByURL;
            specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
          }
          return new _definition.GraphQLScalarType({
            ...config,
            specifiedByURL,
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendObjectType(type) {
          var _typeExtensionsMap$co3;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
          return new _definition.GraphQLObjectType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendInterfaceType(type) {
          var _typeExtensionsMap$co4;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
          return new _definition.GraphQLInterfaceType({
            ...config,
            interfaces: () => [
              ...type.getInterfaces().map(replaceNamedType),
              ...buildInterfaces(extensions)
            ],
            fields: () => ({
              ...(0, _mapValue.mapValue)(config.fields, extendField),
              ...buildFieldMap(extensions)
            }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendUnionType(type) {
          var _typeExtensionsMap$co5;
          const config = type.toConfig();
          const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
          return new _definition.GraphQLUnionType({
            ...config,
            types: () => [
              ...type.getTypes().map(replaceNamedType),
              ...buildUnionTypes(extensions)
            ],
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
          });
        }
        function extendField(field) {
          return {
            ...field,
            type: replaceType(field.type),
            args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
          };
        }
        function extendArg(arg) {
          return { ...arg, type: replaceType(arg.type) };
        }
        function getOperationTypes(nodes) {
          const opTypes = {};
          for (const node of nodes) {
            var _node$operationTypes;
            const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
            for (const operationType of operationTypesNodes) {
              opTypes[operationType.operation] = getNamedType(operationType.type);
            }
          }
          return opTypes;
        }
        function getNamedType(node) {
          var _stdTypeMap$name2;
          const name = node.name.value;
          const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
          if (type === void 0) {
            throw new Error(`Unknown type: "${name}".`);
          }
          return type;
        }
        function getWrappedType(node) {
          if (node.kind === _kinds.Kind.LIST_TYPE) {
            return new _definition.GraphQLList(getWrappedType(node.type));
          }
          if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
            return new _definition.GraphQLNonNull(getWrappedType(node.type));
          }
          return getNamedType(node);
        }
        function buildDirective(node) {
          var _node$description;
          return new _directives.GraphQLDirective({
            name: node.name.value,
            description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
            locations: node.locations.map(({ value }) => value),
            isRepeatable: node.repeatable,
            args: buildArgumentMap(node.arguments),
            astNode: node
          });
        }
        function buildFieldMap(nodes) {
          const fieldConfigMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields;
            const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
            for (const field of nodeFields) {
              var _field$description;
              fieldConfigMap[field.name.value] = {
                type: getWrappedType(field.type),
                description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
                args: buildArgumentMap(field.arguments),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return fieldConfigMap;
        }
        function buildArgumentMap(args) {
          const argsNodes = args !== null && args !== void 0 ? args : [];
          const argConfigMap = /* @__PURE__ */ Object.create(null);
          for (const arg of argsNodes) {
            var _arg$description;
            const type = getWrappedType(arg.type);
            argConfigMap[arg.name.value] = {
              type,
              description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
              deprecationReason: getDeprecationReason(arg),
              astNode: arg
            };
          }
          return argConfigMap;
        }
        function buildInputFieldMap(nodes) {
          const inputFieldMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$fields2;
            const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
            for (const field of fieldsNodes) {
              var _field$description2;
              const type = getWrappedType(field.type);
              inputFieldMap[field.name.value] = {
                type,
                description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
                defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
                deprecationReason: getDeprecationReason(field),
                astNode: field
              };
            }
          }
          return inputFieldMap;
        }
        function buildEnumValueMap(nodes) {
          const enumValueMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            var _node$values;
            const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
            for (const value of valuesNodes) {
              var _value$description;
              enumValueMap[value.name.value] = {
                description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
                deprecationReason: getDeprecationReason(value),
                astNode: value
              };
            }
          }
          return enumValueMap;
        }
        function buildInterfaces(nodes) {
          return nodes.flatMap((node) => {
            var _node$interfaces$map, _node$interfaces;
            return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];
          });
        }
        function buildUnionTypes(nodes) {
          return nodes.flatMap((node) => {
            var _node$types$map, _node$types;
            return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : [];
          });
        }
        function buildType(astNode) {
          var _typeExtensionsMap$na;
          const name = astNode.name.value;
          const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
          switch (astNode.kind) {
            case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
              var _astNode$description;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLObjectType({
                name,
                description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
              var _astNode$description2;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInterfaceType({
                name,
                description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.ENUM_TYPE_DEFINITION: {
              var _astNode$description3;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLEnumType({
                name,
                description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
                values: buildEnumValueMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.UNION_TYPE_DEFINITION: {
              var _astNode$description4;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLUnionType({
                name,
                description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
                types: () => buildUnionTypes(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
              var _astNode$description5;
              return new _definition.GraphQLScalarType({
                name,
                description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
                specifiedByURL: getSpecifiedByURL(astNode),
                astNode,
                extensionASTNodes
              });
            }
            case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
              var _astNode$description6;
              const allNodes = [astNode, ...extensionASTNodes];
              return new _definition.GraphQLInputObjectType({
                name,
                description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
                fields: () => buildInputFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
          }
        }
      }
      var stdTypeMap = (0, _keyMap.keyMap)([..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes], (type) => type.name);
      function getDeprecationReason(node) {
        const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
        return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
      }
      function getSpecifiedByURL(node) {
        const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);
        return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
      }
    }
  });

  // node_modules/graphql/utilities/buildASTSchema.js
  var require_buildASTSchema = __commonJS({
    "node_modules/graphql/utilities/buildASTSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.buildASTSchema = buildASTSchema;
      exports.buildSchema = buildSchema;
      var _devAssert = require_devAssert();
      var _kinds = require_kinds();
      var _parser = require_parser();
      var _directives = require_directives();
      var _schema = require_schema();
      var _validate = require_validate2();
      var _extendSchema = require_extendSchema();
      function buildASTSchema(documentAST, options) {
        documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
          (0, _validate.assertValidSDL)(documentAST);
        }
        const emptySchemaConfig = {
          description: void 0,
          types: [],
          directives: [],
          extensions: /* @__PURE__ */ Object.create(null),
          extensionASTNodes: [],
          assumeValid: false
        };
        const config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
        if (config.astNode == null) {
          for (const type of config.types) {
            switch (type.name) {
              case "Query":
                config.query = type;
                break;
              case "Mutation":
                config.mutation = type;
                break;
              case "Subscription":
                config.subscription = type;
                break;
            }
          }
        }
        const directives = [
          ...config.directives,
          ..._directives.specifiedDirectives.filter((stdDirective) => config.directives.every((directive) => directive.name !== stdDirective.name))
        ];
        return new _schema.GraphQLSchema({ ...config, directives });
      }
      function buildSchema(source, options) {
        const document2 = (0, _parser.parse)(source, {
          noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
          allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
        });
        return buildASTSchema(document2, {
          assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
          assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
      }
    }
  });

  // node_modules/graphql/utilities/lexicographicSortSchema.js
  var require_lexicographicSortSchema = __commonJS({
    "node_modules/graphql/utilities/lexicographicSortSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lexicographicSortSchema = lexicographicSortSchema;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyValMap = require_keyValMap();
      var _naturalCompare = require_naturalCompare();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function lexicographicSortSchema(schema) {
        const schemaConfig = schema.toConfig();
        const typeMap = (0, _keyValMap.keyValMap)(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
        return new _schema.GraphQLSchema({
          ...schemaConfig,
          types: Object.values(typeMap),
          directives: sortByName(schemaConfig.directives).map(sortDirective),
          query: replaceMaybeType(schemaConfig.query),
          mutation: replaceMaybeType(schemaConfig.mutation),
          subscription: replaceMaybeType(schemaConfig.subscription)
        });
        function replaceType(type) {
          if ((0, _definition.isListType)(type)) {
            return new _definition.GraphQLList(replaceType(type.ofType));
          } else if ((0, _definition.isNonNullType)(type)) {
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap[type.name];
        }
        function replaceMaybeType(maybeType) {
          return maybeType && replaceNamedType(maybeType);
        }
        function sortDirective(directive) {
          const config = directive.toConfig();
          return new _directives.GraphQLDirective({
            ...config,
            locations: sortBy(config.locations, (x) => x),
            args: sortArgs(config.args)
          });
        }
        function sortArgs(args) {
          return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
        }
        function sortFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type),
            args: field.args && sortArgs(field.args)
          }));
        }
        function sortInputFields(fieldsMap) {
          return sortObjMap(fieldsMap, (field) => ({
            ...field,
            type: replaceType(field.type)
          }));
        }
        function sortTypes(array) {
          return sortByName(array).map(replaceNamedType);
        }
        function sortNamedType(type) {
          if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
            return type;
          }
          if ((0, _definition.isObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLObjectType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isInterfaceType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInterfaceType({
              ...config,
              interfaces: () => sortTypes(config.interfaces),
              fields: () => sortFields(config.fields)
            });
          }
          if ((0, _definition.isUnionType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLUnionType({
              ...config,
              types: () => sortTypes(config.types)
            });
          }
          if ((0, _definition.isEnumType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLEnumType({
              ...config,
              values: sortObjMap(config.values, (value) => value)
            });
          }
          if ((0, _definition.isInputObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInputObjectType({
              ...config,
              fields: () => sortInputFields(config.fields)
            });
          }
          (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
        }
      }
      function sortObjMap(map, sortValueFn) {
        const sortedMap = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
          sortedMap[key] = sortValueFn(map[key]);
        }
        return sortedMap;
      }
      function sortByName(array) {
        return sortBy(array, (obj) => obj.name);
      }
      function sortBy(array, mapToKey) {
        return array.slice().sort((obj1, obj2) => {
          const key1 = mapToKey(obj1);
          const key2 = mapToKey(obj2);
          return (0, _naturalCompare.naturalCompare)(key1, key2);
        });
      }
    }
  });

  // node_modules/graphql/utilities/printSchema.js
  var require_printSchema = __commonJS({
    "node_modules/graphql/utilities/printSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printIntrospectionSchema = printIntrospectionSchema;
      exports.printSchema = printSchema;
      exports.printType = printType;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _blockString = require_blockString();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      function printSchema(schema) {
        return printFilteredSchema(schema, (n) => !(0, _directives.isSpecifiedDirective)(n), isDefinedType);
      }
      function printIntrospectionSchema(schema) {
        return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType);
      }
      function isDefinedType(type) {
        return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
      }
      function printFilteredSchema(schema, directiveFilter, typeFilter) {
        const directives = schema.getDirectives().filter(directiveFilter);
        const types = Object.values(schema.getTypeMap()).filter(typeFilter);
        return [
          printSchemaDefinition(schema),
          ...directives.map((directive) => printDirective(directive)),
          ...types.map((type) => printType(type))
        ].filter(Boolean).join("\n\n");
      }
      function printSchemaDefinition(schema) {
        if (schema.description == null && isSchemaOfCommonNames(schema)) {
          return;
        }
        const operationTypes = [];
        const queryType = schema.getQueryType();
        if (queryType) {
          operationTypes.push(`  query: ${queryType.name}`);
        }
        const mutationType = schema.getMutationType();
        if (mutationType) {
          operationTypes.push(`  mutation: ${mutationType.name}`);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          operationTypes.push(`  subscription: ${subscriptionType.name}`);
        }
        return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
      }
      function isSchemaOfCommonNames(schema) {
        const queryType = schema.getQueryType();
        if (queryType && queryType.name !== "Query") {
          return false;
        }
        const mutationType = schema.getMutationType();
        if (mutationType && mutationType.name !== "Mutation") {
          return false;
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && subscriptionType.name !== "Subscription") {
          return false;
        }
        return true;
      }
      function printType(type) {
        if ((0, _definition.isScalarType)(type)) {
          return printScalar(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return printObject(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return printInterface(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return printUnion(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return printEnum(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return printInputObject(type);
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
      function printScalar(type) {
        return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
      }
      function printImplementedInterfaces(type) {
        const interfaces = type.getInterfaces();
        return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
      }
      function printObject(type) {
        return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printInterface(type) {
        return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
      }
      function printUnion(type) {
        const types = type.getTypes();
        const possibleTypes = types.length ? " = " + types.join(" | ") : "";
        return printDescription(type) + "union " + type.name + possibleTypes;
      }
      function printEnum(type) {
        const values = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
        return printDescription(type) + `enum ${type.name}` + printBlock(values);
      }
      function printInputObject(type) {
        const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
        return printDescription(type) + `input ${type.name}` + printBlock(fields);
      }
      function printFields(type) {
        const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
        return printBlock(fields);
      }
      function printBlock(items) {
        return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
      }
      function printArgs(args, indentation = "") {
        if (args.length === 0) {
          return "";
        }
        if (args.every((arg) => !arg.description)) {
          return "(" + args.map(printInputValue).join(", ") + ")";
        }
        return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
      }
      function printInputValue(arg) {
        const defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
        let argDecl = arg.name + ": " + String(arg.type);
        if (defaultAST) {
          argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
        }
        return argDecl + printDeprecated(arg.deprecationReason);
      }
      function printDirective(directive) {
        return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
      }
      function printDeprecated(reason) {
        if (reason == null) {
          return "";
        }
        if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
          const astValue = (0, _printer.print)({
            kind: _kinds.Kind.STRING,
            value: reason
          });
          return ` @deprecated(reason: ${astValue})`;
        }
        return " @deprecated";
      }
      function printSpecifiedByURL(scalar) {
        if (scalar.specifiedByURL == null) {
          return "";
        }
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: scalar.specifiedByURL
        });
        return ` @specifiedBy(url: ${astValue})`;
      }
      function printDescription(def, indentation = "", firstInBlock = true) {
        const { description } = def;
        if (description == null) {
          return "";
        }
        const blockString = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: description,
          block: (0, _blockString.isPrintableAsBlockString)(description)
        });
        const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
        return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
      }
    }
  });

  // node_modules/graphql/utilities/concatAST.js
  var require_concatAST = __commonJS({
    "node_modules/graphql/utilities/concatAST.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.concatAST = concatAST;
      var _kinds = require_kinds();
      function concatAST(documents) {
        const definitions = [];
        for (const doc of documents) {
          definitions.push(...doc.definitions);
        }
        return {
          kind: _kinds.Kind.DOCUMENT,
          definitions
        };
      }
    }
  });

  // node_modules/graphql/utilities/separateOperations.js
  var require_separateOperations = __commonJS({
    "node_modules/graphql/utilities/separateOperations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.separateOperations = separateOperations;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      function separateOperations(documentAST) {
        const operations = [];
        const depGraph = /* @__PURE__ */ Object.create(null);
        for (const definitionNode of documentAST.definitions) {
          switch (definitionNode.kind) {
            case _kinds.Kind.OPERATION_DEFINITION:
              operations.push(definitionNode);
              break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
              depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
              break;
            default:
          }
        }
        const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
        for (const operation of operations) {
          const dependencies = /* @__PURE__ */ new Set();
          for (const fragmentName of collectDependencies(operation.selectionSet)) {
            collectTransitiveDependencies(dependencies, depGraph, fragmentName);
          }
          const operationName = operation.name ? operation.name.value : "";
          separatedDocumentASTs[operationName] = {
            kind: _kinds.Kind.DOCUMENT,
            definitions: documentAST.definitions.filter((node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))
          };
        }
        return separatedDocumentASTs;
      }
      function collectTransitiveDependencies(collected, depGraph, fromName) {
        if (!collected.has(fromName)) {
          collected.add(fromName);
          const immediateDeps = depGraph[fromName];
          if (immediateDeps !== void 0) {
            for (const toName of immediateDeps) {
              collectTransitiveDependencies(collected, depGraph, toName);
            }
          }
        }
      }
      function collectDependencies(selectionSet) {
        const dependencies = [];
        (0, _visitor.visit)(selectionSet, {
          FragmentSpread(node) {
            dependencies.push(node.name.value);
          }
        });
        return dependencies;
      }
    }
  });

  // node_modules/graphql/utilities/stripIgnoredCharacters.js
  var require_stripIgnoredCharacters = __commonJS({
    "node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stripIgnoredCharacters = stripIgnoredCharacters;
      var _blockString = require_blockString();
      var _lexer = require_lexer();
      var _source = require_source();
      var _tokenKind = require_tokenKind();
      function stripIgnoredCharacters(source) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        const body = sourceObj.body;
        const lexer = new _lexer.Lexer(sourceObj);
        let strippedBody = "";
        let wasLastAddedTokenNonPunctuator = false;
        while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
          const currentToken = lexer.token;
          const tokenKind = currentToken.kind;
          const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
          if (wasLastAddedTokenNonPunctuator) {
            if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
              strippedBody += " ";
            }
          }
          const tokenBody = body.slice(currentToken.start, currentToken.end);
          if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
            strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
              minimize: true
            });
          } else {
            strippedBody += tokenBody;
          }
          wasLastAddedTokenNonPunctuator = isNonPunctuator;
        }
        return strippedBody;
      }
    }
  });

  // node_modules/graphql/utilities/assertValidName.js
  var require_assertValidName = __commonJS({
    "node_modules/graphql/utilities/assertValidName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertValidName = assertValidName;
      exports.isValidNameError = isValidNameError;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _assertName = require_assertName();
      function assertValidName(name) {
        const error = isValidNameError(name);
        if (error) {
          throw error;
        }
        return name;
      }
      function isValidNameError(name) {
        typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name.startsWith("__")) {
          return new _GraphQLError.GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
        }
        try {
          (0, _assertName.assertName)(name);
        } catch (error) {
          return error;
        }
      }
    }
  });

  // node_modules/graphql/utilities/findBreakingChanges.js
  var require_findBreakingChanges = __commonJS({
    "node_modules/graphql/utilities/findBreakingChanges.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DangerousChangeType = exports.BreakingChangeType = void 0;
      exports.findBreakingChanges = findBreakingChanges;
      exports.findDangerousChanges = findDangerousChanges;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _printer = require_printer();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var _astFromValue = require_astFromValue();
      var _sortValueNode = require_sortValueNode();
      var BreakingChangeType;
      exports.BreakingChangeType = BreakingChangeType;
      (function(BreakingChangeType2) {
        BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
        BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
        BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
        BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
        BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
        BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
        BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
        BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
        BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
        BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
        BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
        BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
        BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
        BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
        BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
        BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
      })(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));
      var DangerousChangeType;
      exports.DangerousChangeType = DangerousChangeType;
      (function(DangerousChangeType2) {
        DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
        DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
        DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
        DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
        DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
        DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
      })(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));
      function findBreakingChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in BreakingChangeType);
      }
      function findDangerousChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in DangerousChangeType);
      }
      function findSchemaChanges(oldSchema, newSchema) {
        return [
          ...findTypeChanges(oldSchema, newSchema),
          ...findDirectiveChanges(oldSchema, newSchema)
        ];
      }
      function findDirectiveChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
        for (const oldDirective of directivesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REMOVED,
            description: `${oldDirective.name} was removed.`
          });
        }
        for (const [oldDirective, newDirective] of directivesDiff.persisted) {
          const argsDiff = diff(oldDirective.args, newDirective.args);
          for (const newArg of argsDiff.added) {
            if ((0, _definition.isRequiredArgument)(newArg)) {
              schemaChanges.push({
                type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
                description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
              });
            }
          }
          for (const oldArg of argsDiff.removed) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
              description: `${oldArg.name} was removed from ${oldDirective.name}.`
            });
          }
          if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
              description: `Repeatable flag was removed from ${oldDirective.name}.`
            });
          }
          for (const location of oldDirective.locations) {
            if (!newDirective.locations.includes(location)) {
              schemaChanges.push({
                type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
                description: `${location} was removed from ${oldDirective.name}.`
              });
            }
          }
        }
        return schemaChanges;
      }
      function findTypeChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
        for (const oldType of typesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED,
            description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
          });
        }
        for (const [oldType, newType] of typesDiff.persisted) {
          if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
            schemaChanges.push(...findEnumTypeChanges(oldType, newType));
          } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
            schemaChanges.push(...findUnionTypeChanges(oldType, newType));
          } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
            schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
          } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
            schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
          } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
            schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
          } else if (oldType.constructor !== newType.constructor) {
            schemaChanges.push({
              type: BreakingChangeType.TYPE_CHANGED_KIND,
              description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findInputObjectTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
        for (const newField of fieldsDiff.added) {
          if ((0, _definition.isRequiredInputField)(newField)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
              description: `A required field ${newField.name} on input type ${oldType.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
              description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
            });
          }
        }
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findUnionTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
        for (const newPossibleType of possibleTypesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.TYPE_ADDED_TO_UNION,
            description: `${newPossibleType.name} was added to union type ${oldType.name}.`
          });
        }
        for (const oldPossibleType of possibleTypesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
            description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findEnumTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const valuesDiff = diff(oldType.getValues(), newType.getValues());
        for (const newValue of valuesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
            description: `${newValue.name} was added to enum type ${oldType.name}.`
          });
        }
        for (const oldValue of valuesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
            description: `${oldValue.name} was removed from enum type ${oldType.name}.`
          });
        }
        return schemaChanges;
      }
      function findImplementedInterfacesChanges(oldType, newType) {
        const schemaChanges = [];
        const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
        for (const newInterface of interfacesDiff.added) {
          schemaChanges.push({
            type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
            description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
          });
        }
        for (const oldInterface of interfacesDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
            description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
          });
        }
        return schemaChanges;
      }
      function findFieldChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
        for (const oldField of fieldsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
          });
        }
        for (const [oldField, newField] of fieldsDiff.persisted) {
          schemaChanges.push(...findArgChanges(oldType, oldField, newField));
          const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.FIELD_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
            });
          }
        }
        return schemaChanges;
      }
      function findArgChanges(oldType, oldField, newField) {
        const schemaChanges = [];
        const argsDiff = diff(oldField.args, newField.args);
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_REMOVED,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
          });
        }
        for (const [oldArg, newArg] of argsDiff.persisted) {
          const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
          if (!isSafe) {
            schemaChanges.push({
              type: BreakingChangeType.ARG_CHANGED_KIND,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
            });
          } else if (oldArg.defaultValue !== void 0) {
            if (newArg.defaultValue === void 0) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
              });
            } else {
              const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
              const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
              if (oldValueStr !== newValueStr) {
                schemaChanges.push({
                  type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                  description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
                });
              }
            }
          }
        }
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_ARG_ADDED,
              description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          } else {
            schemaChanges.push({
              type: DangerousChangeType.OPTIONAL_ARG_ADDED,
              description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
          }
        }
        return schemaChanges;
      }
      function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
        }
        return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
      }
      function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
        if ((0, _definition.isListType)(oldType)) {
          return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
        }
        if ((0, _definition.isNonNullType)(oldType)) {
          return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
        }
        return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
      }
      function typeKindName(type) {
        if ((0, _definition.isScalarType)(type)) {
          return "a Scalar type";
        }
        if ((0, _definition.isObjectType)(type)) {
          return "an Object type";
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return "an Interface type";
        }
        if ((0, _definition.isUnionType)(type)) {
          return "a Union type";
        }
        if ((0, _definition.isEnumType)(type)) {
          return "an Enum type";
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return "an Input type";
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
      function stringifyValue(value, type) {
        const ast = (0, _astFromValue.astFromValue)(value, type);
        ast != null || (0, _invariant.invariant)(false);
        return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
      }
      function diff(oldArray, newArray) {
        const added = [];
        const removed = [];
        const persisted = [];
        const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
        const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
        for (const oldItem of oldArray) {
          const newItem = newMap[oldItem.name];
          if (newItem === void 0) {
            removed.push(oldItem);
          } else {
            persisted.push([oldItem, newItem]);
          }
        }
        for (const newItem of newArray) {
          if (oldMap[newItem.name] === void 0) {
            added.push(newItem);
          }
        }
        return {
          added,
          persisted,
          removed
        };
      }
    }
  });

  // node_modules/graphql/utilities/index.js
  var require_utilities = __commonJS({
    "node_modules/graphql/utilities/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.TypeInfo;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _assertValidName.assertValidName;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _astFromValue.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _buildClientSchema.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _buildASTSchema.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _coerceInputValue.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _concatAST.concatAST;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _typeComparators.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _extendSchema.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _findBreakingChanges.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _getIntrospectionQuery.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _getOperationAST.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _getOperationRootType.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _introspectionFromSchema.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _typeComparators.isEqualType;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _typeComparators.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _assertValidName.isValidNameError;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _lexicographicSortSchema.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _printSchema.printSchema;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _printSchema.printType;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _separateOperations.separateOperations;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _stripIgnoredCharacters.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _typeFromAST.typeFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _valueFromAST.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _valueFromASTUntyped.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _TypeInfo.visitWithTypeInfo;
        }
      });
      var _getIntrospectionQuery = require_getIntrospectionQuery();
      var _getOperationAST = require_getOperationAST();
      var _getOperationRootType = require_getOperationRootType();
      var _introspectionFromSchema = require_introspectionFromSchema();
      var _buildClientSchema = require_buildClientSchema();
      var _buildASTSchema = require_buildASTSchema();
      var _extendSchema = require_extendSchema();
      var _lexicographicSortSchema = require_lexicographicSortSchema();
      var _printSchema = require_printSchema();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _astFromValue = require_astFromValue();
      var _TypeInfo = require_TypeInfo();
      var _coerceInputValue = require_coerceInputValue();
      var _concatAST = require_concatAST();
      var _separateOperations = require_separateOperations();
      var _stripIgnoredCharacters = require_stripIgnoredCharacters();
      var _typeComparators = require_typeComparators();
      var _assertValidName = require_assertValidName();
      var _findBreakingChanges = require_findBreakingChanges();
    }
  });

  // node_modules/graphql/index.js
  var require_graphql2 = __commonJS({
    "node_modules/graphql/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BREAK", {
        enumerable: true,
        get: function() {
          return _index2.BREAK;
        }
      });
      Object.defineProperty(exports, "BreakingChangeType", {
        enumerable: true,
        get: function() {
          return _index6.BreakingChangeType;
        }
      });
      Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
        enumerable: true,
        get: function() {
          return _index.DEFAULT_DEPRECATION_REASON;
        }
      });
      Object.defineProperty(exports, "DangerousChangeType", {
        enumerable: true,
        get: function() {
          return _index6.DangerousChangeType;
        }
      });
      Object.defineProperty(exports, "DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index2.DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "ExecutableDefinitionsRule", {
        enumerable: true,
        get: function() {
          return _index4.ExecutableDefinitionsRule;
        }
      });
      Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.FieldsOnCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.FragmentsOnCompositeTypesRule;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MAX_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MAX_INT;
        }
      });
      Object.defineProperty(exports, "GRAPHQL_MIN_INT", {
        enumerable: true,
        get: function() {
          return _index.GRAPHQL_MIN_INT;
        }
      });
      Object.defineProperty(exports, "GraphQLBoolean", {
        enumerable: true,
        get: function() {
          return _index.GraphQLBoolean;
        }
      });
      Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDeprecatedDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLEnumType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLEnumType;
        }
      });
      Object.defineProperty(exports, "GraphQLError", {
        enumerable: true,
        get: function() {
          return _index5.GraphQLError;
        }
      });
      Object.defineProperty(exports, "GraphQLFloat", {
        enumerable: true,
        get: function() {
          return _index.GraphQLFloat;
        }
      });
      Object.defineProperty(exports, "GraphQLID", {
        enumerable: true,
        get: function() {
          return _index.GraphQLID;
        }
      });
      Object.defineProperty(exports, "GraphQLIncludeDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLIncludeDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInputObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLInt", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInt;
        }
      });
      Object.defineProperty(exports, "GraphQLInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLInterfaceType;
        }
      });
      Object.defineProperty(exports, "GraphQLList", {
        enumerable: true,
        get: function() {
          return _index.GraphQLList;
        }
      });
      Object.defineProperty(exports, "GraphQLNonNull", {
        enumerable: true,
        get: function() {
          return _index.GraphQLNonNull;
        }
      });
      Object.defineProperty(exports, "GraphQLObjectType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLObjectType;
        }
      });
      Object.defineProperty(exports, "GraphQLScalarType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLScalarType;
        }
      });
      Object.defineProperty(exports, "GraphQLSchema", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSchema;
        }
      });
      Object.defineProperty(exports, "GraphQLSkipDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSkipDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
        enumerable: true,
        get: function() {
          return _index.GraphQLSpecifiedByDirective;
        }
      });
      Object.defineProperty(exports, "GraphQLString", {
        enumerable: true,
        get: function() {
          return _index.GraphQLString;
        }
      });
      Object.defineProperty(exports, "GraphQLUnionType", {
        enumerable: true,
        get: function() {
          return _index.GraphQLUnionType;
        }
      });
      Object.defineProperty(exports, "Kind", {
        enumerable: true,
        get: function() {
          return _index2.Kind;
        }
      });
      Object.defineProperty(exports, "KnownArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownDirectivesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownDirectivesRule;
        }
      });
      Object.defineProperty(exports, "KnownFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "KnownTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.KnownTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _index2.Lexer;
        }
      });
      Object.defineProperty(exports, "Location", {
        enumerable: true,
        get: function() {
          return _index2.Location;
        }
      });
      Object.defineProperty(exports, "LoneAnonymousOperationRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneAnonymousOperationRule;
        }
      });
      Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
        enumerable: true,
        get: function() {
          return _index4.LoneSchemaDefinitionRule;
        }
      });
      Object.defineProperty(exports, "NoDeprecatedCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoDeprecatedCustomRule;
        }
      });
      Object.defineProperty(exports, "NoFragmentCyclesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoFragmentCyclesRule;
        }
      });
      Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
        enumerable: true,
        get: function() {
          return _index4.NoSchemaIntrospectionCustomRule;
        }
      });
      Object.defineProperty(exports, "NoUndefinedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUndefinedVariablesRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedFragmentsRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedFragmentsRule;
        }
      });
      Object.defineProperty(exports, "NoUnusedVariablesRule", {
        enumerable: true,
        get: function() {
          return _index4.NoUnusedVariablesRule;
        }
      });
      Object.defineProperty(exports, "OperationTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.OperationTypeNode;
        }
      });
      Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
        enumerable: true,
        get: function() {
          return _index4.OverlappingFieldsCanBeMergedRule;
        }
      });
      Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleFragmentSpreadsRule;
        }
      });
      Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
        enumerable: true,
        get: function() {
          return _index4.PossibleTypeExtensionsRule;
        }
      });
      Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
        enumerable: true,
        get: function() {
          return _index4.ProvidedRequiredArgumentsRule;
        }
      });
      Object.defineProperty(exports, "ScalarLeafsRule", {
        enumerable: true,
        get: function() {
          return _index4.ScalarLeafsRule;
        }
      });
      Object.defineProperty(exports, "SchemaMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.SchemaMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
        enumerable: true,
        get: function() {
          return _index4.SingleFieldSubscriptionsRule;
        }
      });
      Object.defineProperty(exports, "Source", {
        enumerable: true,
        get: function() {
          return _index2.Source;
        }
      });
      Object.defineProperty(exports, "Token", {
        enumerable: true,
        get: function() {
          return _index2.Token;
        }
      });
      Object.defineProperty(exports, "TokenKind", {
        enumerable: true,
        get: function() {
          return _index2.TokenKind;
        }
      });
      Object.defineProperty(exports, "TypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.TypeInfo;
        }
      });
      Object.defineProperty(exports, "TypeKind", {
        enumerable: true,
        get: function() {
          return _index.TypeKind;
        }
      });
      Object.defineProperty(exports, "TypeMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "TypeNameMetaFieldDef", {
        enumerable: true,
        get: function() {
          return _index.TypeNameMetaFieldDef;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueArgumentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueArgumentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectiveNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueDirectivesPerLocationRule;
        }
      });
      Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueEnumValueNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFieldDefinitionNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueFragmentNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueFragmentNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueInputFieldNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueOperationTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueOperationTypesRule;
        }
      });
      Object.defineProperty(exports, "UniqueTypeNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueTypeNamesRule;
        }
      });
      Object.defineProperty(exports, "UniqueVariableNamesRule", {
        enumerable: true,
        get: function() {
          return _index4.UniqueVariableNamesRule;
        }
      });
      Object.defineProperty(exports, "ValidationContext", {
        enumerable: true,
        get: function() {
          return _index4.ValidationContext;
        }
      });
      Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
        enumerable: true,
        get: function() {
          return _index4.ValuesOfCorrectTypeRule;
        }
      });
      Object.defineProperty(exports, "VariablesAreInputTypesRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesAreInputTypesRule;
        }
      });
      Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
        enumerable: true,
        get: function() {
          return _index4.VariablesInAllowedPositionRule;
        }
      });
      Object.defineProperty(exports, "__Directive", {
        enumerable: true,
        get: function() {
          return _index.__Directive;
        }
      });
      Object.defineProperty(exports, "__DirectiveLocation", {
        enumerable: true,
        get: function() {
          return _index.__DirectiveLocation;
        }
      });
      Object.defineProperty(exports, "__EnumValue", {
        enumerable: true,
        get: function() {
          return _index.__EnumValue;
        }
      });
      Object.defineProperty(exports, "__Field", {
        enumerable: true,
        get: function() {
          return _index.__Field;
        }
      });
      Object.defineProperty(exports, "__InputValue", {
        enumerable: true,
        get: function() {
          return _index.__InputValue;
        }
      });
      Object.defineProperty(exports, "__Schema", {
        enumerable: true,
        get: function() {
          return _index.__Schema;
        }
      });
      Object.defineProperty(exports, "__Type", {
        enumerable: true,
        get: function() {
          return _index.__Type;
        }
      });
      Object.defineProperty(exports, "__TypeKind", {
        enumerable: true,
        get: function() {
          return _index.__TypeKind;
        }
      });
      Object.defineProperty(exports, "assertAbstractType", {
        enumerable: true,
        get: function() {
          return _index.assertAbstractType;
        }
      });
      Object.defineProperty(exports, "assertCompositeType", {
        enumerable: true,
        get: function() {
          return _index.assertCompositeType;
        }
      });
      Object.defineProperty(exports, "assertDirective", {
        enumerable: true,
        get: function() {
          return _index.assertDirective;
        }
      });
      Object.defineProperty(exports, "assertEnumType", {
        enumerable: true,
        get: function() {
          return _index.assertEnumType;
        }
      });
      Object.defineProperty(exports, "assertEnumValueName", {
        enumerable: true,
        get: function() {
          return _index.assertEnumValueName;
        }
      });
      Object.defineProperty(exports, "assertInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertInputObjectType;
        }
      });
      Object.defineProperty(exports, "assertInputType", {
        enumerable: true,
        get: function() {
          return _index.assertInputType;
        }
      });
      Object.defineProperty(exports, "assertInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.assertInterfaceType;
        }
      });
      Object.defineProperty(exports, "assertLeafType", {
        enumerable: true,
        get: function() {
          return _index.assertLeafType;
        }
      });
      Object.defineProperty(exports, "assertListType", {
        enumerable: true,
        get: function() {
          return _index.assertListType;
        }
      });
      Object.defineProperty(exports, "assertName", {
        enumerable: true,
        get: function() {
          return _index.assertName;
        }
      });
      Object.defineProperty(exports, "assertNamedType", {
        enumerable: true,
        get: function() {
          return _index.assertNamedType;
        }
      });
      Object.defineProperty(exports, "assertNonNullType", {
        enumerable: true,
        get: function() {
          return _index.assertNonNullType;
        }
      });
      Object.defineProperty(exports, "assertNullableType", {
        enumerable: true,
        get: function() {
          return _index.assertNullableType;
        }
      });
      Object.defineProperty(exports, "assertObjectType", {
        enumerable: true,
        get: function() {
          return _index.assertObjectType;
        }
      });
      Object.defineProperty(exports, "assertOutputType", {
        enumerable: true,
        get: function() {
          return _index.assertOutputType;
        }
      });
      Object.defineProperty(exports, "assertScalarType", {
        enumerable: true,
        get: function() {
          return _index.assertScalarType;
        }
      });
      Object.defineProperty(exports, "assertSchema", {
        enumerable: true,
        get: function() {
          return _index.assertSchema;
        }
      });
      Object.defineProperty(exports, "assertType", {
        enumerable: true,
        get: function() {
          return _index.assertType;
        }
      });
      Object.defineProperty(exports, "assertUnionType", {
        enumerable: true,
        get: function() {
          return _index.assertUnionType;
        }
      });
      Object.defineProperty(exports, "assertValidName", {
        enumerable: true,
        get: function() {
          return _index6.assertValidName;
        }
      });
      Object.defineProperty(exports, "assertValidSchema", {
        enumerable: true,
        get: function() {
          return _index.assertValidSchema;
        }
      });
      Object.defineProperty(exports, "assertWrappingType", {
        enumerable: true,
        get: function() {
          return _index.assertWrappingType;
        }
      });
      Object.defineProperty(exports, "astFromValue", {
        enumerable: true,
        get: function() {
          return _index6.astFromValue;
        }
      });
      Object.defineProperty(exports, "buildASTSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildASTSchema;
        }
      });
      Object.defineProperty(exports, "buildClientSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildClientSchema;
        }
      });
      Object.defineProperty(exports, "buildSchema", {
        enumerable: true,
        get: function() {
          return _index6.buildSchema;
        }
      });
      Object.defineProperty(exports, "coerceInputValue", {
        enumerable: true,
        get: function() {
          return _index6.coerceInputValue;
        }
      });
      Object.defineProperty(exports, "concatAST", {
        enumerable: true,
        get: function() {
          return _index6.concatAST;
        }
      });
      Object.defineProperty(exports, "createSourceEventStream", {
        enumerable: true,
        get: function() {
          return _index3.createSourceEventStream;
        }
      });
      Object.defineProperty(exports, "defaultFieldResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultFieldResolver;
        }
      });
      Object.defineProperty(exports, "defaultTypeResolver", {
        enumerable: true,
        get: function() {
          return _index3.defaultTypeResolver;
        }
      });
      Object.defineProperty(exports, "doTypesOverlap", {
        enumerable: true,
        get: function() {
          return _index6.doTypesOverlap;
        }
      });
      Object.defineProperty(exports, "execute", {
        enumerable: true,
        get: function() {
          return _index3.execute;
        }
      });
      Object.defineProperty(exports, "executeSync", {
        enumerable: true,
        get: function() {
          return _index3.executeSync;
        }
      });
      Object.defineProperty(exports, "extendSchema", {
        enumerable: true,
        get: function() {
          return _index6.extendSchema;
        }
      });
      Object.defineProperty(exports, "findBreakingChanges", {
        enumerable: true,
        get: function() {
          return _index6.findBreakingChanges;
        }
      });
      Object.defineProperty(exports, "findDangerousChanges", {
        enumerable: true,
        get: function() {
          return _index6.findDangerousChanges;
        }
      });
      Object.defineProperty(exports, "formatError", {
        enumerable: true,
        get: function() {
          return _index5.formatError;
        }
      });
      Object.defineProperty(exports, "getArgumentValues", {
        enumerable: true,
        get: function() {
          return _index3.getArgumentValues;
        }
      });
      Object.defineProperty(exports, "getDirectiveValues", {
        enumerable: true,
        get: function() {
          return _index3.getDirectiveValues;
        }
      });
      Object.defineProperty(exports, "getEnterLeaveForKind", {
        enumerable: true,
        get: function() {
          return _index2.getEnterLeaveForKind;
        }
      });
      Object.defineProperty(exports, "getIntrospectionQuery", {
        enumerable: true,
        get: function() {
          return _index6.getIntrospectionQuery;
        }
      });
      Object.defineProperty(exports, "getLocation", {
        enumerable: true,
        get: function() {
          return _index2.getLocation;
        }
      });
      Object.defineProperty(exports, "getNamedType", {
        enumerable: true,
        get: function() {
          return _index.getNamedType;
        }
      });
      Object.defineProperty(exports, "getNullableType", {
        enumerable: true,
        get: function() {
          return _index.getNullableType;
        }
      });
      Object.defineProperty(exports, "getOperationAST", {
        enumerable: true,
        get: function() {
          return _index6.getOperationAST;
        }
      });
      Object.defineProperty(exports, "getOperationRootType", {
        enumerable: true,
        get: function() {
          return _index6.getOperationRootType;
        }
      });
      Object.defineProperty(exports, "getVariableValues", {
        enumerable: true,
        get: function() {
          return _index3.getVariableValues;
        }
      });
      Object.defineProperty(exports, "getVisitFn", {
        enumerable: true,
        get: function() {
          return _index2.getVisitFn;
        }
      });
      Object.defineProperty(exports, "graphql", {
        enumerable: true,
        get: function() {
          return _graphql.graphql;
        }
      });
      Object.defineProperty(exports, "graphqlSync", {
        enumerable: true,
        get: function() {
          return _graphql.graphqlSync;
        }
      });
      Object.defineProperty(exports, "introspectionFromSchema", {
        enumerable: true,
        get: function() {
          return _index6.introspectionFromSchema;
        }
      });
      Object.defineProperty(exports, "introspectionTypes", {
        enumerable: true,
        get: function() {
          return _index.introspectionTypes;
        }
      });
      Object.defineProperty(exports, "isAbstractType", {
        enumerable: true,
        get: function() {
          return _index.isAbstractType;
        }
      });
      Object.defineProperty(exports, "isCompositeType", {
        enumerable: true,
        get: function() {
          return _index.isCompositeType;
        }
      });
      Object.defineProperty(exports, "isConstValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isConstValueNode;
        }
      });
      Object.defineProperty(exports, "isDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isDirective", {
        enumerable: true,
        get: function() {
          return _index.isDirective;
        }
      });
      Object.defineProperty(exports, "isEnumType", {
        enumerable: true,
        get: function() {
          return _index.isEnumType;
        }
      });
      Object.defineProperty(exports, "isEqualType", {
        enumerable: true,
        get: function() {
          return _index6.isEqualType;
        }
      });
      Object.defineProperty(exports, "isExecutableDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isExecutableDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isInputObjectType", {
        enumerable: true,
        get: function() {
          return _index.isInputObjectType;
        }
      });
      Object.defineProperty(exports, "isInputType", {
        enumerable: true,
        get: function() {
          return _index.isInputType;
        }
      });
      Object.defineProperty(exports, "isInterfaceType", {
        enumerable: true,
        get: function() {
          return _index.isInterfaceType;
        }
      });
      Object.defineProperty(exports, "isIntrospectionType", {
        enumerable: true,
        get: function() {
          return _index.isIntrospectionType;
        }
      });
      Object.defineProperty(exports, "isLeafType", {
        enumerable: true,
        get: function() {
          return _index.isLeafType;
        }
      });
      Object.defineProperty(exports, "isListType", {
        enumerable: true,
        get: function() {
          return _index.isListType;
        }
      });
      Object.defineProperty(exports, "isNamedType", {
        enumerable: true,
        get: function() {
          return _index.isNamedType;
        }
      });
      Object.defineProperty(exports, "isNonNullType", {
        enumerable: true,
        get: function() {
          return _index.isNonNullType;
        }
      });
      Object.defineProperty(exports, "isNullableType", {
        enumerable: true,
        get: function() {
          return _index.isNullableType;
        }
      });
      Object.defineProperty(exports, "isObjectType", {
        enumerable: true,
        get: function() {
          return _index.isObjectType;
        }
      });
      Object.defineProperty(exports, "isOutputType", {
        enumerable: true,
        get: function() {
          return _index.isOutputType;
        }
      });
      Object.defineProperty(exports, "isRequiredArgument", {
        enumerable: true,
        get: function() {
          return _index.isRequiredArgument;
        }
      });
      Object.defineProperty(exports, "isRequiredInputField", {
        enumerable: true,
        get: function() {
          return _index.isRequiredInputField;
        }
      });
      Object.defineProperty(exports, "isScalarType", {
        enumerable: true,
        get: function() {
          return _index.isScalarType;
        }
      });
      Object.defineProperty(exports, "isSchema", {
        enumerable: true,
        get: function() {
          return _index.isSchema;
        }
      });
      Object.defineProperty(exports, "isSelectionNode", {
        enumerable: true,
        get: function() {
          return _index2.isSelectionNode;
        }
      });
      Object.defineProperty(exports, "isSpecifiedDirective", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedDirective;
        }
      });
      Object.defineProperty(exports, "isSpecifiedScalarType", {
        enumerable: true,
        get: function() {
          return _index.isSpecifiedScalarType;
        }
      });
      Object.defineProperty(exports, "isType", {
        enumerable: true,
        get: function() {
          return _index.isType;
        }
      });
      Object.defineProperty(exports, "isTypeDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeExtensionNode;
        }
      });
      Object.defineProperty(exports, "isTypeNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeNode;
        }
      });
      Object.defineProperty(exports, "isTypeSubTypeOf", {
        enumerable: true,
        get: function() {
          return _index6.isTypeSubTypeOf;
        }
      });
      Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemDefinitionNode;
        }
      });
      Object.defineProperty(exports, "isTypeSystemExtensionNode", {
        enumerable: true,
        get: function() {
          return _index2.isTypeSystemExtensionNode;
        }
      });
      Object.defineProperty(exports, "isUnionType", {
        enumerable: true,
        get: function() {
          return _index.isUnionType;
        }
      });
      Object.defineProperty(exports, "isValidNameError", {
        enumerable: true,
        get: function() {
          return _index6.isValidNameError;
        }
      });
      Object.defineProperty(exports, "isValueNode", {
        enumerable: true,
        get: function() {
          return _index2.isValueNode;
        }
      });
      Object.defineProperty(exports, "isWrappingType", {
        enumerable: true,
        get: function() {
          return _index.isWrappingType;
        }
      });
      Object.defineProperty(exports, "lexicographicSortSchema", {
        enumerable: true,
        get: function() {
          return _index6.lexicographicSortSchema;
        }
      });
      Object.defineProperty(exports, "locatedError", {
        enumerable: true,
        get: function() {
          return _index5.locatedError;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function() {
          return _index2.parse;
        }
      });
      Object.defineProperty(exports, "parseConstValue", {
        enumerable: true,
        get: function() {
          return _index2.parseConstValue;
        }
      });
      Object.defineProperty(exports, "parseType", {
        enumerable: true,
        get: function() {
          return _index2.parseType;
        }
      });
      Object.defineProperty(exports, "parseValue", {
        enumerable: true,
        get: function() {
          return _index2.parseValue;
        }
      });
      Object.defineProperty(exports, "print", {
        enumerable: true,
        get: function() {
          return _index2.print;
        }
      });
      Object.defineProperty(exports, "printError", {
        enumerable: true,
        get: function() {
          return _index5.printError;
        }
      });
      Object.defineProperty(exports, "printIntrospectionSchema", {
        enumerable: true,
        get: function() {
          return _index6.printIntrospectionSchema;
        }
      });
      Object.defineProperty(exports, "printLocation", {
        enumerable: true,
        get: function() {
          return _index2.printLocation;
        }
      });
      Object.defineProperty(exports, "printSchema", {
        enumerable: true,
        get: function() {
          return _index6.printSchema;
        }
      });
      Object.defineProperty(exports, "printSourceLocation", {
        enumerable: true,
        get: function() {
          return _index2.printSourceLocation;
        }
      });
      Object.defineProperty(exports, "printType", {
        enumerable: true,
        get: function() {
          return _index6.printType;
        }
      });
      Object.defineProperty(exports, "resolveObjMapThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveObjMapThunk;
        }
      });
      Object.defineProperty(exports, "resolveReadonlyArrayThunk", {
        enumerable: true,
        get: function() {
          return _index.resolveReadonlyArrayThunk;
        }
      });
      Object.defineProperty(exports, "responsePathAsArray", {
        enumerable: true,
        get: function() {
          return _index3.responsePathAsArray;
        }
      });
      Object.defineProperty(exports, "separateOperations", {
        enumerable: true,
        get: function() {
          return _index6.separateOperations;
        }
      });
      Object.defineProperty(exports, "specifiedDirectives", {
        enumerable: true,
        get: function() {
          return _index.specifiedDirectives;
        }
      });
      Object.defineProperty(exports, "specifiedRules", {
        enumerable: true,
        get: function() {
          return _index4.specifiedRules;
        }
      });
      Object.defineProperty(exports, "specifiedScalarTypes", {
        enumerable: true,
        get: function() {
          return _index.specifiedScalarTypes;
        }
      });
      Object.defineProperty(exports, "stripIgnoredCharacters", {
        enumerable: true,
        get: function() {
          return _index6.stripIgnoredCharacters;
        }
      });
      Object.defineProperty(exports, "subscribe", {
        enumerable: true,
        get: function() {
          return _index3.subscribe;
        }
      });
      Object.defineProperty(exports, "syntaxError", {
        enumerable: true,
        get: function() {
          return _index5.syntaxError;
        }
      });
      Object.defineProperty(exports, "typeFromAST", {
        enumerable: true,
        get: function() {
          return _index6.typeFromAST;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function() {
          return _index4.validate;
        }
      });
      Object.defineProperty(exports, "validateSchema", {
        enumerable: true,
        get: function() {
          return _index.validateSchema;
        }
      });
      Object.defineProperty(exports, "valueFromAST", {
        enumerable: true,
        get: function() {
          return _index6.valueFromAST;
        }
      });
      Object.defineProperty(exports, "valueFromASTUntyped", {
        enumerable: true,
        get: function() {
          return _index6.valueFromASTUntyped;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function() {
          return _version.version;
        }
      });
      Object.defineProperty(exports, "versionInfo", {
        enumerable: true,
        get: function() {
          return _version.versionInfo;
        }
      });
      Object.defineProperty(exports, "visit", {
        enumerable: true,
        get: function() {
          return _index2.visit;
        }
      });
      Object.defineProperty(exports, "visitInParallel", {
        enumerable: true,
        get: function() {
          return _index2.visitInParallel;
        }
      });
      Object.defineProperty(exports, "visitWithTypeInfo", {
        enumerable: true,
        get: function() {
          return _index6.visitWithTypeInfo;
        }
      });
      var _version = require_version();
      var _graphql = require_graphql();
      var _index = require_type();
      var _index2 = require_language();
      var _index3 = require_execution();
      var _index4 = require_validation();
      var _index5 = require_error();
      var _index6 = require_utilities();
    }
  });

  // node_modules/graphql-language-service/dist/interface/autocompleteUtils.js
  var require_autocompleteUtils = __commonJS({
    "node_modules/graphql-language-service/dist/interface/autocompleteUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hintList = exports.objectValues = exports.forEachState = exports.getFieldDef = exports.getDefinitionState = void 0;
      var graphql_1 = require_graphql2();
      var introspection_1 = require_introspection();
      function getDefinitionState(tokenState) {
        let definitionState;
        forEachState(tokenState, (state) => {
          switch (state.kind) {
            case "Query":
            case "ShortQuery":
            case "Mutation":
            case "Subscription":
            case "FragmentDefinition":
              definitionState = state;
              break;
          }
        });
        return definitionState;
      }
      exports.getDefinitionState = getDefinitionState;
      function getFieldDef(schema, type, fieldName) {
        if (fieldName === introspection_1.SchemaMetaFieldDef.name && schema.getQueryType() === type) {
          return introspection_1.SchemaMetaFieldDef;
        }
        if (fieldName === introspection_1.TypeMetaFieldDef.name && schema.getQueryType() === type) {
          return introspection_1.TypeMetaFieldDef;
        }
        if (fieldName === introspection_1.TypeNameMetaFieldDef.name && (0, graphql_1.isCompositeType)(type)) {
          return introspection_1.TypeNameMetaFieldDef;
        }
        if ("getFields" in type) {
          return type.getFields()[fieldName];
        }
        return null;
      }
      exports.getFieldDef = getFieldDef;
      function forEachState(stack, fn) {
        const reverseStateStack = [];
        let state = stack;
        while (state === null || state === void 0 ? void 0 : state.kind) {
          reverseStateStack.push(state);
          state = state.prevState;
        }
        for (let i = reverseStateStack.length - 1; i >= 0; i--) {
          fn(reverseStateStack[i]);
        }
      }
      exports.forEachState = forEachState;
      function objectValues(object) {
        const keys = Object.keys(object);
        const len = keys.length;
        const values = new Array(len);
        for (let i = 0; i < len; ++i) {
          values[i] = object[keys[i]];
        }
        return values;
      }
      exports.objectValues = objectValues;
      function hintList(token, list) {
        return filterAndSortList(list, normalizeText(token.string));
      }
      exports.hintList = hintList;
      function filterAndSortList(list, text) {
        if (!text) {
          return filterNonEmpty(list, (entry) => !entry.isDeprecated);
        }
        const byProximity = list.map((entry) => ({
          proximity: getProximity(normalizeText(entry.label), text),
          entry
        }));
        return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);
      }
      function filterNonEmpty(array, predicate) {
        const filtered = array.filter(predicate);
        return filtered.length === 0 ? array : filtered;
      }
      function normalizeText(text) {
        return text.toLowerCase().replace(/\W/g, "");
      }
      function getProximity(suggestion, text) {
        let proximity = lexicalDistance(text, suggestion);
        if (suggestion.length > text.length) {
          proximity -= suggestion.length - text.length - 1;
          proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;
        }
        return proximity;
      }
      function lexicalDistance(a, b) {
        let i;
        let j;
        const d = [];
        const aLength = a.length;
        const bLength = b.length;
        for (i = 0; i <= aLength; i++) {
          d[i] = [i];
        }
        for (j = 1; j <= bLength; j++) {
          d[0][j] = j;
        }
        for (i = 1; i <= aLength; i++) {
          for (j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
            }
          }
        }
        return d[aLength][bLength];
      }
    }
  });

  // node_modules/vscode-languageserver-types/lib/umd/main.js
  var require_main = __commonJS({
    "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module) {
      (function(factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
          var v = factory(__require, exports);
          if (v !== void 0)
            module.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = void 0;
        var DocumentUri;
        (function(DocumentUri2) {
          function is(value) {
            return typeof value === "string";
          }
          DocumentUri2.is = is;
        })(DocumentUri = exports2.DocumentUri || (exports2.DocumentUri = {}));
        var URI2;
        (function(URI3) {
          function is(value) {
            return typeof value === "string";
          }
          URI3.is = is;
        })(URI2 = exports2.URI || (exports2.URI = {}));
        var integer;
        (function(integer2) {
          integer2.MIN_VALUE = -2147483648;
          integer2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
          }
          integer2.is = is;
        })(integer = exports2.integer || (exports2.integer = {}));
        var uinteger;
        (function(uinteger2) {
          uinteger2.MIN_VALUE = 0;
          uinteger2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
          }
          uinteger2.is = is;
        })(uinteger = exports2.uinteger || (exports2.uinteger = {}));
        var Position2;
        (function(Position3) {
          function create(line, character) {
            if (line === Number.MAX_VALUE) {
              line = uinteger.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
              character = uinteger.MAX_VALUE;
            }
            return { line, character };
          }
          Position3.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
          }
          Position3.is = is;
        })(Position2 = exports2.Position || (exports2.Position = {}));
        var Range2;
        (function(Range3) {
          function create(one, two, three, four) {
            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
              return { start: Position2.create(one, two), end: Position2.create(three, four) };
            } else if (Position2.is(one) && Position2.is(two)) {
              return { start: one, end: two };
            } else {
              throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
          }
          Range3.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
          }
          Range3.is = is;
        })(Range2 = exports2.Range || (exports2.Range = {}));
        var Location;
        (function(Location2) {
          function create(uri, range) {
            return { uri, range };
          }
          Location2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
          }
          Location2.is = is;
        })(Location = exports2.Location || (exports2.Location = {}));
        var LocationLink;
        (function(LocationLink2) {
          function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
          }
          LocationLink2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
          }
          LocationLink2.is = is;
        })(LocationLink = exports2.LocationLink || (exports2.LocationLink = {}));
        var Color;
        (function(Color2) {
          function create(red, green, blue, alpha) {
            return {
              red,
              green,
              blue,
              alpha
            };
          }
          Color2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
          }
          Color2.is = is;
        })(Color = exports2.Color || (exports2.Color = {}));
        var ColorInformation;
        (function(ColorInformation2) {
          function create(range, color) {
            return {
              range,
              color
            };
          }
          ColorInformation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && Color.is(candidate.color);
          }
          ColorInformation2.is = is;
        })(ColorInformation = exports2.ColorInformation || (exports2.ColorInformation = {}));
        var ColorPresentation;
        (function(ColorPresentation2) {
          function create(label, textEdit, additionalTextEdits) {
            return {
              label,
              textEdit,
              additionalTextEdits
            };
          }
          ColorPresentation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
          }
          ColorPresentation2.is = is;
        })(ColorPresentation = exports2.ColorPresentation || (exports2.ColorPresentation = {}));
        var FoldingRangeKind2;
        (function(FoldingRangeKind3) {
          FoldingRangeKind3.Comment = "comment";
          FoldingRangeKind3.Imports = "imports";
          FoldingRangeKind3.Region = "region";
        })(FoldingRangeKind2 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
        var FoldingRange;
        (function(FoldingRange2) {
          function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
              startLine,
              endLine
            };
            if (Is.defined(startCharacter)) {
              result.startCharacter = startCharacter;
            }
            if (Is.defined(endCharacter)) {
              result.endCharacter = endCharacter;
            }
            if (Is.defined(kind)) {
              result.kind = kind;
            }
            if (Is.defined(collapsedText)) {
              result.collapsedText = collapsedText;
            }
            return result;
          }
          FoldingRange2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
          }
          FoldingRange2.is = is;
        })(FoldingRange = exports2.FoldingRange || (exports2.FoldingRange = {}));
        var DiagnosticRelatedInformation;
        (function(DiagnosticRelatedInformation2) {
          function create(location, message) {
            return {
              location,
              message
            };
          }
          DiagnosticRelatedInformation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
          }
          DiagnosticRelatedInformation2.is = is;
        })(DiagnosticRelatedInformation = exports2.DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = {}));
        var DiagnosticSeverity;
        (function(DiagnosticSeverity2) {
          DiagnosticSeverity2.Error = 1;
          DiagnosticSeverity2.Warning = 2;
          DiagnosticSeverity2.Information = 3;
          DiagnosticSeverity2.Hint = 4;
        })(DiagnosticSeverity = exports2.DiagnosticSeverity || (exports2.DiagnosticSeverity = {}));
        var DiagnosticTag;
        (function(DiagnosticTag2) {
          DiagnosticTag2.Unnecessary = 1;
          DiagnosticTag2.Deprecated = 2;
        })(DiagnosticTag = exports2.DiagnosticTag || (exports2.DiagnosticTag = {}));
        var CodeDescription;
        (function(CodeDescription2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.href);
          }
          CodeDescription2.is = is;
        })(CodeDescription = exports2.CodeDescription || (exports2.CodeDescription = {}));
        var Diagnostic;
        (function(Diagnostic2) {
          function create(range, message, severity, code, source, relatedInformation) {
            var result = { range, message };
            if (Is.defined(severity)) {
              result.severity = severity;
            }
            if (Is.defined(code)) {
              result.code = code;
            }
            if (Is.defined(source)) {
              result.source = source;
            }
            if (Is.defined(relatedInformation)) {
              result.relatedInformation = relatedInformation;
            }
            return result;
          }
          Diagnostic2.create = create;
          function is(value) {
            var _a3;
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a3 = candidate.codeDescription) === null || _a3 === void 0 ? void 0 : _a3.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
          }
          Diagnostic2.is = is;
        })(Diagnostic = exports2.Diagnostic || (exports2.Diagnostic = {}));
        var Command2;
        (function(Command3) {
          function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var result = { title, command };
            if (Is.defined(args) && args.length > 0) {
              result.arguments = args;
            }
            return result;
          }
          Command3.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
          }
          Command3.is = is;
        })(Command2 = exports2.Command || (exports2.Command = {}));
        var TextEdit;
        (function(TextEdit2) {
          function replace(range, newText) {
            return { range, newText };
          }
          TextEdit2.replace = replace;
          function insert(position, newText) {
            return { range: { start: position, end: position }, newText };
          }
          TextEdit2.insert = insert;
          function del(range) {
            return { range, newText: "" };
          }
          TextEdit2.del = del;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
          }
          TextEdit2.is = is;
        })(TextEdit = exports2.TextEdit || (exports2.TextEdit = {}));
        var ChangeAnnotation;
        (function(ChangeAnnotation2) {
          function create(label, needsConfirmation, description) {
            var result = { label };
            if (needsConfirmation !== void 0) {
              result.needsConfirmation = needsConfirmation;
            }
            if (description !== void 0) {
              result.description = description;
            }
            return result;
          }
          ChangeAnnotation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          ChangeAnnotation2.is = is;
        })(ChangeAnnotation = exports2.ChangeAnnotation || (exports2.ChangeAnnotation = {}));
        var ChangeAnnotationIdentifier;
        (function(ChangeAnnotationIdentifier2) {
          function is(value) {
            var candidate = value;
            return Is.string(candidate);
          }
          ChangeAnnotationIdentifier2.is = is;
        })(ChangeAnnotationIdentifier = exports2.ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = {}));
        var AnnotatedTextEdit;
        (function(AnnotatedTextEdit2) {
          function replace(range, newText, annotation) {
            return { range, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.replace = replace;
          function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.insert = insert;
          function del(range, annotation) {
            return { range, newText: "", annotationId: annotation };
          }
          AnnotatedTextEdit2.del = del;
          function is(value) {
            var candidate = value;
            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          AnnotatedTextEdit2.is = is;
        })(AnnotatedTextEdit = exports2.AnnotatedTextEdit || (exports2.AnnotatedTextEdit = {}));
        var TextDocumentEdit;
        (function(TextDocumentEdit2) {
          function create(textDocument, edits) {
            return { textDocument, edits };
          }
          TextDocumentEdit2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
          }
          TextDocumentEdit2.is = is;
        })(TextDocumentEdit = exports2.TextDocumentEdit || (exports2.TextDocumentEdit = {}));
        var CreateFile;
        (function(CreateFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "create",
              uri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          CreateFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          CreateFile2.is = is;
        })(CreateFile = exports2.CreateFile || (exports2.CreateFile = {}));
        var RenameFile;
        (function(RenameFile2) {
          function create(oldUri, newUri, options, annotation) {
            var result = {
              kind: "rename",
              oldUri,
              newUri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          RenameFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          RenameFile2.is = is;
        })(RenameFile = exports2.RenameFile || (exports2.RenameFile = {}));
        var DeleteFile;
        (function(DeleteFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "delete",
              uri
            };
            if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          DeleteFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          DeleteFile2.is = is;
        })(DeleteFile = exports2.DeleteFile || (exports2.DeleteFile = {}));
        var WorkspaceEdit;
        (function(WorkspaceEdit2) {
          function is(value) {
            var candidate = value;
            return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
              if (Is.string(change.kind)) {
                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
              } else {
                return TextDocumentEdit.is(change);
              }
            }));
          }
          WorkspaceEdit2.is = is;
        })(WorkspaceEdit = exports2.WorkspaceEdit || (exports2.WorkspaceEdit = {}));
        var TextEditChangeImpl = function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }();
        var ChangeAnnotations = function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }();
        var WorkspaceChange = function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }();
        exports2.WorkspaceChange = WorkspaceChange;
        var TextDocumentIdentifier;
        (function(TextDocumentIdentifier2) {
          function create(uri) {
            return { uri };
          }
          TextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri);
          }
          TextDocumentIdentifier2.is = is;
        })(TextDocumentIdentifier = exports2.TextDocumentIdentifier || (exports2.TextDocumentIdentifier = {}));
        var VersionedTextDocumentIdentifier;
        (function(VersionedTextDocumentIdentifier2) {
          function create(uri, version) {
            return { uri, version };
          }
          VersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
          }
          VersionedTextDocumentIdentifier2.is = is;
        })(VersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = {}));
        var OptionalVersionedTextDocumentIdentifier;
        (function(OptionalVersionedTextDocumentIdentifier2) {
          function create(uri, version) {
            return { uri, version };
          }
          OptionalVersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
          }
          OptionalVersionedTextDocumentIdentifier2.is = is;
        })(OptionalVersionedTextDocumentIdentifier = exports2.OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = {}));
        var TextDocumentItem;
        (function(TextDocumentItem2) {
          function create(uri, languageId, version, text) {
            return { uri, languageId, version, text };
          }
          TextDocumentItem2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
          }
          TextDocumentItem2.is = is;
        })(TextDocumentItem = exports2.TextDocumentItem || (exports2.TextDocumentItem = {}));
        var MarkupKind;
        (function(MarkupKind2) {
          MarkupKind2.PlainText = "plaintext";
          MarkupKind2.Markdown = "markdown";
          function is(value) {
            var candidate = value;
            return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
          }
          MarkupKind2.is = is;
        })(MarkupKind = exports2.MarkupKind || (exports2.MarkupKind = {}));
        var MarkupContent;
        (function(MarkupContent2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
          }
          MarkupContent2.is = is;
        })(MarkupContent = exports2.MarkupContent || (exports2.MarkupContent = {}));
        var CompletionItemKind2;
        (function(CompletionItemKind3) {
          CompletionItemKind3.Text = 1;
          CompletionItemKind3.Method = 2;
          CompletionItemKind3.Function = 3;
          CompletionItemKind3.Constructor = 4;
          CompletionItemKind3.Field = 5;
          CompletionItemKind3.Variable = 6;
          CompletionItemKind3.Class = 7;
          CompletionItemKind3.Interface = 8;
          CompletionItemKind3.Module = 9;
          CompletionItemKind3.Property = 10;
          CompletionItemKind3.Unit = 11;
          CompletionItemKind3.Value = 12;
          CompletionItemKind3.Enum = 13;
          CompletionItemKind3.Keyword = 14;
          CompletionItemKind3.Snippet = 15;
          CompletionItemKind3.Color = 16;
          CompletionItemKind3.File = 17;
          CompletionItemKind3.Reference = 18;
          CompletionItemKind3.Folder = 19;
          CompletionItemKind3.EnumMember = 20;
          CompletionItemKind3.Constant = 21;
          CompletionItemKind3.Struct = 22;
          CompletionItemKind3.Event = 23;
          CompletionItemKind3.Operator = 24;
          CompletionItemKind3.TypeParameter = 25;
        })(CompletionItemKind2 = exports2.CompletionItemKind || (exports2.CompletionItemKind = {}));
        var InsertTextFormat;
        (function(InsertTextFormat2) {
          InsertTextFormat2.PlainText = 1;
          InsertTextFormat2.Snippet = 2;
        })(InsertTextFormat = exports2.InsertTextFormat || (exports2.InsertTextFormat = {}));
        var CompletionItemTag2;
        (function(CompletionItemTag3) {
          CompletionItemTag3.Deprecated = 1;
        })(CompletionItemTag2 = exports2.CompletionItemTag || (exports2.CompletionItemTag = {}));
        var InsertReplaceEdit;
        (function(InsertReplaceEdit2) {
          function create(newText, insert, replace) {
            return { newText, insert, replace };
          }
          InsertReplaceEdit2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
          }
          InsertReplaceEdit2.is = is;
        })(InsertReplaceEdit = exports2.InsertReplaceEdit || (exports2.InsertReplaceEdit = {}));
        var InsertTextMode;
        (function(InsertTextMode2) {
          InsertTextMode2.asIs = 1;
          InsertTextMode2.adjustIndentation = 2;
        })(InsertTextMode = exports2.InsertTextMode || (exports2.InsertTextMode = {}));
        var CompletionItemLabelDetails;
        (function(CompletionItemLabelDetails2) {
          function is(value) {
            var candidate = value;
            return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          CompletionItemLabelDetails2.is = is;
        })(CompletionItemLabelDetails = exports2.CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = {}));
        var CompletionItem;
        (function(CompletionItem2) {
          function create(label) {
            return { label };
          }
          CompletionItem2.create = create;
        })(CompletionItem = exports2.CompletionItem || (exports2.CompletionItem = {}));
        var CompletionList;
        (function(CompletionList2) {
          function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
          }
          CompletionList2.create = create;
        })(CompletionList = exports2.CompletionList || (exports2.CompletionList = {}));
        var MarkedString;
        (function(MarkedString2) {
          function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
          }
          MarkedString2.fromPlainText = fromPlainText;
          function is(value) {
            var candidate = value;
            return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
          }
          MarkedString2.is = is;
        })(MarkedString = exports2.MarkedString || (exports2.MarkedString = {}));
        var Hover;
        (function(Hover2) {
          function is(value) {
            var candidate = value;
            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
          }
          Hover2.is = is;
        })(Hover = exports2.Hover || (exports2.Hover = {}));
        var ParameterInformation;
        (function(ParameterInformation2) {
          function create(label, documentation) {
            return documentation ? { label, documentation } : { label };
          }
          ParameterInformation2.create = create;
        })(ParameterInformation = exports2.ParameterInformation || (exports2.ParameterInformation = {}));
        var SignatureInformation;
        (function(SignatureInformation2) {
          function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              parameters[_i - 2] = arguments[_i];
            }
            var result = { label };
            if (Is.defined(documentation)) {
              result.documentation = documentation;
            }
            if (Is.defined(parameters)) {
              result.parameters = parameters;
            } else {
              result.parameters = [];
            }
            return result;
          }
          SignatureInformation2.create = create;
        })(SignatureInformation = exports2.SignatureInformation || (exports2.SignatureInformation = {}));
        var DocumentHighlightKind3;
        (function(DocumentHighlightKind4) {
          DocumentHighlightKind4.Text = 1;
          DocumentHighlightKind4.Read = 2;
          DocumentHighlightKind4.Write = 3;
        })(DocumentHighlightKind3 = exports2.DocumentHighlightKind || (exports2.DocumentHighlightKind = {}));
        var DocumentHighlight;
        (function(DocumentHighlight2) {
          function create(range, kind) {
            var result = { range };
            if (Is.number(kind)) {
              result.kind = kind;
            }
            return result;
          }
          DocumentHighlight2.create = create;
        })(DocumentHighlight = exports2.DocumentHighlight || (exports2.DocumentHighlight = {}));
        var SymbolKind2;
        (function(SymbolKind3) {
          SymbolKind3.File = 1;
          SymbolKind3.Module = 2;
          SymbolKind3.Namespace = 3;
          SymbolKind3.Package = 4;
          SymbolKind3.Class = 5;
          SymbolKind3.Method = 6;
          SymbolKind3.Property = 7;
          SymbolKind3.Field = 8;
          SymbolKind3.Constructor = 9;
          SymbolKind3.Enum = 10;
          SymbolKind3.Interface = 11;
          SymbolKind3.Function = 12;
          SymbolKind3.Variable = 13;
          SymbolKind3.Constant = 14;
          SymbolKind3.String = 15;
          SymbolKind3.Number = 16;
          SymbolKind3.Boolean = 17;
          SymbolKind3.Array = 18;
          SymbolKind3.Object = 19;
          SymbolKind3.Key = 20;
          SymbolKind3.Null = 21;
          SymbolKind3.EnumMember = 22;
          SymbolKind3.Struct = 23;
          SymbolKind3.Event = 24;
          SymbolKind3.Operator = 25;
          SymbolKind3.TypeParameter = 26;
        })(SymbolKind2 = exports2.SymbolKind || (exports2.SymbolKind = {}));
        var SymbolTag2;
        (function(SymbolTag3) {
          SymbolTag3.Deprecated = 1;
        })(SymbolTag2 = exports2.SymbolTag || (exports2.SymbolTag = {}));
        var SymbolInformation;
        (function(SymbolInformation2) {
          function create(name, kind, range, uri, containerName) {
            var result = {
              name,
              kind,
              location: { uri, range }
            };
            if (containerName) {
              result.containerName = containerName;
            }
            return result;
          }
          SymbolInformation2.create = create;
        })(SymbolInformation = exports2.SymbolInformation || (exports2.SymbolInformation = {}));
        var WorkspaceSymbol;
        (function(WorkspaceSymbol2) {
          function create(name, kind, uri, range) {
            return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
          }
          WorkspaceSymbol2.create = create;
        })(WorkspaceSymbol = exports2.WorkspaceSymbol || (exports2.WorkspaceSymbol = {}));
        var DocumentSymbol;
        (function(DocumentSymbol2) {
          function create(name, detail, kind, range, selectionRange, children) {
            var result = {
              name,
              detail,
              kind,
              range,
              selectionRange
            };
            if (children !== void 0) {
              result.children = children;
            }
            return result;
          }
          DocumentSymbol2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
          }
          DocumentSymbol2.is = is;
        })(DocumentSymbol = exports2.DocumentSymbol || (exports2.DocumentSymbol = {}));
        var CodeActionKind;
        (function(CodeActionKind2) {
          CodeActionKind2.Empty = "";
          CodeActionKind2.QuickFix = "quickfix";
          CodeActionKind2.Refactor = "refactor";
          CodeActionKind2.RefactorExtract = "refactor.extract";
          CodeActionKind2.RefactorInline = "refactor.inline";
          CodeActionKind2.RefactorRewrite = "refactor.rewrite";
          CodeActionKind2.Source = "source";
          CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
          CodeActionKind2.SourceFixAll = "source.fixAll";
        })(CodeActionKind = exports2.CodeActionKind || (exports2.CodeActionKind = {}));
        var CodeActionTriggerKind;
        (function(CodeActionTriggerKind2) {
          CodeActionTriggerKind2.Invoked = 1;
          CodeActionTriggerKind2.Automatic = 2;
        })(CodeActionTriggerKind = exports2.CodeActionTriggerKind || (exports2.CodeActionTriggerKind = {}));
        var CodeActionContext;
        (function(CodeActionContext2) {
          function create(diagnostics, only, triggerKind) {
            var result = { diagnostics };
            if (only !== void 0 && only !== null) {
              result.only = only;
            }
            if (triggerKind !== void 0 && triggerKind !== null) {
              result.triggerKind = triggerKind;
            }
            return result;
          }
          CodeActionContext2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
          }
          CodeActionContext2.is = is;
        })(CodeActionContext = exports2.CodeActionContext || (exports2.CodeActionContext = {}));
        var CodeAction;
        (function(CodeAction2) {
          function create(title, kindOrCommandOrEdit, kind) {
            var result = { title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === "string") {
              checkKind = false;
              result.kind = kindOrCommandOrEdit;
            } else if (Command2.is(kindOrCommandOrEdit)) {
              result.command = kindOrCommandOrEdit;
            } else {
              result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          CodeAction2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
          }
          CodeAction2.is = is;
        })(CodeAction = exports2.CodeAction || (exports2.CodeAction = {}));
        var CodeLens;
        (function(CodeLens2) {
          function create(range, data) {
            var result = { range };
            if (Is.defined(data)) {
              result.data = data;
            }
            return result;
          }
          CodeLens2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
          }
          CodeLens2.is = is;
        })(CodeLens = exports2.CodeLens || (exports2.CodeLens = {}));
        var FormattingOptions;
        (function(FormattingOptions2) {
          function create(tabSize, insertSpaces) {
            return { tabSize, insertSpaces };
          }
          FormattingOptions2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
          }
          FormattingOptions2.is = is;
        })(FormattingOptions = exports2.FormattingOptions || (exports2.FormattingOptions = {}));
        var DocumentLink;
        (function(DocumentLink2) {
          function create(range, target, data) {
            return { range, target, data };
          }
          DocumentLink2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
          }
          DocumentLink2.is = is;
        })(DocumentLink = exports2.DocumentLink || (exports2.DocumentLink = {}));
        var SelectionRange;
        (function(SelectionRange2) {
          function create(range, parent) {
            return { range, parent };
          }
          SelectionRange2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
          }
          SelectionRange2.is = is;
        })(SelectionRange = exports2.SelectionRange || (exports2.SelectionRange = {}));
        var SemanticTokenTypes;
        (function(SemanticTokenTypes2) {
          SemanticTokenTypes2["namespace"] = "namespace";
          SemanticTokenTypes2["type"] = "type";
          SemanticTokenTypes2["class"] = "class";
          SemanticTokenTypes2["enum"] = "enum";
          SemanticTokenTypes2["interface"] = "interface";
          SemanticTokenTypes2["struct"] = "struct";
          SemanticTokenTypes2["typeParameter"] = "typeParameter";
          SemanticTokenTypes2["parameter"] = "parameter";
          SemanticTokenTypes2["variable"] = "variable";
          SemanticTokenTypes2["property"] = "property";
          SemanticTokenTypes2["enumMember"] = "enumMember";
          SemanticTokenTypes2["event"] = "event";
          SemanticTokenTypes2["function"] = "function";
          SemanticTokenTypes2["method"] = "method";
          SemanticTokenTypes2["macro"] = "macro";
          SemanticTokenTypes2["keyword"] = "keyword";
          SemanticTokenTypes2["modifier"] = "modifier";
          SemanticTokenTypes2["comment"] = "comment";
          SemanticTokenTypes2["string"] = "string";
          SemanticTokenTypes2["number"] = "number";
          SemanticTokenTypes2["regexp"] = "regexp";
          SemanticTokenTypes2["operator"] = "operator";
          SemanticTokenTypes2["decorator"] = "decorator";
        })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
        var SemanticTokenModifiers;
        (function(SemanticTokenModifiers2) {
          SemanticTokenModifiers2["declaration"] = "declaration";
          SemanticTokenModifiers2["definition"] = "definition";
          SemanticTokenModifiers2["readonly"] = "readonly";
          SemanticTokenModifiers2["static"] = "static";
          SemanticTokenModifiers2["deprecated"] = "deprecated";
          SemanticTokenModifiers2["abstract"] = "abstract";
          SemanticTokenModifiers2["async"] = "async";
          SemanticTokenModifiers2["modification"] = "modification";
          SemanticTokenModifiers2["documentation"] = "documentation";
          SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
        })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
        var SemanticTokens;
        (function(SemanticTokens2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
          }
          SemanticTokens2.is = is;
        })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
        var InlineValueText;
        (function(InlineValueText2) {
          function create(range, text) {
            return { range, text };
          }
          InlineValueText2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.string(candidate.text);
          }
          InlineValueText2.is = is;
        })(InlineValueText = exports2.InlineValueText || (exports2.InlineValueText = {}));
        var InlineValueVariableLookup;
        (function(InlineValueVariableLookup2) {
          function create(range, variableName, caseSensitiveLookup) {
            return { range, variableName, caseSensitiveLookup };
          }
          InlineValueVariableLookup2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
          }
          InlineValueVariableLookup2.is = is;
        })(InlineValueVariableLookup = exports2.InlineValueVariableLookup || (exports2.InlineValueVariableLookup = {}));
        var InlineValueEvaluatableExpression;
        (function(InlineValueEvaluatableExpression2) {
          function create(range, expression) {
            return { range, expression };
          }
          InlineValueEvaluatableExpression2.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
          }
          InlineValueEvaluatableExpression2.is = is;
        })(InlineValueEvaluatableExpression = exports2.InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = {}));
        var InlineValueContext;
        (function(InlineValueContext2) {
          function create(frameId, stoppedLocation) {
            return { frameId, stoppedLocation };
          }
          InlineValueContext2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range2.is(value.stoppedLocation);
          }
          InlineValueContext2.is = is;
        })(InlineValueContext = exports2.InlineValueContext || (exports2.InlineValueContext = {}));
        var InlayHintKind3;
        (function(InlayHintKind4) {
          InlayHintKind4.Type = 1;
          InlayHintKind4.Parameter = 2;
          function is(value) {
            return value === 1 || value === 2;
          }
          InlayHintKind4.is = is;
        })(InlayHintKind3 = exports2.InlayHintKind || (exports2.InlayHintKind = {}));
        var InlayHintLabelPart;
        (function(InlayHintLabelPart2) {
          function create(value) {
            return { value };
          }
          InlayHintLabelPart2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
          }
          InlayHintLabelPart2.is = is;
        })(InlayHintLabelPart = exports2.InlayHintLabelPart || (exports2.InlayHintLabelPart = {}));
        var InlayHint;
        (function(InlayHint2) {
          function create(position, label, kind) {
            var result = { position, label };
            if (kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          InlayHint2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
          }
          InlayHint2.is = is;
        })(InlayHint = exports2.InlayHint || (exports2.InlayHint = {}));
        var WorkspaceFolder;
        (function(WorkspaceFolder2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
          }
          WorkspaceFolder2.is = is;
        })(WorkspaceFolder = exports2.WorkspaceFolder || (exports2.WorkspaceFolder = {}));
        exports2.EOL = ["\n", "\r\n", "\r"];
        var TextDocument;
        (function(TextDocument2) {
          function create(uri, languageId, version, content) {
            return new FullTextDocument(uri, languageId, version, content);
          }
          TextDocument2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
          }
          TextDocument2.is = is;
          function applyEdits(document2, edits) {
            var text = document2.getText();
            var sortedEdits = mergeSort(edits, function(a, b) {
              var diff = a.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a.range.start.character - b.range.start.character;
              }
              return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
              var e = sortedEdits[i];
              var startOffset = document2.offsetAt(e.range.start);
              var endOffset = document2.offsetAt(e.range.end);
              if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
              } else {
                throw new Error("Overlapping edit");
              }
              lastModifiedOffset = startOffset;
            }
            return text;
          }
          TextDocument2.applyEdits = applyEdits;
          function mergeSort(data, compare) {
            if (data.length <= 1) {
              return data;
            }
            var p = data.length / 2 | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare);
            mergeSort(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
              var ret = compare(left[leftIdx], right[rightIdx]);
              if (ret <= 0) {
                data[i++] = left[leftIdx++];
              } else {
                data[i++] = right[rightIdx++];
              }
            }
            while (leftIdx < left.length) {
              data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
              data[i++] = right[rightIdx++];
            }
            return data;
          }
        })(TextDocument = exports2.TextDocument || (exports2.TextDocument = {}));
        var FullTextDocument = function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position2.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position2.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument2;
        }();
        var Is;
        (function(Is2) {
          var toString = Object.prototype.toString;
          function defined(value) {
            return typeof value !== "undefined";
          }
          Is2.defined = defined;
          function undefined2(value) {
            return typeof value === "undefined";
          }
          Is2.undefined = undefined2;
          function boolean(value) {
            return value === true || value === false;
          }
          Is2.boolean = boolean;
          function string(value) {
            return toString.call(value) === "[object String]";
          }
          Is2.string = string;
          function number(value) {
            return toString.call(value) === "[object Number]";
          }
          Is2.number = number;
          function numberRange(value, min, max) {
            return toString.call(value) === "[object Number]" && min <= value && value <= max;
          }
          Is2.numberRange = numberRange;
          function integer2(value) {
            return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
          }
          Is2.integer = integer2;
          function uinteger2(value) {
            return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
          }
          Is2.uinteger = uinteger2;
          function func(value) {
            return toString.call(value) === "[object Function]";
          }
          Is2.func = func;
          function objectLiteral(value) {
            return value !== null && typeof value === "object";
          }
          Is2.objectLiteral = objectLiteral;
          function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
          }
          Is2.typedArray = typedArray;
        })(Is || (Is = {}));
      });
    }
  });

  // node_modules/graphql-language-service/dist/types.js
  var require_types = __commonJS({
    "node_modules/graphql-language-service/dist/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompletionItemKind = exports.FileChangeTypeKind = exports.InsertTextFormat = void 0;
      var vscode_languageserver_types_1 = require_main();
      Object.defineProperty(exports, "InsertTextFormat", { enumerable: true, get: function() {
        return vscode_languageserver_types_1.InsertTextFormat;
      } });
      exports.FileChangeTypeKind = {
        Created: 1,
        Changed: 2,
        Deleted: 3
      };
      var CompletionItemKind2;
      (function(CompletionItemKind3) {
        CompletionItemKind3.Text = 1;
        CompletionItemKind3.Method = 2;
        CompletionItemKind3.Function = 3;
        CompletionItemKind3.Constructor = 4;
        CompletionItemKind3.Field = 5;
        CompletionItemKind3.Variable = 6;
        CompletionItemKind3.Class = 7;
        CompletionItemKind3.Interface = 8;
        CompletionItemKind3.Module = 9;
        CompletionItemKind3.Property = 10;
        CompletionItemKind3.Unit = 11;
        CompletionItemKind3.Value = 12;
        CompletionItemKind3.Enum = 13;
        CompletionItemKind3.Keyword = 14;
        CompletionItemKind3.Snippet = 15;
        CompletionItemKind3.Color = 16;
        CompletionItemKind3.File = 17;
        CompletionItemKind3.Reference = 18;
        CompletionItemKind3.Folder = 19;
        CompletionItemKind3.EnumMember = 20;
        CompletionItemKind3.Constant = 21;
        CompletionItemKind3.Struct = 22;
        CompletionItemKind3.Event = 23;
        CompletionItemKind3.Operator = 24;
        CompletionItemKind3.TypeParameter = 25;
      })(CompletionItemKind2 = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    }
  });

  // node_modules/graphql-language-service/dist/parser/CharacterStream.js
  var require_CharacterStream = __commonJS({
    "node_modules/graphql-language-service/dist/parser/CharacterStream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var CharacterStream = class {
        constructor(sourceText) {
          this.getStartOfToken = () => this._start;
          this.getCurrentPosition = () => this._pos;
          this.eol = () => this._sourceText.length === this._pos;
          this.sol = () => this._pos === 0;
          this.peek = () => {
            return this._sourceText.charAt(this._pos) || null;
          };
          this.next = () => {
            const char = this._sourceText.charAt(this._pos);
            this._pos++;
            return char;
          };
          this.eat = (pattern) => {
            const isMatched = this._testNextCharacter(pattern);
            if (isMatched) {
              this._start = this._pos;
              this._pos++;
              return this._sourceText.charAt(this._pos - 1);
            }
            return void 0;
          };
          this.eatWhile = (match) => {
            let isMatched = this._testNextCharacter(match);
            let didEat = false;
            if (isMatched) {
              didEat = isMatched;
              this._start = this._pos;
            }
            while (isMatched) {
              this._pos++;
              isMatched = this._testNextCharacter(match);
              didEat = true;
            }
            return didEat;
          };
          this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
          this.skipToEnd = () => {
            this._pos = this._sourceText.length;
          };
          this.skipTo = (position) => {
            this._pos = position;
          };
          this.match = (pattern, consume = true, caseFold = false) => {
            let token = null;
            let match = null;
            if (typeof pattern === "string") {
              const regex = new RegExp(pattern, caseFold ? "i" : "g");
              match = regex.test(this._sourceText.substr(this._pos, pattern.length));
              token = pattern;
            } else if (pattern instanceof RegExp) {
              match = this._sourceText.slice(this._pos).match(pattern);
              token = match === null || match === void 0 ? void 0 : match[0];
            }
            if (match != null && (typeof pattern === "string" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos))) {
              if (consume) {
                this._start = this._pos;
                if (token && token.length) {
                  this._pos += token.length;
                }
              }
              return match;
            }
            return false;
          };
          this.backUp = (num) => {
            this._pos -= num;
          };
          this.column = () => this._pos;
          this.indentation = () => {
            const match = this._sourceText.match(/\s*/);
            let indent = 0;
            if (match && match.length !== 0) {
              const whiteSpaces = match[0];
              let pos = 0;
              while (whiteSpaces.length > pos) {
                if (whiteSpaces.charCodeAt(pos) === 9) {
                  indent += 2;
                } else {
                  indent++;
                }
                pos++;
              }
            }
            return indent;
          };
          this.current = () => this._sourceText.slice(this._start, this._pos);
          this._start = 0;
          this._pos = 0;
          this._sourceText = sourceText;
        }
        _testNextCharacter(pattern) {
          const character = this._sourceText.charAt(this._pos);
          let isMatched = false;
          if (typeof pattern === "string") {
            isMatched = character === pattern;
          } else {
            isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
          }
          return isMatched;
        }
      };
      exports.default = CharacterStream;
    }
  });

  // node_modules/graphql-language-service/dist/parser/RuleHelpers.js
  var require_RuleHelpers = __commonJS({
    "node_modules/graphql-language-service/dist/parser/RuleHelpers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.p = exports.t = exports.butNot = exports.list = exports.opt = void 0;
      function opt(ofRule) {
        return { ofRule };
      }
      exports.opt = opt;
      function list(ofRule, separator) {
        return { ofRule, isList: true, separator };
      }
      exports.list = list;
      function butNot(rule, exclusions) {
        const ruleMatch = rule.match;
        rule.match = (token) => {
          let check = false;
          if (ruleMatch) {
            check = ruleMatch(token);
          }
          return check && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token));
        };
        return rule;
      }
      exports.butNot = butNot;
      function t(kind, style) {
        return { style, match: (token) => token.kind === kind };
      }
      exports.t = t;
      function p(value, style) {
        return {
          style: style || "punctuation",
          match: (token) => token.kind === "Punctuation" && token.value === value
        };
      }
      exports.p = p;
    }
  });

  // node_modules/graphql-language-service/dist/parser/Rules.js
  var require_Rules = __commonJS({
    "node_modules/graphql-language-service/dist/parser/Rules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseRules = exports.LexRules = exports.isIgnored = void 0;
      var RuleHelpers_1 = require_RuleHelpers();
      var graphql_1 = require_graphql2();
      var isIgnored = (ch) => ch === " " || ch === "	" || ch === "," || ch === "\n" || ch === "\r" || ch === "\uFEFF" || ch === "\xA0";
      exports.isIgnored = isIgnored;
      exports.LexRules = {
        Name: /^[_A-Za-z][_0-9A-Za-z]*/,
        Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
        Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
        String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
        Comment: /^#.*/
      };
      exports.ParseRules = {
        Document: [(0, RuleHelpers_1.list)("Definition")],
        Definition(token) {
          switch (token.value) {
            case "{":
              return "ShortQuery";
            case "query":
              return "Query";
            case "mutation":
              return "Mutation";
            case "subscription":
              return "Subscription";
            case "fragment":
              return graphql_1.Kind.FRAGMENT_DEFINITION;
            case "schema":
              return "SchemaDef";
            case "scalar":
              return "ScalarDef";
            case "type":
              return "ObjectTypeDef";
            case "interface":
              return "InterfaceDef";
            case "union":
              return "UnionDef";
            case "enum":
              return "EnumDef";
            case "input":
              return "InputDef";
            case "extend":
              return "ExtendDef";
            case "directive":
              return "DirectiveDef";
          }
        },
        ShortQuery: ["SelectionSet"],
        Query: [
          word("query"),
          (0, RuleHelpers_1.opt)(name("def")),
          (0, RuleHelpers_1.opt)("VariableDefinitions"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        Mutation: [
          word("mutation"),
          (0, RuleHelpers_1.opt)(name("def")),
          (0, RuleHelpers_1.opt)("VariableDefinitions"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        Subscription: [
          word("subscription"),
          (0, RuleHelpers_1.opt)(name("def")),
          (0, RuleHelpers_1.opt)("VariableDefinitions"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        VariableDefinitions: [(0, RuleHelpers_1.p)("("), (0, RuleHelpers_1.list)("VariableDefinition"), (0, RuleHelpers_1.p)(")")],
        VariableDefinition: ["Variable", (0, RuleHelpers_1.p)(":"), "Type", (0, RuleHelpers_1.opt)("DefaultValue")],
        Variable: [(0, RuleHelpers_1.p)("$", "variable"), name("variable")],
        DefaultValue: [(0, RuleHelpers_1.p)("="), "Value"],
        SelectionSet: [(0, RuleHelpers_1.p)("{"), (0, RuleHelpers_1.list)("Selection"), (0, RuleHelpers_1.p)("}")],
        Selection(token, stream) {
          return token.value === "..." ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? "InlineFragment" : "FragmentSpread" : stream.match(/[\s\u00a0,]*:/, false) ? "AliasedField" : "Field";
        },
        AliasedField: [
          name("property"),
          (0, RuleHelpers_1.p)(":"),
          name("qualifier"),
          (0, RuleHelpers_1.opt)("Arguments"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.opt)("SelectionSet")
        ],
        Field: [
          name("property"),
          (0, RuleHelpers_1.opt)("Arguments"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.opt)("SelectionSet")
        ],
        Arguments: [(0, RuleHelpers_1.p)("("), (0, RuleHelpers_1.list)("Argument"), (0, RuleHelpers_1.p)(")")],
        Argument: [name("attribute"), (0, RuleHelpers_1.p)(":"), "Value"],
        FragmentSpread: [(0, RuleHelpers_1.p)("..."), name("def"), (0, RuleHelpers_1.list)("Directive")],
        InlineFragment: [
          (0, RuleHelpers_1.p)("..."),
          (0, RuleHelpers_1.opt)("TypeCondition"),
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        FragmentDefinition: [
          word("fragment"),
          (0, RuleHelpers_1.opt)((0, RuleHelpers_1.butNot)(name("def"), [word("on")])),
          "TypeCondition",
          (0, RuleHelpers_1.list)("Directive"),
          "SelectionSet"
        ],
        TypeCondition: [word("on"), "NamedType"],
        Value(token) {
          switch (token.kind) {
            case "Number":
              return "NumberValue";
            case "String":
              return "StringValue";
            case "Punctuation":
              switch (token.value) {
                case "[":
                  return "ListValue";
                case "{":
                  return "ObjectValue";
                case "$":
                  return "Variable";
                case "&":
                  return "NamedType";
              }
              return null;
            case "Name":
              switch (token.value) {
                case "true":
                case "false":
                  return "BooleanValue";
              }
              if (token.value === "null") {
                return "NullValue";
              }
              return "EnumValue";
          }
        },
        NumberValue: [(0, RuleHelpers_1.t)("Number", "number")],
        StringValue: [
          {
            style: "string",
            match: (token) => token.kind === "String",
            update(state, token) {
              if (token.value.startsWith('"""')) {
                state.inBlockstring = !token.value.slice(3).endsWith('"""');
              }
            }
          }
        ],
        BooleanValue: [(0, RuleHelpers_1.t)("Name", "builtin")],
        NullValue: [(0, RuleHelpers_1.t)("Name", "keyword")],
        EnumValue: [name("string-2")],
        ListValue: [(0, RuleHelpers_1.p)("["), (0, RuleHelpers_1.list)("Value"), (0, RuleHelpers_1.p)("]")],
        ObjectValue: [(0, RuleHelpers_1.p)("{"), (0, RuleHelpers_1.list)("ObjectField"), (0, RuleHelpers_1.p)("}")],
        ObjectField: [name("attribute"), (0, RuleHelpers_1.p)(":"), "Value"],
        Type(token) {
          return token.value === "[" ? "ListType" : "NonNullType";
        },
        ListType: [(0, RuleHelpers_1.p)("["), "Type", (0, RuleHelpers_1.p)("]"), (0, RuleHelpers_1.opt)((0, RuleHelpers_1.p)("!"))],
        NonNullType: ["NamedType", (0, RuleHelpers_1.opt)((0, RuleHelpers_1.p)("!"))],
        NamedType: [type("atom")],
        Directive: [(0, RuleHelpers_1.p)("@", "meta"), name("meta"), (0, RuleHelpers_1.opt)("Arguments")],
        DirectiveDef: [
          word("directive"),
          (0, RuleHelpers_1.p)("@", "meta"),
          name("meta"),
          (0, RuleHelpers_1.opt)("ArgumentsDef"),
          word("on"),
          (0, RuleHelpers_1.list)("DirectiveLocation", (0, RuleHelpers_1.p)("|"))
        ],
        InterfaceDef: [
          word("interface"),
          name("atom"),
          (0, RuleHelpers_1.opt)("Implements"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("FieldDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        Implements: [word("implements"), (0, RuleHelpers_1.list)("NamedType", (0, RuleHelpers_1.p)("&"))],
        DirectiveLocation: [name("string-2")],
        SchemaDef: [
          word("schema"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("OperationTypeDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        OperationTypeDef: [name("keyword"), (0, RuleHelpers_1.p)(":"), name("atom")],
        ScalarDef: [word("scalar"), name("atom"), (0, RuleHelpers_1.list)("Directive")],
        ObjectTypeDef: [
          word("type"),
          name("atom"),
          (0, RuleHelpers_1.opt)("Implements"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("FieldDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        FieldDef: [
          name("property"),
          (0, RuleHelpers_1.opt)("ArgumentsDef"),
          (0, RuleHelpers_1.p)(":"),
          "Type",
          (0, RuleHelpers_1.list)("Directive")
        ],
        ArgumentsDef: [(0, RuleHelpers_1.p)("("), (0, RuleHelpers_1.list)("InputValueDef"), (0, RuleHelpers_1.p)(")")],
        InputValueDef: [
          name("attribute"),
          (0, RuleHelpers_1.p)(":"),
          "Type",
          (0, RuleHelpers_1.opt)("DefaultValue"),
          (0, RuleHelpers_1.list)("Directive")
        ],
        UnionDef: [
          word("union"),
          name("atom"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("="),
          (0, RuleHelpers_1.list)("UnionMember", (0, RuleHelpers_1.p)("|"))
        ],
        UnionMember: ["NamedType"],
        EnumDef: [
          word("enum"),
          name("atom"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("EnumValueDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        EnumValueDef: [name("string-2"), (0, RuleHelpers_1.list)("Directive")],
        InputDef: [
          word("input"),
          name("atom"),
          (0, RuleHelpers_1.list)("Directive"),
          (0, RuleHelpers_1.p)("{"),
          (0, RuleHelpers_1.list)("InputValueDef"),
          (0, RuleHelpers_1.p)("}")
        ],
        ExtendDef: [word("extend"), "ExtensionDefinition"],
        ExtensionDefinition(token) {
          switch (token.value) {
            case "schema":
              return graphql_1.Kind.SCHEMA_EXTENSION;
            case "scalar":
              return graphql_1.Kind.SCALAR_TYPE_EXTENSION;
            case "type":
              return graphql_1.Kind.OBJECT_TYPE_EXTENSION;
            case "interface":
              return graphql_1.Kind.INTERFACE_TYPE_EXTENSION;
            case "union":
              return graphql_1.Kind.UNION_TYPE_EXTENSION;
            case "enum":
              return graphql_1.Kind.ENUM_TYPE_EXTENSION;
            case "input":
              return graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION;
          }
        },
        [graphql_1.Kind.SCHEMA_EXTENSION]: ["SchemaDef"],
        [graphql_1.Kind.SCALAR_TYPE_EXTENSION]: ["ScalarDef"],
        [graphql_1.Kind.OBJECT_TYPE_EXTENSION]: ["ObjectTypeDef"],
        [graphql_1.Kind.INTERFACE_TYPE_EXTENSION]: ["InterfaceDef"],
        [graphql_1.Kind.UNION_TYPE_EXTENSION]: ["UnionDef"],
        [graphql_1.Kind.ENUM_TYPE_EXTENSION]: ["EnumDef"],
        [graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION]: ["InputDef"]
      };
      function word(value) {
        return {
          style: "keyword",
          match: (token) => token.kind === "Name" && token.value === value
        };
      }
      function name(style) {
        return {
          style,
          match: (token) => token.kind === "Name",
          update(state, token) {
            state.name = token.value;
          }
        };
      }
      function type(style) {
        return {
          style,
          match: (token) => token.kind === "Name",
          update(state, token) {
            var _a3;
            if ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.prevState) {
              state.name = token.value;
              state.prevState.prevState.type = token.value;
            }
          }
        };
      }
    }
  });

  // node_modules/graphql-language-service/dist/parser/onlineParser.js
  var require_onlineParser = __commonJS({
    "node_modules/graphql-language-service/dist/parser/onlineParser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Rules_1 = require_Rules();
      var graphql_1 = require_graphql2();
      function onlineParser(options = {
        eatWhitespace: (stream) => stream.eatWhile(Rules_1.isIgnored),
        lexRules: Rules_1.LexRules,
        parseRules: Rules_1.ParseRules,
        editorConfig: {}
      }) {
        return {
          startState() {
            const initialState = {
              level: 0,
              step: 0,
              name: null,
              kind: null,
              type: null,
              rule: null,
              needsSeparator: false,
              prevState: null
            };
            pushRule(options.parseRules, initialState, graphql_1.Kind.DOCUMENT);
            return initialState;
          },
          token(stream, state) {
            return getToken(stream, state, options);
          }
        };
      }
      exports.default = onlineParser;
      function getToken(stream, state, options) {
        var _a3;
        if (state.inBlockstring) {
          if (stream.match(/.*"""/)) {
            state.inBlockstring = false;
            return "string";
          }
          stream.skipToEnd();
          return "string";
        }
        const { lexRules, parseRules, eatWhitespace, editorConfig } = options;
        if (state.rule && state.rule.length === 0) {
          popRule(state);
        } else if (state.needsAdvance) {
          state.needsAdvance = false;
          advanceRule(state, true);
        }
        if (stream.sol()) {
          const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;
          state.indentLevel = Math.floor(stream.indentation() / tabSize);
        }
        if (eatWhitespace(stream)) {
          return "ws";
        }
        const token = lex(lexRules, stream);
        if (!token) {
          const matchedSomething = stream.match(/\S+/);
          if (!matchedSomething) {
            stream.match(/\s/);
          }
          pushRule(SpecialParseRules, state, "Invalid");
          return "invalidchar";
        }
        if (token.kind === "Comment") {
          pushRule(SpecialParseRules, state, "Comment");
          return "comment";
        }
        const backupState = assign({}, state);
        if (token.kind === "Punctuation") {
          if (/^[{([]/.test(token.value)) {
            if (state.indentLevel !== void 0) {
              state.levels = (state.levels || []).concat(state.indentLevel + 1);
            }
          } else if (/^[})\]]/.test(token.value)) {
            const levels = state.levels = (state.levels || []).slice(0, -1);
            if (state.indentLevel && levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {
              state.indentLevel = levels[levels.length - 1];
            }
          }
        }
        while (state.rule) {
          let expected = typeof state.rule === "function" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];
          if (state.needsSeparator) {
            expected = expected === null || expected === void 0 ? void 0 : expected.separator;
          }
          if (expected) {
            if (expected.ofRule) {
              expected = expected.ofRule;
            }
            if (typeof expected === "string") {
              pushRule(parseRules, state, expected);
              continue;
            }
            if ((_a3 = expected.match) === null || _a3 === void 0 ? void 0 : _a3.call(expected, token)) {
              if (expected.update) {
                expected.update(state, token);
              }
              if (token.kind === "Punctuation") {
                advanceRule(state, true);
              } else {
                state.needsAdvance = true;
              }
              return expected.style;
            }
          }
          unsuccessful(state);
        }
        assign(state, backupState);
        pushRule(SpecialParseRules, state, "Invalid");
        return "invalidchar";
      }
      function assign(to, from) {
        const keys = Object.keys(from);
        for (let i = 0; i < keys.length; i++) {
          to[keys[i]] = from[keys[i]];
        }
        return to;
      }
      var SpecialParseRules = {
        Invalid: [],
        Comment: []
      };
      function pushRule(rules, state, ruleKind) {
        if (!rules[ruleKind]) {
          throw new TypeError("Unknown rule: " + ruleKind);
        }
        state.prevState = Object.assign({}, state);
        state.kind = ruleKind;
        state.name = null;
        state.type = null;
        state.rule = rules[ruleKind];
        state.step = 0;
        state.needsSeparator = false;
      }
      function popRule(state) {
        if (!state.prevState) {
          return;
        }
        state.kind = state.prevState.kind;
        state.name = state.prevState.name;
        state.type = state.prevState.type;
        state.rule = state.prevState.rule;
        state.step = state.prevState.step;
        state.needsSeparator = state.prevState.needsSeparator;
        state.prevState = state.prevState.prevState;
      }
      function advanceRule(state, successful) {
        var _a3;
        if (isList(state) && state.rule) {
          const step = state.rule[state.step];
          if (step.separator) {
            const { separator } = step;
            state.needsSeparator = !state.needsSeparator;
            if (!state.needsSeparator && separator.ofRule) {
              return;
            }
          }
          if (successful) {
            return;
          }
        }
        state.needsSeparator = false;
        state.step++;
        while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {
          popRule(state);
          if (state.rule) {
            if (isList(state)) {
              if ((_a3 = state.rule) === null || _a3 === void 0 ? void 0 : _a3[state.step].separator) {
                state.needsSeparator = !state.needsSeparator;
              }
            } else {
              state.needsSeparator = false;
              state.step++;
            }
          }
        }
      }
      function isList(state) {
        const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== "string" && state.rule[state.step];
        return step && step.isList;
      }
      function unsuccessful(state) {
        while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {
          popRule(state);
        }
        if (state.rule) {
          advanceRule(state, false);
        }
      }
      function lex(lexRules, stream) {
        const kinds = Object.keys(lexRules);
        for (let i = 0; i < kinds.length; i++) {
          const match = stream.match(lexRules[kinds[i]]);
          if (match && match instanceof Array) {
            return { kind: kinds[i], value: match[0] };
          }
        }
      }
    }
  });

  // node_modules/graphql-language-service/dist/parser/types.js
  var require_types2 = __commonJS({
    "node_modules/graphql-language-service/dist/parser/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RuleKinds = exports.AdditionalRuleKinds = void 0;
      var graphql_1 = require_graphql2();
      exports.AdditionalRuleKinds = {
        ALIASED_FIELD: "AliasedField",
        ARGUMENTS: "Arguments",
        SHORT_QUERY: "ShortQuery",
        QUERY: "Query",
        MUTATION: "Mutation",
        SUBSCRIPTION: "Subscription",
        TYPE_CONDITION: "TypeCondition",
        INVALID: "Invalid",
        COMMENT: "Comment",
        SCHEMA_DEF: "SchemaDef",
        SCALAR_DEF: "ScalarDef",
        OBJECT_TYPE_DEF: "ObjectTypeDef",
        OBJECT_VALUE: "ObjectValue",
        LIST_VALUE: "ListValue",
        INTERFACE_DEF: "InterfaceDef",
        UNION_DEF: "UnionDef",
        ENUM_DEF: "EnumDef",
        ENUM_VALUE: "EnumValue",
        FIELD_DEF: "FieldDef",
        INPUT_DEF: "InputDef",
        INPUT_VALUE_DEF: "InputValueDef",
        ARGUMENTS_DEF: "ArgumentsDef",
        EXTEND_DEF: "ExtendDef",
        EXTENSION_DEFINITION: "ExtensionDefinition",
        DIRECTIVE_DEF: "DirectiveDef",
        IMPLEMENTS: "Implements",
        VARIABLE_DEFINITIONS: "VariableDefinitions",
        TYPE: "Type"
      };
      exports.RuleKinds = Object.assign(Object.assign({}, graphql_1.Kind), exports.AdditionalRuleKinds);
    }
  });

  // node_modules/graphql-language-service/dist/parser/index.js
  var require_parser2 = __commonJS({
    "node_modules/graphql-language-service/dist/parser/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onlineParser = exports.t = exports.p = exports.opt = exports.list = exports.butNot = exports.isIgnored = exports.ParseRules = exports.LexRules = exports.CharacterStream = void 0;
      var CharacterStream_1 = require_CharacterStream();
      Object.defineProperty(exports, "CharacterStream", { enumerable: true, get: function() {
        return __importDefault(CharacterStream_1).default;
      } });
      var Rules_1 = require_Rules();
      Object.defineProperty(exports, "LexRules", { enumerable: true, get: function() {
        return Rules_1.LexRules;
      } });
      Object.defineProperty(exports, "ParseRules", { enumerable: true, get: function() {
        return Rules_1.ParseRules;
      } });
      Object.defineProperty(exports, "isIgnored", { enumerable: true, get: function() {
        return Rules_1.isIgnored;
      } });
      var RuleHelpers_1 = require_RuleHelpers();
      Object.defineProperty(exports, "butNot", { enumerable: true, get: function() {
        return RuleHelpers_1.butNot;
      } });
      Object.defineProperty(exports, "list", { enumerable: true, get: function() {
        return RuleHelpers_1.list;
      } });
      Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
        return RuleHelpers_1.opt;
      } });
      Object.defineProperty(exports, "p", { enumerable: true, get: function() {
        return RuleHelpers_1.p;
      } });
      Object.defineProperty(exports, "t", { enumerable: true, get: function() {
        return RuleHelpers_1.t;
      } });
      var onlineParser_1 = require_onlineParser();
      Object.defineProperty(exports, "onlineParser", { enumerable: true, get: function() {
        return __importDefault(onlineParser_1).default;
      } });
      __exportStar(require_types2(), exports);
    }
  });

  // node_modules/graphql-language-service/dist/interface/getAutocompleteSuggestions.js
  var require_getAutocompleteSuggestions = __commonJS({
    "node_modules/graphql-language-service/dist/interface/getAutocompleteSuggestions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GraphQLDocumentMode = exports.getTypeInfo = exports.canUseDirective = exports.runOnlineParser = exports.getTokenAtPosition = exports.getFragmentDefinitions = exports.getVariableCompletions = exports.getAutocompleteSuggestions = exports.SuggestionCommand = void 0;
      var graphql_1 = require_graphql2();
      var types_1 = require_types();
      var parser_1 = require_parser2();
      var autocompleteUtils_1 = require_autocompleteUtils();
      exports.SuggestionCommand = {
        command: "editor.action.triggerSuggest",
        title: "Suggestions"
      };
      var collectFragmentDefs = (op) => {
        const externalFragments = [];
        if (op) {
          try {
            (0, graphql_1.visit)((0, graphql_1.parse)(op), {
              FragmentDefinition(def) {
                externalFragments.push(def);
              }
            });
          } catch (_a3) {
            return [];
          }
        }
        return externalFragments;
      };
      var typeSystemKinds = [
        graphql_1.Kind.SCHEMA_DEFINITION,
        graphql_1.Kind.OPERATION_TYPE_DEFINITION,
        graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        graphql_1.Kind.UNION_TYPE_DEFINITION,
        graphql_1.Kind.ENUM_TYPE_DEFINITION,
        graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        graphql_1.Kind.DIRECTIVE_DEFINITION,
        graphql_1.Kind.SCHEMA_EXTENSION,
        graphql_1.Kind.SCALAR_TYPE_EXTENSION,
        graphql_1.Kind.OBJECT_TYPE_EXTENSION,
        graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
        graphql_1.Kind.UNION_TYPE_EXTENSION,
        graphql_1.Kind.ENUM_TYPE_EXTENSION,
        graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION
      ];
      var hasTypeSystemDefinitions = (sdl) => {
        let hasTypeSystemDef = false;
        if (sdl) {
          try {
            (0, graphql_1.visit)((0, graphql_1.parse)(sdl), {
              enter(node) {
                if (node.kind === "Document") {
                  return;
                }
                if (typeSystemKinds.includes(node.kind)) {
                  hasTypeSystemDef = true;
                  return graphql_1.BREAK;
                }
                return false;
              }
            });
          } catch (_a3) {
            return hasTypeSystemDef;
          }
        }
        return hasTypeSystemDef;
      };
      function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {
        var _a3;
        const opts = Object.assign(Object.assign({}, options), { schema });
        const token = contextToken || getTokenAtPosition(queryText, cursor);
        const state = token.state.kind === "Invalid" ? token.state.prevState : token.state;
        const mode = (options === null || options === void 0 ? void 0 : options.mode) || getDocumentMode(queryText, options === null || options === void 0 ? void 0 : options.uri);
        if (!state) {
          return [];
        }
        const { kind, step, prevState } = state;
        const typeInfo = getTypeInfo(schema, token.state);
        if (kind === parser_1.RuleKinds.DOCUMENT) {
          if (mode === GraphQLDocumentMode.TYPE_SYSTEM) {
            return getSuggestionsForTypeSystemDefinitions(token);
          }
          return getSuggestionsForExecutableDefinitions(token);
        }
        if (kind === parser_1.RuleKinds.EXTEND_DEF) {
          return getSuggestionsForExtensionDefinitions(token);
        }
        if (((_a3 = prevState === null || prevState === void 0 ? void 0 : prevState.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === parser_1.RuleKinds.EXTENSION_DEFINITION && state.name) {
          return (0, autocompleteUtils_1.hintList)(token, []);
        }
        if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === graphql_1.Kind.SCALAR_TYPE_EXTENSION) {
          return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter(graphql_1.isScalarType).map((type) => ({
            label: type.name,
            kind: types_1.CompletionItemKind.Function
          })));
        }
        if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
          return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter((type) => (0, graphql_1.isObjectType)(type) && !type.name.startsWith("__")).map((type) => ({
            label: type.name,
            kind: types_1.CompletionItemKind.Function
          })));
        }
        if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === graphql_1.Kind.INTERFACE_TYPE_EXTENSION) {
          return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).map((type) => ({
            label: type.name,
            kind: types_1.CompletionItemKind.Function
          })));
        }
        if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === graphql_1.Kind.UNION_TYPE_EXTENSION) {
          return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter(graphql_1.isUnionType).map((type) => ({
            label: type.name,
            kind: types_1.CompletionItemKind.Function
          })));
        }
        if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === graphql_1.Kind.ENUM_TYPE_EXTENSION) {
          return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter((type) => (0, graphql_1.isEnumType)(type) && !type.name.startsWith("__")).map((type) => ({
            label: type.name,
            kind: types_1.CompletionItemKind.Function
          })));
        }
        if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {
          return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter(graphql_1.isInputObjectType).map((type) => ({
            label: type.name,
            kind: types_1.CompletionItemKind.Function
          })));
        }
        if (kind === parser_1.RuleKinds.IMPLEMENTS || kind === parser_1.RuleKinds.NAMED_TYPE && (prevState === null || prevState === void 0 ? void 0 : prevState.kind) === parser_1.RuleKinds.IMPLEMENTS) {
          return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);
        }
        if (kind === parser_1.RuleKinds.SELECTION_SET || kind === parser_1.RuleKinds.FIELD || kind === parser_1.RuleKinds.ALIASED_FIELD) {
          return getSuggestionsForFieldNames(token, typeInfo, opts);
        }
        if (kind === parser_1.RuleKinds.ARGUMENTS || kind === parser_1.RuleKinds.ARGUMENT && step === 0) {
          const { argDefs } = typeInfo;
          if (argDefs) {
            return (0, autocompleteUtils_1.hintList)(token, argDefs.map((argDef) => {
              var _a4;
              return {
                label: argDef.name,
                insertText: argDef.name + ": ",
                command: exports.SuggestionCommand,
                detail: String(argDef.type),
                documentation: (_a4 = argDef.description) !== null && _a4 !== void 0 ? _a4 : void 0,
                kind: types_1.CompletionItemKind.Variable,
                type: argDef.type
              };
            }));
          }
        }
        if ((kind === parser_1.RuleKinds.OBJECT_VALUE || kind === parser_1.RuleKinds.OBJECT_FIELD && step === 0) && typeInfo.objectFieldDefs) {
          const objectFields = (0, autocompleteUtils_1.objectValues)(typeInfo.objectFieldDefs);
          const completionKind = kind === parser_1.RuleKinds.OBJECT_VALUE ? types_1.CompletionItemKind.Value : types_1.CompletionItemKind.Field;
          return (0, autocompleteUtils_1.hintList)(token, objectFields.map((field) => {
            var _a4;
            return {
              label: field.name,
              detail: String(field.type),
              documentation: (_a4 = field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
              kind: completionKind,
              type: field.type
            };
          }));
        }
        if (kind === parser_1.RuleKinds.ENUM_VALUE || kind === parser_1.RuleKinds.LIST_VALUE && step === 1 || kind === parser_1.RuleKinds.OBJECT_FIELD && step === 2 || kind === parser_1.RuleKinds.ARGUMENT && step === 2) {
          return getSuggestionsForInputValues(token, typeInfo, queryText, schema);
        }
        if (kind === parser_1.RuleKinds.VARIABLE && step === 1) {
          const namedInputType = (0, graphql_1.getNamedType)(typeInfo.inputType);
          const variableDefinitions = getVariableCompletions(queryText, schema, token);
          return (0, autocompleteUtils_1.hintList)(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));
        }
        if (kind === parser_1.RuleKinds.TYPE_CONDITION && step === 1 || kind === parser_1.RuleKinds.NAMED_TYPE && prevState != null && prevState.kind === parser_1.RuleKinds.TYPE_CONDITION) {
          return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);
        }
        if (kind === parser_1.RuleKinds.FRAGMENT_SPREAD && step === 1) {
          return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));
        }
        const unwrappedState = unwrapType(state);
        if (mode === GraphQLDocumentMode.TYPE_SYSTEM && !unwrappedState.needsAdvance && kind === parser_1.RuleKinds.NAMED_TYPE || kind === parser_1.RuleKinds.LIST_TYPE) {
          if (unwrappedState.kind === parser_1.RuleKinds.FIELD_DEF) {
            return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter((type) => (0, graphql_1.isOutputType)(type) && !type.name.startsWith("__")).map((type) => ({
              label: type.name,
              kind: types_1.CompletionItemKind.Function
            })));
          }
          if (unwrappedState.kind === parser_1.RuleKinds.INPUT_VALUE_DEF) {
            return (0, autocompleteUtils_1.hintList)(token, Object.values(schema.getTypeMap()).filter((type) => (0, graphql_1.isInputType)(type) && !type.name.startsWith("__")).map((type) => ({
              label: type.name,
              kind: types_1.CompletionItemKind.Function
            })));
          }
        }
        if (kind === parser_1.RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === parser_1.RuleKinds.LIST_TYPE && step === 1 || kind === parser_1.RuleKinds.NAMED_TYPE && prevState && (prevState.kind === parser_1.RuleKinds.VARIABLE_DEFINITION || prevState.kind === parser_1.RuleKinds.LIST_TYPE || prevState.kind === parser_1.RuleKinds.NON_NULL_TYPE)) {
          return getSuggestionsForVariableDefinition(token, schema, kind);
        }
        if (kind === parser_1.RuleKinds.DIRECTIVE) {
          return getSuggestionsForDirective(token, state, schema, kind);
        }
        return [];
      }
      exports.getAutocompleteSuggestions = getAutocompleteSuggestions;
      var insertSuffix = ` {
  $1
}`;
      var getInsertText = (field) => {
        const { type } = field;
        if ((0, graphql_1.isCompositeType)(type)) {
          return insertSuffix;
        }
        if ((0, graphql_1.isListType)(type) && (0, graphql_1.isCompositeType)(type.ofType)) {
          return insertSuffix;
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          if ((0, graphql_1.isCompositeType)(type.ofType)) {
            return insertSuffix;
          }
          if ((0, graphql_1.isListType)(type.ofType) && (0, graphql_1.isCompositeType)(type.ofType.ofType)) {
            return insertSuffix;
          }
        }
        return null;
      };
      function getSuggestionsForTypeSystemDefinitions(token) {
        return (0, autocompleteUtils_1.hintList)(token, [
          { label: "extend", kind: types_1.CompletionItemKind.Function },
          { label: "type", kind: types_1.CompletionItemKind.Function },
          { label: "interface", kind: types_1.CompletionItemKind.Function },
          { label: "union", kind: types_1.CompletionItemKind.Function },
          { label: "input", kind: types_1.CompletionItemKind.Function },
          { label: "scalar", kind: types_1.CompletionItemKind.Function },
          { label: "schema", kind: types_1.CompletionItemKind.Function }
        ]);
      }
      function getSuggestionsForExecutableDefinitions(token) {
        return (0, autocompleteUtils_1.hintList)(token, [
          { label: "query", kind: types_1.CompletionItemKind.Function },
          { label: "mutation", kind: types_1.CompletionItemKind.Function },
          { label: "subscription", kind: types_1.CompletionItemKind.Function },
          { label: "fragment", kind: types_1.CompletionItemKind.Function },
          { label: "{", kind: types_1.CompletionItemKind.Constructor }
        ]);
      }
      function getSuggestionsForExtensionDefinitions(token) {
        return (0, autocompleteUtils_1.hintList)(token, [
          { label: "type", kind: types_1.CompletionItemKind.Function },
          { label: "interface", kind: types_1.CompletionItemKind.Function },
          { label: "union", kind: types_1.CompletionItemKind.Function },
          { label: "input", kind: types_1.CompletionItemKind.Function },
          { label: "scalar", kind: types_1.CompletionItemKind.Function },
          { label: "schema", kind: types_1.CompletionItemKind.Function }
        ]);
      }
      function getSuggestionsForFieldNames(token, typeInfo, options) {
        var _a3;
        if (typeInfo.parentType) {
          const { parentType } = typeInfo;
          let fields = [];
          if ("getFields" in parentType) {
            fields = (0, autocompleteUtils_1.objectValues)(parentType.getFields());
          }
          if ((0, graphql_1.isCompositeType)(parentType)) {
            fields.push(graphql_1.TypeNameMetaFieldDef);
          }
          if (parentType === ((_a3 = options === null || options === void 0 ? void 0 : options.schema) === null || _a3 === void 0 ? void 0 : _a3.getQueryType())) {
            fields.push(graphql_1.SchemaMetaFieldDef, graphql_1.TypeMetaFieldDef);
          }
          return (0, autocompleteUtils_1.hintList)(token, fields.map((field, index) => {
            var _a4;
            const suggestion = {
              sortText: String(index) + field.name,
              label: field.name,
              detail: String(field.type),
              documentation: (_a4 = field.description) !== null && _a4 !== void 0 ? _a4 : void 0,
              deprecated: Boolean(field.deprecationReason),
              isDeprecated: Boolean(field.deprecationReason),
              deprecationReason: field.deprecationReason,
              kind: types_1.CompletionItemKind.Field,
              type: field.type
            };
            if (options === null || options === void 0 ? void 0 : options.fillLeafsOnComplete) {
              const insertText = getInsertText(field);
              if (insertText) {
                suggestion.insertText = field.name + insertText;
                suggestion.insertTextFormat = types_1.InsertTextFormat.Snippet;
                suggestion.command = exports.SuggestionCommand;
              }
            }
            return suggestion;
          }));
        }
        return [];
      }
      function getSuggestionsForInputValues(token, typeInfo, queryText, schema) {
        const namedInputType = (0, graphql_1.getNamedType)(typeInfo.inputType);
        const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);
        if (namedInputType instanceof graphql_1.GraphQLEnumType) {
          const values = namedInputType.getValues();
          return (0, autocompleteUtils_1.hintList)(token, values.map((value) => {
            var _a3;
            return {
              label: value.name,
              detail: String(namedInputType),
              documentation: (_a3 = value.description) !== null && _a3 !== void 0 ? _a3 : void 0,
              deprecated: Boolean(value.deprecationReason),
              isDeprecated: Boolean(value.deprecationReason),
              deprecationReason: value.deprecationReason,
              kind: types_1.CompletionItemKind.EnumMember,
              type: namedInputType
            };
          }).concat(queryVariables));
        }
        if (namedInputType === graphql_1.GraphQLBoolean) {
          return (0, autocompleteUtils_1.hintList)(token, queryVariables.concat([
            {
              label: "true",
              detail: String(graphql_1.GraphQLBoolean),
              documentation: "Not false.",
              kind: types_1.CompletionItemKind.Variable,
              type: graphql_1.GraphQLBoolean
            },
            {
              label: "false",
              detail: String(graphql_1.GraphQLBoolean),
              documentation: "Not true.",
              kind: types_1.CompletionItemKind.Variable,
              type: graphql_1.GraphQLBoolean
            }
          ]));
        }
        return queryVariables;
      }
      function getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {
        if (tokenState.needsSeparator) {
          return [];
        }
        const typeMap = schema.getTypeMap();
        const schemaInterfaces = (0, autocompleteUtils_1.objectValues)(typeMap).filter(graphql_1.isInterfaceType);
        const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);
        const inlineInterfaces = /* @__PURE__ */ new Set();
        runOnlineParser(documentText, (_, state) => {
          var _a3, _b, _c, _d, _e;
          if (state.name) {
            if (state.kind === parser_1.RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {
              inlineInterfaces.add(state.name);
            }
            if (state.kind === parser_1.RuleKinds.NAMED_TYPE && ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === parser_1.RuleKinds.IMPLEMENTS) {
              if (typeInfo.interfaceDef) {
                const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);
                if (existingType) {
                  return;
                }
                const type = schema.getType(state.name);
                const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();
                typeInfo.interfaceDef = new graphql_1.GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [
                  ...interfaceConfig.interfaces,
                  type || new graphql_1.GraphQLInterfaceType({ name: state.name, fields: {} })
                ] }));
              } else if (typeInfo.objectTypeDef) {
                const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);
                if (existingType) {
                  return;
                }
                const type = schema.getType(state.name);
                const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();
                typeInfo.objectTypeDef = new graphql_1.GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [
                  ...objectTypeConfig.interfaces,
                  type || new graphql_1.GraphQLInterfaceType({ name: state.name, fields: {} })
                ] }));
              }
            }
          }
        });
        const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;
        const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];
        const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);
        const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));
        return (0, autocompleteUtils_1.hintList)(token, possibleInterfaces.map((type) => {
          const result = {
            label: type.name,
            kind: types_1.CompletionItemKind.Interface,
            type
          };
          if (type === null || type === void 0 ? void 0 : type.description) {
            result.documentation = type.description;
          }
          return result;
        }));
      }
      function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {
        let possibleTypes;
        if (typeInfo.parentType) {
          if ((0, graphql_1.isAbstractType)(typeInfo.parentType)) {
            const abstractType = (0, graphql_1.assertAbstractType)(typeInfo.parentType);
            const possibleObjTypes = schema.getPossibleTypes(abstractType);
            const possibleIfaceMap = /* @__PURE__ */ Object.create(null);
            possibleObjTypes.forEach((type) => {
              type.getInterfaces().forEach((iface) => {
                possibleIfaceMap[iface.name] = iface;
              });
            });
            possibleTypes = possibleObjTypes.concat((0, autocompleteUtils_1.objectValues)(possibleIfaceMap));
          } else {
            possibleTypes = [typeInfo.parentType];
          }
        } else {
          const typeMap = schema.getTypeMap();
          possibleTypes = (0, autocompleteUtils_1.objectValues)(typeMap).filter((type) => (0, graphql_1.isCompositeType)(type) && !type.name.startsWith("__"));
        }
        return (0, autocompleteUtils_1.hintList)(token, possibleTypes.map((type) => {
          const namedType = (0, graphql_1.getNamedType)(type);
          return {
            label: String(type),
            documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || "",
            kind: types_1.CompletionItemKind.Field
          };
        }));
      }
      function getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {
        if (!queryText) {
          return [];
        }
        const typeMap = schema.getTypeMap();
        const defState = (0, autocompleteUtils_1.getDefinitionState)(token.state);
        const fragments = getFragmentDefinitions(queryText);
        if (fragmentDefs && fragmentDefs.length > 0) {
          fragments.push(...fragmentDefs);
        }
        const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === parser_1.RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && (0, graphql_1.isCompositeType)(typeInfo.parentType) && (0, graphql_1.isCompositeType)(typeMap[frag.typeCondition.name.value]) && (0, graphql_1.doTypesOverlap)(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));
        return (0, autocompleteUtils_1.hintList)(token, relevantFrags.map((frag) => ({
          label: frag.name.value,
          detail: String(typeMap[frag.typeCondition.name.value]),
          documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,
          kind: types_1.CompletionItemKind.Field,
          type: typeMap[frag.typeCondition.name.value]
        })));
      }
      var getParentDefinition = (state, kind) => {
        var _a3, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) === kind) {
          return state.prevState;
        }
        if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {
          return state.prevState.prevState;
        }
        if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {
          return state.prevState.prevState.prevState;
        }
        if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {
          return state.prevState.prevState.prevState.prevState;
        }
      };
      function getVariableCompletions(queryText, schema, token) {
        let variableName = null;
        let variableType;
        const definitions = /* @__PURE__ */ Object.create({});
        runOnlineParser(queryText, (_, state) => {
          if ((state === null || state === void 0 ? void 0 : state.kind) === parser_1.RuleKinds.VARIABLE && state.name) {
            variableName = state.name;
          }
          if ((state === null || state === void 0 ? void 0 : state.kind) === parser_1.RuleKinds.NAMED_TYPE && variableName) {
            const parentDefinition = getParentDefinition(state, parser_1.RuleKinds.TYPE);
            if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {
              variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);
            }
          }
          if (variableName && variableType && !definitions[variableName]) {
            definitions[variableName] = {
              detail: variableType.toString(),
              insertText: token.string === "$" ? variableName : "$" + variableName,
              label: variableName,
              type: variableType,
              kind: types_1.CompletionItemKind.Variable
            };
            variableName = null;
            variableType = null;
          }
        });
        return (0, autocompleteUtils_1.objectValues)(definitions);
      }
      exports.getVariableCompletions = getVariableCompletions;
      function getFragmentDefinitions(queryText) {
        const fragmentDefs = [];
        runOnlineParser(queryText, (_, state) => {
          if (state.kind === parser_1.RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {
            fragmentDefs.push({
              kind: parser_1.RuleKinds.FRAGMENT_DEFINITION,
              name: {
                kind: graphql_1.Kind.NAME,
                value: state.name
              },
              selectionSet: {
                kind: parser_1.RuleKinds.SELECTION_SET,
                selections: []
              },
              typeCondition: {
                kind: parser_1.RuleKinds.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: state.type
                }
              }
            });
          }
        });
        return fragmentDefs;
      }
      exports.getFragmentDefinitions = getFragmentDefinitions;
      function getSuggestionsForVariableDefinition(token, schema, _kind) {
        const inputTypeMap = schema.getTypeMap();
        const inputTypes = (0, autocompleteUtils_1.objectValues)(inputTypeMap).filter(graphql_1.isInputType);
        return (0, autocompleteUtils_1.hintList)(token, inputTypes.map((type) => ({
          label: type.name,
          documentation: type.description,
          kind: types_1.CompletionItemKind.Variable
        })));
      }
      function getSuggestionsForDirective(token, state, schema, _kind) {
        var _a3;
        if ((_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.kind) {
          const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));
          return (0, autocompleteUtils_1.hintList)(token, directives.map((directive) => ({
            label: directive.name,
            documentation: directive.description || "",
            kind: types_1.CompletionItemKind.Function
          })));
        }
        return [];
      }
      function getTokenAtPosition(queryText, cursor) {
        let styleAtCursor = null;
        let stateAtCursor = null;
        let stringAtCursor = null;
        const token = runOnlineParser(queryText, (stream, state, style, index) => {
          if (index === cursor.line && stream.getCurrentPosition() >= cursor.character) {
            styleAtCursor = style;
            stateAtCursor = Object.assign({}, state);
            stringAtCursor = stream.current();
            return "BREAK";
          }
        });
        return {
          start: token.start,
          end: token.end,
          string: stringAtCursor || token.string,
          state: stateAtCursor || token.state,
          style: styleAtCursor || token.style
        };
      }
      exports.getTokenAtPosition = getTokenAtPosition;
      function runOnlineParser(queryText, callback) {
        const lines = queryText.split("\n");
        const parser = (0, parser_1.onlineParser)();
        let state = parser.startState();
        let style = "";
        let stream = new parser_1.CharacterStream("");
        for (let i = 0; i < lines.length; i++) {
          stream = new parser_1.CharacterStream(lines[i]);
          while (!stream.eol()) {
            style = parser.token(stream, state);
            const code = callback(stream, state, style, i);
            if (code === "BREAK") {
              break;
            }
          }
          callback(stream, state, style, i);
          if (!state.kind) {
            state = parser.startState();
          }
        }
        return {
          start: stream.getStartOfToken(),
          end: stream.getCurrentPosition(),
          string: stream.current(),
          state,
          style
        };
      }
      exports.runOnlineParser = runOnlineParser;
      function canUseDirective(state, directive) {
        if (!state || !state.kind) {
          return false;
        }
        const { kind, prevState } = state;
        const { locations } = directive;
        switch (kind) {
          case parser_1.RuleKinds.QUERY:
            return locations.includes(graphql_1.DirectiveLocation.QUERY);
          case parser_1.RuleKinds.MUTATION:
            return locations.includes(graphql_1.DirectiveLocation.MUTATION);
          case parser_1.RuleKinds.SUBSCRIPTION:
            return locations.includes(graphql_1.DirectiveLocation.SUBSCRIPTION);
          case parser_1.RuleKinds.FIELD:
          case parser_1.RuleKinds.ALIASED_FIELD:
            return locations.includes(graphql_1.DirectiveLocation.FIELD);
          case parser_1.RuleKinds.FRAGMENT_DEFINITION:
            return locations.includes(graphql_1.DirectiveLocation.FRAGMENT_DEFINITION);
          case parser_1.RuleKinds.FRAGMENT_SPREAD:
            return locations.includes(graphql_1.DirectiveLocation.FRAGMENT_SPREAD);
          case parser_1.RuleKinds.INLINE_FRAGMENT:
            return locations.includes(graphql_1.DirectiveLocation.INLINE_FRAGMENT);
          case parser_1.RuleKinds.SCHEMA_DEF:
            return locations.includes(graphql_1.DirectiveLocation.SCHEMA);
          case parser_1.RuleKinds.SCALAR_DEF:
            return locations.includes(graphql_1.DirectiveLocation.SCALAR);
          case parser_1.RuleKinds.OBJECT_TYPE_DEF:
            return locations.includes(graphql_1.DirectiveLocation.OBJECT);
          case parser_1.RuleKinds.FIELD_DEF:
            return locations.includes(graphql_1.DirectiveLocation.FIELD_DEFINITION);
          case parser_1.RuleKinds.INTERFACE_DEF:
            return locations.includes(graphql_1.DirectiveLocation.INTERFACE);
          case parser_1.RuleKinds.UNION_DEF:
            return locations.includes(graphql_1.DirectiveLocation.UNION);
          case parser_1.RuleKinds.ENUM_DEF:
            return locations.includes(graphql_1.DirectiveLocation.ENUM);
          case parser_1.RuleKinds.ENUM_VALUE:
            return locations.includes(graphql_1.DirectiveLocation.ENUM_VALUE);
          case parser_1.RuleKinds.INPUT_DEF:
            return locations.includes(graphql_1.DirectiveLocation.INPUT_OBJECT);
          case parser_1.RuleKinds.INPUT_VALUE_DEF:
            const prevStateKind = prevState === null || prevState === void 0 ? void 0 : prevState.kind;
            switch (prevStateKind) {
              case parser_1.RuleKinds.ARGUMENTS_DEF:
                return locations.includes(graphql_1.DirectiveLocation.ARGUMENT_DEFINITION);
              case parser_1.RuleKinds.INPUT_DEF:
                return locations.includes(graphql_1.DirectiveLocation.INPUT_FIELD_DEFINITION);
            }
        }
        return false;
      }
      exports.canUseDirective = canUseDirective;
      function getTypeInfo(schema, tokenState) {
        let argDef;
        let argDefs;
        let directiveDef;
        let enumValue;
        let fieldDef;
        let inputType;
        let objectTypeDef;
        let objectFieldDefs;
        let parentType;
        let type;
        let interfaceDef;
        (0, autocompleteUtils_1.forEachState)(tokenState, (state) => {
          var _a3;
          switch (state.kind) {
            case parser_1.RuleKinds.QUERY:
            case "ShortQuery":
              type = schema.getQueryType();
              break;
            case parser_1.RuleKinds.MUTATION:
              type = schema.getMutationType();
              break;
            case parser_1.RuleKinds.SUBSCRIPTION:
              type = schema.getSubscriptionType();
              break;
            case parser_1.RuleKinds.INLINE_FRAGMENT:
            case parser_1.RuleKinds.FRAGMENT_DEFINITION:
              if (state.type) {
                type = schema.getType(state.type);
              }
              break;
            case parser_1.RuleKinds.FIELD:
            case parser_1.RuleKinds.ALIASED_FIELD: {
              if (!type || !state.name) {
                fieldDef = null;
              } else {
                fieldDef = parentType ? (0, autocompleteUtils_1.getFieldDef)(schema, parentType, state.name) : null;
                type = fieldDef ? fieldDef.type : null;
              }
              break;
            }
            case parser_1.RuleKinds.SELECTION_SET:
              parentType = (0, graphql_1.getNamedType)(type);
              break;
            case parser_1.RuleKinds.DIRECTIVE:
              directiveDef = state.name ? schema.getDirective(state.name) : null;
              break;
            case parser_1.RuleKinds.INTERFACE_DEF:
              if (state.name) {
                objectTypeDef = null;
                interfaceDef = new graphql_1.GraphQLInterfaceType({
                  name: state.name,
                  interfaces: [],
                  fields: {}
                });
              }
              break;
            case parser_1.RuleKinds.OBJECT_TYPE_DEF:
              if (state.name) {
                interfaceDef = null;
                objectTypeDef = new graphql_1.GraphQLObjectType({
                  name: state.name,
                  interfaces: [],
                  fields: {}
                });
              }
              break;
            case parser_1.RuleKinds.ARGUMENTS: {
              if (state.prevState) {
                switch (state.prevState.kind) {
                  case parser_1.RuleKinds.FIELD:
                    argDefs = fieldDef && fieldDef.args;
                    break;
                  case parser_1.RuleKinds.DIRECTIVE:
                    argDefs = directiveDef && directiveDef.args;
                    break;
                  case parser_1.RuleKinds.ALIASED_FIELD: {
                    const name = (_a3 = state.prevState) === null || _a3 === void 0 ? void 0 : _a3.name;
                    if (!name) {
                      argDefs = null;
                      break;
                    }
                    const field = parentType ? (0, autocompleteUtils_1.getFieldDef)(schema, parentType, name) : null;
                    if (!field) {
                      argDefs = null;
                      break;
                    }
                    argDefs = field.args;
                    break;
                  }
                  default:
                    argDefs = null;
                    break;
                }
              } else {
                argDefs = null;
              }
              break;
            }
            case parser_1.RuleKinds.ARGUMENT:
              if (argDefs) {
                for (let i = 0; i < argDefs.length; i++) {
                  if (argDefs[i].name === state.name) {
                    argDef = argDefs[i];
                    break;
                  }
                }
              }
              inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;
              break;
            case parser_1.RuleKinds.ENUM_VALUE:
              const enumType = (0, graphql_1.getNamedType)(inputType);
              enumValue = enumType instanceof graphql_1.GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;
              break;
            case parser_1.RuleKinds.LIST_VALUE:
              const nullableType = (0, graphql_1.getNullableType)(inputType);
              inputType = nullableType instanceof graphql_1.GraphQLList ? nullableType.ofType : null;
              break;
            case parser_1.RuleKinds.OBJECT_VALUE:
              const objectType = (0, graphql_1.getNamedType)(inputType);
              objectFieldDefs = objectType instanceof graphql_1.GraphQLInputObjectType ? objectType.getFields() : null;
              break;
            case parser_1.RuleKinds.OBJECT_FIELD:
              const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;
              inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;
              break;
            case parser_1.RuleKinds.NAMED_TYPE:
              if (state.name) {
                type = schema.getType(state.name);
              }
              break;
          }
        });
        return {
          argDef,
          argDefs,
          directiveDef,
          enumValue,
          fieldDef,
          inputType,
          objectFieldDefs,
          parentType,
          type,
          interfaceDef,
          objectTypeDef
        };
      }
      exports.getTypeInfo = getTypeInfo;
      var GraphQLDocumentMode;
      (function(GraphQLDocumentMode2) {
        GraphQLDocumentMode2["TYPE_SYSTEM"] = "TYPE_SYSTEM";
        GraphQLDocumentMode2["EXECUTABLE"] = "EXECUTABLE";
      })(GraphQLDocumentMode = exports.GraphQLDocumentMode || (exports.GraphQLDocumentMode = {}));
      function getDocumentMode(documentText, uri) {
        if (uri === null || uri === void 0 ? void 0 : uri.endsWith(".graphqls")) {
          return GraphQLDocumentMode.TYPE_SYSTEM;
        }
        return hasTypeSystemDefinitions(documentText) ? GraphQLDocumentMode.TYPE_SYSTEM : GraphQLDocumentMode.EXECUTABLE;
      }
      function unwrapType(state) {
        if (state.prevState && state.kind && [
          parser_1.RuleKinds.NAMED_TYPE,
          parser_1.RuleKinds.LIST_TYPE,
          parser_1.RuleKinds.TYPE,
          parser_1.RuleKinds.NON_NULL_TYPE
        ].includes(state.kind)) {
          return unwrapType(state.prevState);
        }
        return state;
      }
    }
  });

  // node_modules/nullthrows/nullthrows.js
  var require_nullthrows = __commonJS({
    "node_modules/nullthrows/nullthrows.js"(exports, module) {
      "use strict";
      function nullthrows(x, message) {
        if (x != null) {
          return x;
        }
        var error = new Error(message !== void 0 ? message : "Got unexpected " + x);
        error.framesToPop = 1;
        throw error;
      }
      module.exports = nullthrows;
      module.exports.default = nullthrows;
      Object.defineProperty(module.exports, "__esModule", { value: true });
    }
  });

  // node_modules/graphql-language-service/dist/utils/fragmentDependencies.js
  var require_fragmentDependencies = __commonJS({
    "node_modules/graphql-language-service/dist/utils/fragmentDependencies.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = void 0;
      var graphql_1 = require_graphql2();
      var nullthrows_1 = __importDefault(require_nullthrows());
      var getFragmentDependencies = (operationString, fragmentDefinitions) => {
        if (!fragmentDefinitions) {
          return [];
        }
        let parsedOperation;
        try {
          parsedOperation = (0, graphql_1.parse)(operationString);
        } catch (_a3) {
          return [];
        }
        return (0, exports.getFragmentDependenciesForAST)(parsedOperation, fragmentDefinitions);
      };
      exports.getFragmentDependencies = getFragmentDependencies;
      var getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {
        if (!fragmentDefinitions) {
          return [];
        }
        const existingFrags = /* @__PURE__ */ new Map();
        const referencedFragNames = /* @__PURE__ */ new Set();
        (0, graphql_1.visit)(parsedOperation, {
          FragmentDefinition(node) {
            existingFrags.set(node.name.value, true);
          },
          FragmentSpread(node) {
            if (!referencedFragNames.has(node.name.value)) {
              referencedFragNames.add(node.name.value);
            }
          }
        });
        const asts = /* @__PURE__ */ new Set();
        referencedFragNames.forEach((name) => {
          if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
            asts.add((0, nullthrows_1.default)(fragmentDefinitions.get(name)));
          }
        });
        const referencedFragments = [];
        asts.forEach((ast) => {
          (0, graphql_1.visit)(ast, {
            FragmentSpread(node) {
              if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                asts.add((0, nullthrows_1.default)(fragmentDefinitions.get(node.name.value)));
                referencedFragNames.add(node.name.value);
              }
            }
          });
          if (!existingFrags.has(ast.name.value)) {
            referencedFragments.push(ast);
          }
        });
        return referencedFragments;
      };
      exports.getFragmentDependenciesForAST = getFragmentDependenciesForAST;
    }
  });

  // node_modules/graphql-language-service/dist/utils/getVariablesJSONSchema.js
  var require_getVariablesJSONSchema = __commonJS({
    "node_modules/graphql-language-service/dist/utils/getVariablesJSONSchema.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getVariablesJSONSchema = exports.defaultJSONSchemaOptions = void 0;
      var graphql_1 = require_graphql2();
      exports.defaultJSONSchemaOptions = {
        useMarkdownDescription: false
      };
      function text(into, newText) {
        into.push(newText);
      }
      function renderType(into, t) {
        if ((0, graphql_1.isNonNullType)(t)) {
          renderType(into, t.ofType);
          text(into, "!");
        } else if ((0, graphql_1.isListType)(t)) {
          text(into, "[");
          renderType(into, t.ofType);
          text(into, "]");
        } else {
          text(into, t.name);
        }
      }
      function renderTypeToString(t, useMarkdown) {
        const into = [];
        if (useMarkdown) {
          text(into, "```graphql\n");
        }
        renderType(into, t);
        if (useMarkdown) {
          text(into, "\n```");
        }
        return into.join("");
      }
      var scalarTypesMap = {
        Int: "integer",
        String: "string",
        Float: "number",
        ID: "string",
        Boolean: "boolean",
        DateTime: "string"
      };
      var Marker = class {
        constructor() {
          this.set = /* @__PURE__ */ new Set();
        }
        mark(name) {
          if (this.set.has(name)) {
            return false;
          }
          this.set.add(name);
          return true;
        }
      };
      function getJSONSchemaFromGraphQLType(type, options) {
        let required = false;
        let definition = /* @__PURE__ */ Object.create(null);
        const definitions = /* @__PURE__ */ Object.create(null);
        if ("defaultValue" in type && type.defaultValue !== void 0) {
          definition.default = type.defaultValue;
        }
        if ((0, graphql_1.isEnumType)(type)) {
          definition.type = "string";
          definition.enum = type.getValues().map((val) => val.name);
        }
        if ((0, graphql_1.isScalarType)(type) && scalarTypesMap[type.name]) {
          definition.type = scalarTypesMap[type.name];
        }
        if ((0, graphql_1.isListType)(type)) {
          definition.type = "array";
          const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type.ofType, options);
          if (def.$ref) {
            definition.items = { $ref: def.$ref };
          } else {
            definition.items = def;
          }
          if (defs) {
            Object.keys(defs).forEach((defName) => {
              definitions[defName] = defs[defName];
            });
          }
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          required = true;
          const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type.ofType, options);
          definition = def;
          if (defs) {
            Object.keys(defs).forEach((defName) => {
              definitions[defName] = defs[defName];
            });
          }
        }
        if ((0, graphql_1.isInputObjectType)(type)) {
          definition.$ref = `#/definitions/${type.name}`;
          if (options === null || options === void 0 ? void 0 : options.definitionMarker.mark(type.name)) {
            const fields = type.getFields();
            const fieldDef = {
              type: "object",
              properties: {},
              required: []
            };
            if (type.description) {
              fieldDef.description = type.description + `
` + renderTypeToString(type);
              if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
                fieldDef.markdownDescription = type.description + `
` + renderTypeToString(type, true);
              }
            } else {
              fieldDef.description = renderTypeToString(type);
              if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
                fieldDef.markdownDescription = renderTypeToString(type, true);
              }
            }
            Object.keys(fields).forEach((fieldName) => {
              const field = fields[fieldName];
              const { required: fieldRequired, definition: typeDefinition, definitions: typeDefinitions } = getJSONSchemaFromGraphQLType(field.type, options);
              const { definition: fieldDefinition } = getJSONSchemaFromGraphQLType(field, options);
              fieldDef.properties[fieldName] = Object.assign(Object.assign({}, typeDefinition), fieldDefinition);
              const renderedField = renderTypeToString(field.type);
              fieldDef.properties[fieldName].description = field.description ? field.description + "\n" + renderedField : renderedField;
              if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
                const renderedFieldMarkdown = renderTypeToString(field.type, true);
                fieldDef.properties[fieldName].markdownDescription = field.description ? field.description + "\n" + renderedFieldMarkdown : renderedFieldMarkdown;
              }
              if (fieldRequired) {
                fieldDef.required.push(fieldName);
              }
              if (typeDefinitions) {
                Object.keys(typeDefinitions).map((defName) => {
                  definitions[defName] = typeDefinitions[defName];
                });
              }
            });
            definitions[type.name] = fieldDef;
          }
        }
        if ("description" in type && !(0, graphql_1.isScalarType)(type) && type.description && !definition.description) {
          definition.description = type.description + "\n" + renderTypeToString(type);
          if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
            definition.markdownDescription = type.description + "\n" + renderTypeToString(type, true);
          }
        } else {
          definition.description = renderTypeToString(type);
          if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
            definition.markdownDescription = renderTypeToString(type, true);
          }
        }
        return { required, definition, definitions };
      }
      function getVariablesJSONSchema(variableToType, options) {
        const jsonSchema = {
          $schema: "https://json-schema.org/draft/2020-12/schema",
          type: "object",
          properties: {},
          required: []
        };
        const runtimeOptions = Object.assign(Object.assign({}, options), { definitionMarker: new Marker() });
        if (variableToType) {
          Object.entries(variableToType).forEach(([variableName, type]) => {
            var _a3;
            const { definition, required, definitions } = getJSONSchemaFromGraphQLType(type, runtimeOptions);
            jsonSchema.properties[variableName] = definition;
            if (required) {
              (_a3 = jsonSchema.required) === null || _a3 === void 0 ? void 0 : _a3.push(variableName);
            }
            if (definitions) {
              jsonSchema.definitions = Object.assign(Object.assign({}, jsonSchema === null || jsonSchema === void 0 ? void 0 : jsonSchema.definitions), definitions);
            }
          });
        }
        return jsonSchema;
      }
      exports.getVariablesJSONSchema = getVariablesJSONSchema;
    }
  });

  // node_modules/graphql-language-service/dist/utils/getASTNodeAtPosition.js
  var require_getASTNodeAtPosition = __commonJS({
    "node_modules/graphql-language-service/dist/utils/getASTNodeAtPosition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pointToOffset = exports.getASTNodeAtPosition = void 0;
      var graphql_1 = require_graphql2();
      function getASTNodeAtPosition(query, ast, point) {
        const offset = pointToOffset(query, point);
        let nodeContainingPosition;
        (0, graphql_1.visit)(ast, {
          enter(node) {
            if (node.kind !== "Name" && node.loc && node.loc.start <= offset && offset <= node.loc.end) {
              nodeContainingPosition = node;
            } else {
              return false;
            }
          },
          leave(node) {
            if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {
              return false;
            }
          }
        });
        return nodeContainingPosition;
      }
      exports.getASTNodeAtPosition = getASTNodeAtPosition;
      function pointToOffset(text, point) {
        const linesUntilPosition = text.split("\n").slice(0, point.line);
        return point.character + linesUntilPosition.map((line) => line.length + 1).reduce((a, b) => a + b, 0);
      }
      exports.pointToOffset = pointToOffset;
    }
  });

  // node_modules/graphql-language-service/dist/utils/Range.js
  var require_Range = __commonJS({
    "node_modules/graphql-language-service/dist/utils/Range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.locToRange = exports.offsetToPosition = exports.Position = exports.Range = void 0;
      var Range2 = class {
        constructor(start, end) {
          this.containsPosition = (position) => {
            if (this.start.line === position.line) {
              return this.start.character <= position.character;
            }
            if (this.end.line === position.line) {
              return this.end.character >= position.character;
            }
            return this.start.line <= position.line && this.end.line >= position.line;
          };
          this.start = start;
          this.end = end;
        }
        setStart(line, character) {
          this.start = new Position2(line, character);
        }
        setEnd(line, character) {
          this.end = new Position2(line, character);
        }
      };
      exports.Range = Range2;
      var Position2 = class {
        constructor(line, character) {
          this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;
          this.line = line;
          this.character = character;
        }
        setLine(line) {
          this.line = line;
        }
        setCharacter(character) {
          this.character = character;
        }
      };
      exports.Position = Position2;
      function offsetToPosition(text, loc) {
        const EOL = "\n";
        const buf = text.slice(0, loc);
        const lines = buf.split(EOL).length - 1;
        const lastLineIndex = buf.lastIndexOf(EOL);
        return new Position2(lines, loc - lastLineIndex - 1);
      }
      exports.offsetToPosition = offsetToPosition;
      function locToRange(text, loc) {
        const start = offsetToPosition(text, loc.start);
        const end = offsetToPosition(text, loc.end);
        return new Range2(start, end);
      }
      exports.locToRange = locToRange;
    }
  });

  // node_modules/graphql-language-service/dist/utils/validateWithCustomRules.js
  var require_validateWithCustomRules = __commonJS({
    "node_modules/graphql-language-service/dist/utils/validateWithCustomRules.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateWithCustomRules = void 0;
      var graphql_1 = require_graphql2();
      var specifiedSDLRules = [
        graphql_1.LoneSchemaDefinitionRule,
        graphql_1.UniqueOperationTypesRule,
        graphql_1.UniqueTypeNamesRule,
        graphql_1.UniqueEnumValueNamesRule,
        graphql_1.UniqueFieldDefinitionNamesRule,
        graphql_1.UniqueDirectiveNamesRule,
        graphql_1.KnownTypeNamesRule,
        graphql_1.KnownDirectivesRule,
        graphql_1.UniqueDirectivesPerLocationRule,
        graphql_1.PossibleTypeExtensionsRule,
        graphql_1.UniqueArgumentNamesRule,
        graphql_1.UniqueInputFieldNamesRule
      ];
      function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {
        const rules = graphql_1.specifiedRules.filter((rule) => {
          if (rule === graphql_1.NoUnusedFragmentsRule || rule === graphql_1.ExecutableDefinitionsRule) {
            return false;
          }
          if (isRelayCompatMode && rule === graphql_1.KnownFragmentNamesRule) {
            return false;
          }
          return true;
        });
        if (customRules) {
          Array.prototype.push.apply(rules, customRules);
        }
        if (isSchemaDocument) {
          Array.prototype.push.apply(rules, specifiedSDLRules);
        }
        const errors = (0, graphql_1.validate)(schema, ast, rules);
        return errors.filter((error) => {
          if (error.message.includes("Unknown directive") && error.nodes) {
            const node = error.nodes[0];
            if (node && node.kind === graphql_1.Kind.DIRECTIVE) {
              const name = node.name.value;
              if (name === "arguments" || name === "argumentDefinitions") {
                return false;
              }
            }
          }
          return true;
        });
      }
      exports.validateWithCustomRules = validateWithCustomRules;
    }
  });

  // node_modules/graphql-language-service/dist/utils/collectVariables.js
  var require_collectVariables = __commonJS({
    "node_modules/graphql-language-service/dist/utils/collectVariables.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.collectVariables = void 0;
      var graphql_1 = require_graphql2();
      function collectVariables(schema, documentAST) {
        const variableToType = /* @__PURE__ */ Object.create(null);
        documentAST.definitions.forEach((definition) => {
          if (definition.kind === "OperationDefinition") {
            const { variableDefinitions } = definition;
            if (variableDefinitions) {
              variableDefinitions.forEach(({ variable, type }) => {
                const inputType = (0, graphql_1.typeFromAST)(schema, type);
                if (inputType) {
                  variableToType[variable.name.value] = inputType;
                } else if (type.kind === graphql_1.Kind.NAMED_TYPE && type.name.value === "Float") {
                  variableToType[variable.name.value] = graphql_1.GraphQLFloat;
                }
              });
            }
          }
        });
        return variableToType;
      }
      exports.collectVariables = collectVariables;
    }
  });

  // node_modules/graphql-language-service/dist/utils/getOperationFacts.js
  var require_getOperationFacts = __commonJS({
    "node_modules/graphql-language-service/dist/utils/getOperationFacts.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getQueryFacts = exports.getOperationASTFacts = void 0;
      var graphql_1 = require_graphql2();
      var collectVariables_1 = require_collectVariables();
      function getOperationASTFacts(documentAST, schema) {
        const variableToType = schema ? (0, collectVariables_1.collectVariables)(schema, documentAST) : void 0;
        const operations = [];
        (0, graphql_1.visit)(documentAST, {
          OperationDefinition(node) {
            operations.push(node);
          }
        });
        return { variableToType, operations };
      }
      exports.getOperationASTFacts = getOperationASTFacts;
      function getOperationFacts(schema, documentString) {
        if (!documentString) {
          return;
        }
        try {
          const documentAST = (0, graphql_1.parse)(documentString);
          return Object.assign(Object.assign({}, getOperationASTFacts(documentAST, schema)), { documentAST });
        } catch (_a3) {
          return;
        }
      }
      exports.default = getOperationFacts;
      exports.getQueryFacts = getOperationFacts;
    }
  });

  // node_modules/graphql-language-service/dist/utils/index.js
  var require_utils = __commonJS({
    "node_modules/graphql-language-service/dist/utils/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getQueryFacts = exports.getOperationASTFacts = exports.getOperationFacts = exports.collectVariables = exports.validateWithCustomRules = exports.offsetToPosition = exports.locToRange = exports.Range = exports.Position = exports.pointToOffset = exports.getASTNodeAtPosition = exports.getVariablesJSONSchema = exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = void 0;
      var fragmentDependencies_1 = require_fragmentDependencies();
      Object.defineProperty(exports, "getFragmentDependencies", { enumerable: true, get: function() {
        return fragmentDependencies_1.getFragmentDependencies;
      } });
      Object.defineProperty(exports, "getFragmentDependenciesForAST", { enumerable: true, get: function() {
        return fragmentDependencies_1.getFragmentDependenciesForAST;
      } });
      var getVariablesJSONSchema_1 = require_getVariablesJSONSchema();
      Object.defineProperty(exports, "getVariablesJSONSchema", { enumerable: true, get: function() {
        return getVariablesJSONSchema_1.getVariablesJSONSchema;
      } });
      var getASTNodeAtPosition_1 = require_getASTNodeAtPosition();
      Object.defineProperty(exports, "getASTNodeAtPosition", { enumerable: true, get: function() {
        return getASTNodeAtPosition_1.getASTNodeAtPosition;
      } });
      Object.defineProperty(exports, "pointToOffset", { enumerable: true, get: function() {
        return getASTNodeAtPosition_1.pointToOffset;
      } });
      var Range_1 = require_Range();
      Object.defineProperty(exports, "Position", { enumerable: true, get: function() {
        return Range_1.Position;
      } });
      Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
        return Range_1.Range;
      } });
      Object.defineProperty(exports, "locToRange", { enumerable: true, get: function() {
        return Range_1.locToRange;
      } });
      Object.defineProperty(exports, "offsetToPosition", { enumerable: true, get: function() {
        return Range_1.offsetToPosition;
      } });
      var validateWithCustomRules_1 = require_validateWithCustomRules();
      Object.defineProperty(exports, "validateWithCustomRules", { enumerable: true, get: function() {
        return validateWithCustomRules_1.validateWithCustomRules;
      } });
      var collectVariables_1 = require_collectVariables();
      Object.defineProperty(exports, "collectVariables", { enumerable: true, get: function() {
        return collectVariables_1.collectVariables;
      } });
      var getOperationFacts_1 = require_getOperationFacts();
      Object.defineProperty(exports, "getOperationFacts", { enumerable: true, get: function() {
        return __importDefault(getOperationFacts_1).default;
      } });
      Object.defineProperty(exports, "getOperationASTFacts", { enumerable: true, get: function() {
        return getOperationFacts_1.getOperationASTFacts;
      } });
      Object.defineProperty(exports, "getQueryFacts", { enumerable: true, get: function() {
        return getOperationFacts_1.getQueryFacts;
      } });
    }
  });

  // node_modules/graphql-language-service/dist/interface/getDefinition.js
  var require_getDefinition = __commonJS({
    "node_modules/graphql-language-service/dist/interface/getDefinition.js"(exports) {
      "use strict";
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDefinitionQueryResultForDefinitionNode = exports.getDefinitionQueryResultForFragmentSpread = exports.getDefinitionQueryResultForField = exports.getDefinitionQueryResultForNamedType = exports.LANGUAGE = void 0;
      var utils_1 = require_utils();
      exports.LANGUAGE = "GraphQL";
      function assert(value, message) {
        if (!value) {
          throw new Error(message);
        }
      }
      function getRange(text, node) {
        const location = node.loc;
        assert(location, "Expected ASTNode to have a location.");
        return (0, utils_1.locToRange)(text, location);
      }
      function getPosition(text, node) {
        const location = node.loc;
        assert(location, "Expected ASTNode to have a location.");
        return (0, utils_1.offsetToPosition)(text, location.start);
      }
      function getDefinitionQueryResultForNamedType(text, node, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const name = node.name.value;
          const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name);
          if (defNodes.length === 0) {
            throw new Error(`Definition not found for GraphQL type ${name}`);
          }
          const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || "", content, definition));
          return {
            definitions,
            queryRange: definitions.map((_) => getRange(text, node))
          };
        });
      }
      exports.getDefinitionQueryResultForNamedType = getDefinitionQueryResultForNamedType;
      function getDefinitionQueryResultForField(fieldName, typeName, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === typeName);
          if (defNodes.length === 0) {
            throw new Error(`Definition not found for GraphQL type ${typeName}`);
          }
          const definitions = [];
          defNodes.forEach(({ filePath, content, definition }) => {
            var _a3;
            const fieldDefinition = (_a3 = definition.fields) === null || _a3 === void 0 ? void 0 : _a3.find((item) => item.name.value === fieldName);
            if (fieldDefinition == null) {
              return null;
            }
            definitions.push(getDefinitionForFieldDefinition(filePath || "", content, fieldDefinition));
          });
          return {
            definitions,
            queryRange: []
          };
        });
      }
      exports.getDefinitionQueryResultForField = getDefinitionQueryResultForField;
      function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {
        return __awaiter3(this, void 0, void 0, function* () {
          const name = fragment.name.value;
          const defNodes = dependencies.filter(({ definition }) => definition.name.value === name);
          if (defNodes.length === 0) {
            throw new Error(`Definition not found for GraphQL fragment ${name}`);
          }
          const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || "", content, definition));
          return {
            definitions,
            queryRange: definitions.map((_) => getRange(text, fragment))
          };
        });
      }
      exports.getDefinitionQueryResultForFragmentSpread = getDefinitionQueryResultForFragmentSpread;
      function getDefinitionQueryResultForDefinitionNode(path, text, definition) {
        return {
          definitions: [getDefinitionForFragmentDefinition(path, text, definition)],
          queryRange: definition.name ? [getRange(text, definition.name)] : []
        };
      }
      exports.getDefinitionQueryResultForDefinitionNode = getDefinitionQueryResultForDefinitionNode;
      function getDefinitionForFragmentDefinition(path, text, definition) {
        const { name } = definition;
        if (!name) {
          throw new Error("Expected ASTNode to have a Name.");
        }
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
      function getDefinitionForNodeDefinition(path, text, definition) {
        const { name } = definition;
        assert(name, "Expected ASTNode to have a Name.");
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
      function getDefinitionForFieldDefinition(path, text, definition) {
        const { name } = definition;
        assert(name, "Expected ASTNode to have a Name.");
        return {
          path,
          position: getPosition(text, definition),
          range: getRange(text, definition),
          name: name.value || "",
          language: exports.LANGUAGE,
          projectRoot: path
        };
      }
    }
  });

  // node_modules/graphql-language-service/dist/interface/getDiagnostics.js
  var require_getDiagnostics = __commonJS({
    "node_modules/graphql-language-service/dist/interface/getDiagnostics.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRange = exports.validateQuery = exports.getDiagnostics = exports.DIAGNOSTIC_SEVERITY = exports.SEVERITY = void 0;
      var graphql_1 = require_graphql2();
      var parser_1 = require_parser2();
      var utils_1 = require_utils();
      exports.SEVERITY = {
        Error: "Error",
        Warning: "Warning",
        Information: "Information",
        Hint: "Hint"
      };
      exports.DIAGNOSTIC_SEVERITY = {
        [exports.SEVERITY.Error]: 1,
        [exports.SEVERITY.Warning]: 2,
        [exports.SEVERITY.Information]: 3,
        [exports.SEVERITY.Hint]: 4
      };
      var invariant = (condition, message) => {
        if (!condition) {
          throw new Error(message);
        }
      };
      function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {
        var _a3, _b;
        let ast = null;
        let fragments = "";
        if (externalFragments) {
          fragments = typeof externalFragments === "string" ? externalFragments : externalFragments.reduce((acc, node) => acc + (0, graphql_1.print)(node) + "\n\n", "");
        }
        const enhancedQuery = fragments ? `${query}

${fragments}` : query;
        try {
          ast = (0, graphql_1.parse)(enhancedQuery);
        } catch (error) {
          if (error instanceof graphql_1.GraphQLError) {
            const range = getRange((_b = (_a3 = error.locations) === null || _a3 === void 0 ? void 0 : _a3[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, enhancedQuery);
            return [
              {
                severity: exports.DIAGNOSTIC_SEVERITY.Error,
                message: error.message,
                source: "GraphQL: Syntax",
                range
              }
            ];
          }
          throw error;
        }
        return validateQuery(ast, schema, customRules, isRelayCompatMode);
      }
      exports.getDiagnostics = getDiagnostics;
      function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {
        if (!schema) {
          return [];
        }
        const validationErrorAnnotations = (0, utils_1.validateWithCustomRules)(schema, ast, customRules, isRelayCompatMode).flatMap((error) => annotations(error, exports.DIAGNOSTIC_SEVERITY.Error, "Validation"));
        const deprecationWarningAnnotations = (0, graphql_1.validate)(schema, ast, [
          graphql_1.NoDeprecatedCustomRule
        ]).flatMap((error) => annotations(error, exports.DIAGNOSTIC_SEVERITY.Warning, "Deprecation"));
        return validationErrorAnnotations.concat(deprecationWarningAnnotations);
      }
      exports.validateQuery = validateQuery;
      function annotations(error, severity, type) {
        if (!error.nodes) {
          return [];
        }
        const highlightedNodes = [];
        error.nodes.forEach((node, i) => {
          const highlightNode = node.kind !== "Variable" && "name" in node && node.name !== void 0 ? node.name : "variable" in node && node.variable !== void 0 ? node.variable : node;
          if (highlightNode) {
            invariant(error.locations, "GraphQL validation error requires locations.");
            const loc = error.locations[i];
            const highlightLoc = getLocation(highlightNode);
            const end = loc.column + (highlightLoc.end - highlightLoc.start);
            highlightedNodes.push({
              source: `GraphQL: ${type}`,
              message: error.message,
              severity,
              range: new utils_1.Range(new utils_1.Position(loc.line - 1, loc.column - 1), new utils_1.Position(loc.line - 1, end))
            });
          }
        });
        return highlightedNodes;
      }
      function getRange(location, queryText) {
        const parser = (0, parser_1.onlineParser)();
        const state = parser.startState();
        const lines = queryText.split("\n");
        invariant(lines.length >= location.line, "Query text must have more lines than where the error happened");
        let stream = null;
        for (let i = 0; i < location.line; i++) {
          stream = new parser_1.CharacterStream(lines[i]);
          while (!stream.eol()) {
            const style = parser.token(stream, state);
            if (style === "invalidchar") {
              break;
            }
          }
        }
        invariant(stream, "Expected Parser stream to be available.");
        const line = location.line - 1;
        const start = stream.getStartOfToken();
        const end = stream.getCurrentPosition();
        return new utils_1.Range(new utils_1.Position(line, start), new utils_1.Position(line, end));
      }
      exports.getRange = getRange;
      function getLocation(node) {
        const typeCastedNode = node;
        const location = typeCastedNode.loc;
        invariant(location, "Expected ASTNode to have a location.");
        return location;
      }
    }
  });

  // node_modules/graphql-language-service/dist/interface/getOutline.js
  var require_getOutline = __commonJS({
    "node_modules/graphql-language-service/dist/interface/getOutline.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getOutline = void 0;
      var graphql_1 = require_graphql2();
      var utils_1 = require_utils();
      var { INLINE_FRAGMENT } = graphql_1.Kind;
      function getOutline(documentText) {
        let ast;
        try {
          ast = (0, graphql_1.parse)(documentText);
        } catch (_a3) {
          return null;
        }
        const visitorFns = outlineTreeConverter(documentText);
        const outlineTrees = (0, graphql_1.visit)(ast, {
          leave(node) {
            if (visitorFns !== void 0 && node.kind in visitorFns) {
              return visitorFns[node.kind](node);
            }
            return null;
          }
        });
        return { outlineTrees };
      }
      exports.getOutline = getOutline;
      function outlineTreeConverter(docText) {
        const meta = (node) => {
          return {
            representativeName: node.name,
            startPosition: (0, utils_1.offsetToPosition)(docText, node.loc.start),
            endPosition: (0, utils_1.offsetToPosition)(docText, node.loc.end),
            kind: node.kind,
            children: node.selectionSet || node.fields || node.values || node.arguments || []
          };
        };
        return {
          Field: (node) => {
            const tokenizedText = node.alias ? [buildToken("plain", node.alias), buildToken("plain", ": ")] : [];
            tokenizedText.push(buildToken("plain", node.name));
            return Object.assign({ tokenizedText }, meta(node));
          },
          OperationDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", node.operation),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          Document: (node) => node.definitions,
          SelectionSet: (node) => concatMap(node.selections, (child) => {
            return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;
          }),
          Name: (node) => node.value,
          FragmentDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "fragment"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InterfaceTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "interface"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          EnumTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "enum"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          EnumValueDefinition: (node) => Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node)),
          ObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "type"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InputObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
            buildToken("keyword", "input"),
            buildToken("whitespace", " "),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          FragmentSpread: (node) => Object.assign({ tokenizedText: [
            buildToken("plain", "..."),
            buildToken("class-name", node.name)
          ] }, meta(node)),
          InputValueDefinition: (node) => {
            return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
          },
          FieldDefinition: (node) => {
            return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
          },
          InlineFragment: (node) => node.selectionSet
        };
      }
      function buildToken(kind, value) {
        return { kind, value };
      }
      function concatMap(arr, fn) {
        const res = [];
        for (let i = 0; i < arr.length; i++) {
          const x = fn(arr[i], i);
          if (Array.isArray(x)) {
            res.push(...x);
          } else {
            res.push(x);
          }
        }
        return res;
      }
    }
  });

  // node_modules/graphql-language-service/dist/interface/getHoverInformation.js
  var require_getHoverInformation = __commonJS({
    "node_modules/graphql-language-service/dist/interface/getHoverInformation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHoverInformation = void 0;
      var graphql_1 = require_graphql2();
      var getAutocompleteSuggestions_1 = require_getAutocompleteSuggestions();
      function getHoverInformation(schema, queryText, cursor, contextToken, config) {
        const token = contextToken || (0, getAutocompleteSuggestions_1.getTokenAtPosition)(queryText, cursor);
        if (!schema || !token || !token.state) {
          return "";
        }
        const { kind, step } = token.state;
        const typeInfo = (0, getAutocompleteSuggestions_1.getTypeInfo)(schema, token.state);
        const options = Object.assign(Object.assign({}, config), { schema });
        if (kind === "Field" && step === 0 && typeInfo.fieldDef || kind === "AliasedField" && step === 2 && typeInfo.fieldDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderField(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.fieldDef);
          return into.join("").trim();
        }
        if (kind === "Directive" && step === 1 && typeInfo.directiveDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderDirective(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.directiveDef);
          return into.join("").trim();
        }
        if (kind === "Argument" && step === 0 && typeInfo.argDef) {
          const into = [];
          renderMdCodeStart(into, options);
          renderArg(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.argDef);
          return into.join("").trim();
        }
        if (kind === "EnumValue" && typeInfo.enumValue && "description" in typeInfo.enumValue) {
          const into = [];
          renderMdCodeStart(into, options);
          renderEnumValue(into, typeInfo, options);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.enumValue);
          return into.join("").trim();
        }
        if (kind === "NamedType" && typeInfo.type && "description" in typeInfo.type) {
          const into = [];
          renderMdCodeStart(into, options);
          renderType(into, typeInfo, options, typeInfo.type);
          renderMdCodeEnd(into, options);
          renderDescription(into, options, typeInfo.type);
          return into.join("").trim();
        }
        return "";
      }
      exports.getHoverInformation = getHoverInformation;
      function renderMdCodeStart(into, options) {
        if (options.useMarkdown) {
          text(into, "```graphql\n");
        }
      }
      function renderMdCodeEnd(into, options) {
        if (options.useMarkdown) {
          text(into, "\n```");
        }
      }
      function renderField(into, typeInfo, options) {
        renderQualifiedField(into, typeInfo, options);
        renderTypeAnnotation(into, typeInfo, options, typeInfo.type);
      }
      function renderQualifiedField(into, typeInfo, options) {
        if (!typeInfo.fieldDef) {
          return;
        }
        const fieldName = typeInfo.fieldDef.name;
        if (fieldName.slice(0, 2) !== "__") {
          renderType(into, typeInfo, options, typeInfo.parentType);
          text(into, ".");
        }
        text(into, fieldName);
      }
      function renderDirective(into, typeInfo, _options) {
        if (!typeInfo.directiveDef) {
          return;
        }
        const name = "@" + typeInfo.directiveDef.name;
        text(into, name);
      }
      function renderArg(into, typeInfo, options) {
        if (typeInfo.directiveDef) {
          renderDirective(into, typeInfo, options);
        } else if (typeInfo.fieldDef) {
          renderQualifiedField(into, typeInfo, options);
        }
        if (!typeInfo.argDef) {
          return;
        }
        const { name } = typeInfo.argDef;
        text(into, "(");
        text(into, name);
        renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);
        text(into, ")");
      }
      function renderTypeAnnotation(into, typeInfo, options, t) {
        text(into, ": ");
        renderType(into, typeInfo, options, t);
      }
      function renderEnumValue(into, typeInfo, options) {
        if (!typeInfo.enumValue) {
          return;
        }
        const { name } = typeInfo.enumValue;
        renderType(into, typeInfo, options, typeInfo.inputType);
        text(into, ".");
        text(into, name);
      }
      function renderType(into, typeInfo, options, t) {
        if (!t) {
          return;
        }
        if (t instanceof graphql_1.GraphQLNonNull) {
          renderType(into, typeInfo, options, t.ofType);
          text(into, "!");
        } else if (t instanceof graphql_1.GraphQLList) {
          text(into, "[");
          renderType(into, typeInfo, options, t.ofType);
          text(into, "]");
        } else {
          text(into, t.name);
        }
      }
      function renderDescription(into, options, def) {
        if (!def) {
          return;
        }
        const description = typeof def.description === "string" ? def.description : null;
        if (description) {
          text(into, "\n\n");
          text(into, description);
        }
        renderDeprecation(into, options, def);
      }
      function renderDeprecation(into, _options, def) {
        if (!def) {
          return;
        }
        const reason = def.deprecationReason || null;
        if (!reason) {
          return;
        }
        text(into, "\n\n");
        text(into, "Deprecated: ");
        text(into, reason);
      }
      function text(into, content) {
        into.push(content);
      }
    }
  });

  // node_modules/graphql-language-service/dist/interface/index.js
  var require_interface = __commonJS({
    "node_modules/graphql-language-service/dist/interface/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHoverInformation = exports.getOutline = void 0;
      __exportStar(require_autocompleteUtils(), exports);
      __exportStar(require_getAutocompleteSuggestions(), exports);
      __exportStar(require_getDefinition(), exports);
      __exportStar(require_getDiagnostics(), exports);
      var getOutline_1 = require_getOutline();
      Object.defineProperty(exports, "getOutline", { enumerable: true, get: function() {
        return getOutline_1.getOutline;
      } });
      var getHoverInformation_1 = require_getHoverInformation();
      Object.defineProperty(exports, "getHoverInformation", { enumerable: true, get: function() {
        return getHoverInformation_1.getHoverInformation;
      } });
    }
  });

  // node_modules/graphql-language-service/dist/index.js
  var require_dist = __commonJS({
    "node_modules/graphql-language-service/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Range = exports.validateWithCustomRules = exports.collectVariables = exports.Position = exports.pointToOffset = exports.offsetToPosition = exports.getVariablesJSONSchema = exports.getQueryFacts = exports.getOperationFacts = exports.getOperationASTFacts = exports.getFragmentDependenciesForAST = exports.getFragmentDependencies = exports.getASTNodeAtPosition = exports.FileChangeTypeKind = exports.CompletionItemKind = exports.opt = exports.t = exports.list = exports.p = exports.isIgnored = exports.LexRules = exports.RuleKinds = exports.CharacterStream = exports.ParseRules = exports.onlineParser = exports.validateQuery = exports.SuggestionCommand = exports.canUseDirective = exports.DIAGNOSTIC_SEVERITY = exports.SEVERITY = exports.getVariableCompletions = exports.getTypeInfo = exports.getTokenAtPosition = exports.getRange = exports.getOutline = exports.getHoverInformation = exports.getFragmentDefinitions = exports.getFieldDef = exports.getDiagnostics = exports.getDefinitionState = exports.getDefinitionQueryResultForField = exports.getDefinitionQueryResultForNamedType = exports.getDefinitionQueryResultForFragmentSpread = exports.getDefinitionQueryResultForDefinitionNode = exports.getAutocompleteSuggestions = void 0;
      var interface_1 = require_interface();
      Object.defineProperty(exports, "getAutocompleteSuggestions", { enumerable: true, get: function() {
        return interface_1.getAutocompleteSuggestions;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForDefinitionNode", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForDefinitionNode;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForFragmentSpread", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForFragmentSpread;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForNamedType", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForNamedType;
      } });
      Object.defineProperty(exports, "getDefinitionQueryResultForField", { enumerable: true, get: function() {
        return interface_1.getDefinitionQueryResultForField;
      } });
      Object.defineProperty(exports, "getDefinitionState", { enumerable: true, get: function() {
        return interface_1.getDefinitionState;
      } });
      Object.defineProperty(exports, "getDiagnostics", { enumerable: true, get: function() {
        return interface_1.getDiagnostics;
      } });
      Object.defineProperty(exports, "getFieldDef", { enumerable: true, get: function() {
        return interface_1.getFieldDef;
      } });
      Object.defineProperty(exports, "getFragmentDefinitions", { enumerable: true, get: function() {
        return interface_1.getFragmentDefinitions;
      } });
      Object.defineProperty(exports, "getHoverInformation", { enumerable: true, get: function() {
        return interface_1.getHoverInformation;
      } });
      Object.defineProperty(exports, "getOutline", { enumerable: true, get: function() {
        return interface_1.getOutline;
      } });
      Object.defineProperty(exports, "getRange", { enumerable: true, get: function() {
        return interface_1.getRange;
      } });
      Object.defineProperty(exports, "getTokenAtPosition", { enumerable: true, get: function() {
        return interface_1.getTokenAtPosition;
      } });
      Object.defineProperty(exports, "getTypeInfo", { enumerable: true, get: function() {
        return interface_1.getTypeInfo;
      } });
      Object.defineProperty(exports, "getVariableCompletions", { enumerable: true, get: function() {
        return interface_1.getVariableCompletions;
      } });
      Object.defineProperty(exports, "SEVERITY", { enumerable: true, get: function() {
        return interface_1.SEVERITY;
      } });
      Object.defineProperty(exports, "DIAGNOSTIC_SEVERITY", { enumerable: true, get: function() {
        return interface_1.DIAGNOSTIC_SEVERITY;
      } });
      Object.defineProperty(exports, "canUseDirective", { enumerable: true, get: function() {
        return interface_1.canUseDirective;
      } });
      Object.defineProperty(exports, "SuggestionCommand", { enumerable: true, get: function() {
        return interface_1.SuggestionCommand;
      } });
      Object.defineProperty(exports, "validateQuery", { enumerable: true, get: function() {
        return interface_1.validateQuery;
      } });
      var parser_1 = require_parser2();
      Object.defineProperty(exports, "onlineParser", { enumerable: true, get: function() {
        return parser_1.onlineParser;
      } });
      Object.defineProperty(exports, "ParseRules", { enumerable: true, get: function() {
        return parser_1.ParseRules;
      } });
      Object.defineProperty(exports, "CharacterStream", { enumerable: true, get: function() {
        return parser_1.CharacterStream;
      } });
      Object.defineProperty(exports, "RuleKinds", { enumerable: true, get: function() {
        return parser_1.RuleKinds;
      } });
      Object.defineProperty(exports, "LexRules", { enumerable: true, get: function() {
        return parser_1.LexRules;
      } });
      Object.defineProperty(exports, "isIgnored", { enumerable: true, get: function() {
        return parser_1.isIgnored;
      } });
      Object.defineProperty(exports, "p", { enumerable: true, get: function() {
        return parser_1.p;
      } });
      Object.defineProperty(exports, "list", { enumerable: true, get: function() {
        return parser_1.list;
      } });
      Object.defineProperty(exports, "t", { enumerable: true, get: function() {
        return parser_1.t;
      } });
      Object.defineProperty(exports, "opt", { enumerable: true, get: function() {
        return parser_1.opt;
      } });
      var types_1 = require_types();
      Object.defineProperty(exports, "CompletionItemKind", { enumerable: true, get: function() {
        return types_1.CompletionItemKind;
      } });
      Object.defineProperty(exports, "FileChangeTypeKind", { enumerable: true, get: function() {
        return types_1.FileChangeTypeKind;
      } });
      var utils_1 = require_utils();
      Object.defineProperty(exports, "getASTNodeAtPosition", { enumerable: true, get: function() {
        return utils_1.getASTNodeAtPosition;
      } });
      Object.defineProperty(exports, "getFragmentDependencies", { enumerable: true, get: function() {
        return utils_1.getFragmentDependencies;
      } });
      Object.defineProperty(exports, "getFragmentDependenciesForAST", { enumerable: true, get: function() {
        return utils_1.getFragmentDependenciesForAST;
      } });
      Object.defineProperty(exports, "getOperationASTFacts", { enumerable: true, get: function() {
        return utils_1.getOperationASTFacts;
      } });
      Object.defineProperty(exports, "getOperationFacts", { enumerable: true, get: function() {
        return utils_1.getOperationFacts;
      } });
      Object.defineProperty(exports, "getQueryFacts", { enumerable: true, get: function() {
        return utils_1.getQueryFacts;
      } });
      Object.defineProperty(exports, "getVariablesJSONSchema", { enumerable: true, get: function() {
        return utils_1.getVariablesJSONSchema;
      } });
      Object.defineProperty(exports, "offsetToPosition", { enumerable: true, get: function() {
        return utils_1.offsetToPosition;
      } });
      Object.defineProperty(exports, "pointToOffset", { enumerable: true, get: function() {
        return utils_1.pointToOffset;
      } });
      Object.defineProperty(exports, "Position", { enumerable: true, get: function() {
        return utils_1.Position;
      } });
      Object.defineProperty(exports, "collectVariables", { enumerable: true, get: function() {
        return utils_1.collectVariables;
      } });
      Object.defineProperty(exports, "validateWithCustomRules", { enumerable: true, get: function() {
        return utils_1.validateWithCustomRules;
      } });
      Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
        return utils_1.Range;
      } });
    }
  });

  // node_modules/picomatch-browser/lib/constants.js
  var require_constants = __commonJS({
    "node_modules/picomatch-browser/lib/constants.js"(exports, module) {
      "use strict";
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var SEP = "/";
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR,
        SEP
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
        SEP: "\\"
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        CHAR_0: 48,
        CHAR_9: 57,
        CHAR_UPPERCASE_A: 65,
        CHAR_LOWERCASE_A: 97,
        CHAR_UPPERCASE_Z: 90,
        CHAR_LOWERCASE_Z: 122,
        CHAR_LEFT_PARENTHESES: 40,
        CHAR_RIGHT_PARENTHESES: 41,
        CHAR_ASTERISK: 42,
        CHAR_AMPERSAND: 38,
        CHAR_AT: 64,
        CHAR_BACKWARD_SLASH: 92,
        CHAR_CARRIAGE_RETURN: 13,
        CHAR_CIRCUMFLEX_ACCENT: 94,
        CHAR_COLON: 58,
        CHAR_COMMA: 44,
        CHAR_DOT: 46,
        CHAR_DOUBLE_QUOTE: 34,
        CHAR_EQUAL: 61,
        CHAR_EXCLAMATION_MARK: 33,
        CHAR_FORM_FEED: 12,
        CHAR_FORWARD_SLASH: 47,
        CHAR_GRAVE_ACCENT: 96,
        CHAR_HASH: 35,
        CHAR_HYPHEN_MINUS: 45,
        CHAR_LEFT_ANGLE_BRACKET: 60,
        CHAR_LEFT_CURLY_BRACE: 123,
        CHAR_LEFT_SQUARE_BRACKET: 91,
        CHAR_LINE_FEED: 10,
        CHAR_NO_BREAK_SPACE: 160,
        CHAR_PERCENT: 37,
        CHAR_PLUS: 43,
        CHAR_QUESTION_MARK: 63,
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        CHAR_RIGHT_CURLY_BRACE: 125,
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        CHAR_SEMICOLON: 59,
        CHAR_SINGLE_QUOTE: 39,
        CHAR_SPACE: 32,
        CHAR_TAB: 9,
        CHAR_UNDERSCORE: 95,
        CHAR_VERTICAL_LINE: 124,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        globChars(win322) {
          return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    }
  });

  // node_modules/picomatch-browser/lib/utils.js
  var require_utils2 = __commonJS({
    "node_modules/picomatch-browser/lib/utils.js"(exports) {
      "use strict";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants();
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? "" : "^";
        const append = options.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
      exports.basename = (path, { windows } = {}) => {
        if (windows) {
          return path.replace(/[\\/]$/, "").replace(/.*[\\/]/, "");
        } else {
          return path.replace(/\/$/, "").replace(/.*\//, "");
        }
      };
    }
  });

  // node_modules/picomatch-browser/lib/scan.js
  var require_scan = __commonJS({
    "node_modules/picomatch-browser/lib/scan.js"(exports, module) {
      "use strict";
      var utils = require_utils2();
      var {
        CHAR_ASTERISK,
        CHAR_AT,
        CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH2,
        CHAR_COMMA,
        CHAR_DOT: CHAR_DOT2,
        CHAR_EXCLAMATION_MARK,
        CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH2,
        CHAR_LEFT_CURLY_BRACE,
        CHAR_LEFT_PARENTHESES,
        CHAR_LEFT_SQUARE_BRACKET,
        CHAR_PLUS,
        CHAR_QUESTION_MARK: CHAR_QUESTION_MARK2,
        CHAR_RIGHT_CURLY_BRACE,
        CHAR_RIGHT_PARENTHESES,
        CHAR_RIGHT_SQUARE_BRACKET
      } = require_constants();
      var isPathSeparator2 = (code) => {
        return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
      };
      var depth = (token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      };
      var scan = (input, options) => {
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = () => index >= length;
        const peek = () => str.charCodeAt(index + 1);
        const advance = () => {
          prev = code;
          return str.charCodeAt(++index);
        };
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH2) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT2 && (code = advance()) === CHAR_DOT2) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH2) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true)
              continue;
            if (prev === CHAR_DOT2 && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK2 || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH2) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
              isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK2) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH2) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
            }
          }
          if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base = str;
        let prefix = "";
        let glob = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex);
          glob = str.slice(lastIndex);
        } else if (isGlob === true) {
          base = "";
          glob = str;
        } else {
          base = str;
        }
        if (base && base !== "" && base !== "/" && base !== str) {
          if (isPathSeparator2(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
          }
        }
        if (opts.unescape === true) {
          if (glob)
            glob = utils.removeBackslashes(glob);
          if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base,
          glob,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated
        };
        if (opts.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator2(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      };
      module.exports = scan;
    }
  });

  // node_modules/picomatch-browser/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/picomatch-browser/lib/parse.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var utils = require_utils2();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = (args, options) => {
        if (typeof options.expandRange === "function") {
          return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v) => utils.escapeRegex(v)).join("..");
        }
        return value;
      };
      var syntaxError = (type, char) => {
        return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
      };
      var parse = (input, options) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        const bos = { type: "bos", value: "", output: opts.prepend || "" };
        const tokens = [bos];
        const capture = opts.capture ? "" : "?:";
        const PLATFORM_CHARS = constants.globChars(opts.windows);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = (opts2) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? "" : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        if (typeof opts.noext === "boolean") {
          opts.noextglob = opts.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = () => state.index === len - 1;
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index];
        const remaining = () => input.slice(state.index + 1);
        const consume = (value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        };
        const append = (token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        };
        const negate = () => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        };
        const increment = (type) => {
          state[type]++;
          stack.push(type);
        };
        const decrement = (type) => {
          state[type]--;
          stack.pop();
        };
        const push = (tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output)
            append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        };
        const extglobOpen = (type, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output = (opts.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output });
          extglobs.push(token);
        };
        const extglobClose = (token) => {
          let output = token.close + (opts.capture ? ")" : "");
          if (token.type === "negate") {
            let extglobStar = star;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts);
            }
            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
              output = token.close = `)$))${extglobStar}`;
            }
            if (token.prev.type === "bos" && eos()) {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output });
          decrement("parens");
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star : "");
              }
              return star;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts.unescape === true) {
              output = output.replace(/\\/g, "");
            } else {
              output = output.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output === input && opts.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output, state, options);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match && match[0].length > 2) {
              slashes = match[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts.unescape === true) {
              value = advance() || "";
            } else {
              value += advance() || "";
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix2 = POSIX_REGEX_SOURCE[rest2];
                  if (posix2) {
                    prev.value = pre + posix2;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output = expandRange(range, opts);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output = "\\}";
              state.output = out;
              for (const t of toks) {
                state.output += t.output || t.value;
              }
            }
            push({ type: "brace", value, output });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output = "|";
            }
            push({ type: "comma", value, output });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".")
                prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output = `\\${value}`;
              }
              push({ type: "text", value, output });
              continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match) {
              value += match[0];
              state.index += match[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star };
          if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      };
      parse.fastpaths = (input, options) => {
        const opts = { ...options };
        const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
        }
        input = REPLACEMENTS[input] || input;
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(opts.windows);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star = opts.bash === true ? ".*?" : STAR;
        if (opts.capture) {
          star = `(${star})`;
        }
        const globstar = (opts2) => {
          if (opts2.noglobstar === true)
            return star;
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create = (str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*.*":
              return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "*/*":
              return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
            case "**":
              return nodot + globstar(opts);
            case "**/*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
            default: {
              const match = /^(.*?)\.(\w+)$/.exec(str);
              if (!match)
                return;
              const source2 = create(match[1]);
              if (!source2)
                return;
              return source2 + DOT_LITERAL + match[2];
            }
          }
        };
        const output = utils.removePrefix(input, state);
        let source = create(output);
        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module.exports = parse;
    }
  });

  // node_modules/picomatch-browser/lib/picomatch.js
  var require_picomatch = __commonJS({
    "node_modules/picomatch-browser/lib/picomatch.js"(exports, module) {
      "use strict";
      var scan = require_scan();
      var parse = require_parse();
      var utils = require_utils2();
      var constants = require_constants();
      var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
      var picomatch = (glob, options, returnState = false) => {
        if (Array.isArray(glob)) {
          const fns = glob.map((input) => picomatch(input, options, returnState));
          const arrayMatcher = (str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2)
                return state2;
            }
            return false;
          };
          return arrayMatcher;
        }
        const isState = isObject2(glob) && glob.tokens && glob.input;
        if (glob === "" || typeof glob !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts = options || {};
        const posix2 = opts.windows;
        const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = () => false;
        if (opts.ignore) {
          const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
          isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false) => {
          const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix2 });
          const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
          if (typeof opts.onResult === "function") {
            opts.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") {
              opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts.onMatch === "function") {
            opts.onMatch(result);
          }
          return returnObject ? result : true;
        };
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      };
      picomatch.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts = options || {};
        const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
        let match = input === glob;
        let output = match && format ? format(input) : input;
        if (match === false) {
          output = format ? format(input) : input;
          match = output === glob;
        }
        if (match === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match = picomatch.matchBase(input, regex, options, posix2);
          } else {
            match = regex.exec(output);
          }
        }
        return { isMatch: Boolean(match), match, output };
      };
      picomatch.matchBase = (input, glob, options) => {
        const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
        return regex.test(utils.basename(input));
      };
      picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
      picomatch.parse = (pattern, options) => {
        if (Array.isArray(pattern))
          return pattern.map((p) => picomatch.parse(p, options));
        return parse(pattern, { ...options, fastpaths: false });
      };
      picomatch.scan = (input, options) => scan(input, options);
      picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return parsed.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? "" : "^";
        const append = opts.contains ? "" : "$";
        let source = `${prepend}(?:${parsed.output})${append}`;
        if (parsed && parsed.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options);
        if (returnState === true) {
          regex.state = parsed;
        }
        return regex;
      };
      picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        const opts = options || {};
        let parsed = { negated: false, fastpaths: true };
        let prefix = "";
        let output;
        if (input.startsWith("./")) {
          input = input.slice(2);
          prefix = parsed.prefix = "./";
        }
        if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          output = parse.fastpaths(input, options);
        }
        if (output === void 0) {
          parsed = parse(input, options);
          parsed.prefix = prefix + (parsed.prefix || "");
        } else {
          parsed.output = output;
        }
        return picomatch.compileRe(parsed, options, returnOutput, returnState);
      };
      picomatch.toRegex = (source, options) => {
        try {
          const opts = options || {};
          return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
        } catch (err) {
          if (options && options.debug === true)
            throw err;
          return /$^/;
        }
      };
      picomatch.constants = constants;
      module.exports = picomatch;
    }
  });

  // node_modules/picomatch-browser/index.js
  var require_picomatch_browser = __commonJS({
    "node_modules/picomatch-browser/index.js"(exports, module) {
      "use strict";
      module.exports = require_picomatch();
    }
  });

  // node_modules/monaco-graphql/dist/schemaLoader.js
  var require_schemaLoader = __commonJS({
    "node_modules/monaco-graphql/dist/schemaLoader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultSchemaLoader = void 0;
      var graphql_1 = require_graphql2();
      var defaultSchemaLoader = function(schemaConfig, parser) {
        var schema = schemaConfig.schema, documentAST = schemaConfig.documentAST, introspectionJSON = schemaConfig.introspectionJSON, introspectionJSONString = schemaConfig.introspectionJSONString, buildSchemaOptions = schemaConfig.buildSchemaOptions, documentString = schemaConfig.documentString;
        if (schema) {
          return schema;
        }
        if (introspectionJSONString) {
          var introspectionJSONResult = JSON.parse(introspectionJSONString);
          return (0, graphql_1.buildClientSchema)(introspectionJSONResult, buildSchemaOptions);
        }
        if (documentString && parser) {
          var docAST = parser(documentString);
          return (0, graphql_1.buildASTSchema)(docAST, buildSchemaOptions);
        }
        if (introspectionJSON) {
          return (0, graphql_1.buildClientSchema)(introspectionJSON, buildSchemaOptions);
        }
        if (documentAST) {
          return (0, graphql_1.buildASTSchema)(documentAST, buildSchemaOptions);
        }
        throw new Error("no schema supplied");
      };
      exports.defaultSchemaLoader = defaultSchemaLoader;
    }
  });

  // node_modules/monaco-graphql/dist/LanguageService.js
  var require_LanguageService = __commonJS({
    "node_modules/monaco-graphql/dist/LanguageService.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LanguageService = void 0;
      var graphql_1 = require_graphql2();
      var picomatch_browser_1 = __importDefault(require_picomatch_browser());
      var graphql_language_service_1 = require_dist();
      var schemaLoader_1 = require_schemaLoader();
      var schemaCache = /* @__PURE__ */ new Map();
      var LanguageService = function() {
        function LanguageService2(_a3) {
          var parser = _a3.parser, schemas = _a3.schemas, parseOptions = _a3.parseOptions, externalFragmentDefinitions = _a3.externalFragmentDefinitions, customValidationRules = _a3.customValidationRules, fillLeafsOnComplete = _a3.fillLeafsOnComplete;
          var _this = this;
          this._parser = graphql_1.parse;
          this._schemas = [];
          this._schemaCache = schemaCache;
          this._schemaLoader = schemaLoader_1.defaultSchemaLoader;
          this._parseOptions = void 0;
          this._customValidationRules = void 0;
          this._externalFragmentDefinitionNodes = null;
          this._externalFragmentDefinitionsString = null;
          this._fillLeafsOnComplete = false;
          this.getCompletion = function(uri, documentText, position) {
            var schema = _this.getSchemaForFile(uri);
            if (!documentText || documentText.length < 1 || !(schema === null || schema === void 0 ? void 0 : schema.schema)) {
              return [];
            }
            return (0, graphql_language_service_1.getAutocompleteSuggestions)(schema.schema, documentText, position, void 0, _this.getExternalFragmentDefinitions(), { uri, fillLeafsOnComplete: _this._fillLeafsOnComplete });
          };
          this.getDiagnostics = function(uri, documentText, customRules) {
            var schema = _this.getSchemaForFile(uri);
            if (!documentText || documentText.trim().length < 2 || !(schema === null || schema === void 0 ? void 0 : schema.schema)) {
              return [];
            }
            return (0, graphql_language_service_1.getDiagnostics)(documentText, schema.schema, customRules !== null && customRules !== void 0 ? customRules : _this._customValidationRules, false, _this.getExternalFragmentDefinitions());
          };
          this.getHover = function(uri, documentText, position, options) {
            var schema = _this.getSchemaForFile(uri);
            if (schema && (documentText === null || documentText === void 0 ? void 0 : documentText.length) > 3) {
              return (0, graphql_language_service_1.getHoverInformation)(schema.schema, documentText, position, void 0, __assign({ useMarkdown: true }, options));
            }
          };
          this.getVariablesJSONSchema = function(uri, documentText, options) {
            var schema = _this.getSchemaForFile(uri);
            if (schema && documentText.length > 3) {
              try {
                var documentAST = _this.parse(documentText);
                var operationFacts = (0, graphql_language_service_1.getOperationASTFacts)(documentAST, schema.schema);
                if (operationFacts === null || operationFacts === void 0 ? void 0 : operationFacts.variableToType) {
                  return (0, graphql_language_service_1.getVariablesJSONSchema)(operationFacts.variableToType, options);
                }
              } catch (_a4) {
              }
            }
            return null;
          };
          this._schemaLoader = schemaLoader_1.defaultSchemaLoader;
          if (schemas) {
            this._schemas = schemas;
            this._cacheSchemas();
          }
          if (parser) {
            this._parser = parser;
          }
          this._fillLeafsOnComplete = fillLeafsOnComplete;
          if (parseOptions) {
            this._parseOptions = parseOptions;
          }
          if (customValidationRules) {
            this._customValidationRules = customValidationRules;
          }
          if (externalFragmentDefinitions) {
            if (Array.isArray(externalFragmentDefinitions)) {
              this._externalFragmentDefinitionNodes = externalFragmentDefinitions;
            } else {
              this._externalFragmentDefinitionsString = externalFragmentDefinitions;
            }
          }
        }
        LanguageService2.prototype._cacheSchemas = function() {
          var _this = this;
          this._schemas.forEach(function(schema) {
            return _this._cacheSchema(schema);
          });
        };
        LanguageService2.prototype._cacheSchema = function(schemaConfig) {
          var schema = this._schemaLoader(schemaConfig, this.parse.bind(this));
          return this._schemaCache.set(schemaConfig.uri, __assign(__assign({}, schemaConfig), { schema }));
        };
        LanguageService2.prototype.getSchemaForFile = function(uri) {
          if (!this._schemas || !this._schemas.length) {
            return;
          }
          if (this._schemas.length === 1) {
            return this._schemaCache.get(this._schemas[0].uri);
          }
          var schema = this._schemas.find(function(schemaConfig) {
            if (!schemaConfig.fileMatch) {
              return false;
            }
            return schemaConfig.fileMatch.some(function(glob) {
              var isMatch = (0, picomatch_browser_1.default)(glob);
              return isMatch(uri);
            });
          });
          if (schema) {
            var cacheEntry = this._schemaCache.get(schema.uri);
            if (cacheEntry) {
              return cacheEntry;
            }
            var cache = this._cacheSchema(schema);
            return cache.get(schema.uri);
          }
        };
        LanguageService2.prototype.getExternalFragmentDefinitions = function() {
          if (!this._externalFragmentDefinitionNodes && this._externalFragmentDefinitionsString) {
            var definitionNodes_1 = [];
            try {
              (0, graphql_1.visit)(this._parser(this._externalFragmentDefinitionsString), {
                FragmentDefinition: function(node) {
                  definitionNodes_1.push(node);
                }
              });
            } catch (_a3) {
              throw new Error("Failed parsing externalFragmentDefinitions string:\n".concat(this._externalFragmentDefinitionsString));
            }
            this._externalFragmentDefinitionNodes = definitionNodes_1;
          }
          return this._externalFragmentDefinitionNodes;
        };
        LanguageService2.prototype.updateSchemas = function(schemas) {
          return __awaiter3(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              this._schemas = schemas;
              this._cacheSchemas();
              return [2];
            });
          });
        };
        LanguageService2.prototype.updateSchema = function(schema) {
          var schemaIndex = this._schemas.findIndex(function(c) {
            return c.uri === schema.uri;
          });
          if (schemaIndex < 0) {
            console.warn("updateSchema could not find a schema in your config by that URI", schema.uri);
            return;
          }
          this._schemas[schemaIndex] = schema;
          this._cacheSchema(schema);
        };
        LanguageService2.prototype.addSchema = function(schema) {
          this._schemas.push(schema);
          this._cacheSchema(schema);
        };
        LanguageService2.prototype.parse = function(text, options) {
          return this._parser(text, options || this._parseOptions);
        };
        return LanguageService2;
      }();
      exports.LanguageService = LanguageService;
    }
  });

  // node_modules/monaco-graphql/dist/utils.js
  var require_utils3 = __commonJS({
    "node_modules/monaco-graphql/dist/utils.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getStringSchema = exports.toMarkerData = exports.toCompletion = exports.toGraphQLPosition = exports.toMonacoRange = exports.getModelLanguageId = void 0;
      var graphql_1 = require_graphql2();
      var graphql_language_service_1 = require_dist();
      var getModelLanguageId = function(model) {
        if ("getModeId" in model) {
          return model.getModeId();
        }
        return model.getLanguageId();
      };
      exports.getModelLanguageId = getModelLanguageId;
      function toMonacoRange(range) {
        return {
          startLineNumber: range.start.line + 1,
          startColumn: range.start.character + 1,
          endLineNumber: range.end.line + 1,
          endColumn: range.end.character + 1
        };
      }
      exports.toMonacoRange = toMonacoRange;
      function toGraphQLPosition(position) {
        return new graphql_language_service_1.Position(position.lineNumber - 1, position.column - 1);
      }
      exports.toGraphQLPosition = toGraphQLPosition;
      function toCompletion(entry, range) {
        var results = {
          label: entry.label,
          insertText: entry.insertText,
          insertTextFormat: entry.insertTextFormat,
          sortText: entry.sortText,
          filterText: entry.filterText,
          documentation: entry.documentation,
          detail: entry.detail,
          range: range ? toMonacoRange(range) : void 0,
          kind: entry.kind
        };
        if (entry.insertTextFormat) {
          results.insertTextFormat = entry.insertTextFormat;
        }
        if (entry.command) {
          results.command = __assign(__assign({}, entry.command), { id: entry.command.command });
        }
        return results;
      }
      exports.toCompletion = toCompletion;
      function toMarkerData(diagnostic) {
        return {
          startLineNumber: diagnostic.range.start.line + 1,
          endLineNumber: diagnostic.range.end.line + 1,
          startColumn: diagnostic.range.start.character + 1,
          endColumn: diagnostic.range.end.character,
          message: diagnostic.message,
          severity: 5,
          code: diagnostic.code || void 0
        };
      }
      exports.toMarkerData = toMarkerData;
      var getStringSchema = function(schemaConfig) {
        var graphQLSchema = schemaConfig.schema, documentAST = schemaConfig.documentAST, introspectionJSON = schemaConfig.introspectionJSON, introspectionJSONString = schemaConfig.introspectionJSONString, documentString = schemaConfig.documentString, rest = __rest(schemaConfig, ["schema", "documentAST", "introspectionJSON", "introspectionJSONString", "documentString"]);
        if (graphQLSchema) {
          return __assign(__assign({}, rest), { documentString: (0, graphql_1.printSchema)(graphQLSchema) });
        }
        if (introspectionJSONString) {
          return __assign(__assign({}, rest), { introspectionJSONString });
        }
        if (documentString) {
          return __assign(__assign({}, rest), { documentString });
        }
        if (introspectionJSON) {
          return __assign(__assign({}, rest), { introspectionJSONString: JSON.stringify(introspectionJSON) });
        }
        if (documentAST) {
          var schema = (0, graphql_1.buildASTSchema)(documentAST, rest.buildSchemaOptions);
          return __assign(__assign({}, rest), { documentString: (0, graphql_1.printSchema)(schema) });
        }
        throw new Error("no schema supplied");
      };
      exports.getStringSchema = getStringSchema;
    }
  });

  // node_modules/prettier/standalone.js
  var require_standalone = __commonJS({
    "node_modules/prettier/standalone.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          f.prettier = e();
        }
      })(function() {
        "use strict";
        var xe = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
        var pt = xe((r0, pu) => {
          var ir = function(e) {
            return e && e.Math == Math && e;
          };
          pu.exports = ir(typeof globalThis == "object" && globalThis) || ir(typeof window == "object" && window) || ir(typeof self == "object" && self) || ir(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        });
        var Dt = xe((n0, fu) => {
          fu.exports = function(e) {
            try {
              return !!e();
            } catch {
              return true;
            }
          };
        });
        var yt = xe((u0, Du) => {
          var Mo = Dt();
          Du.exports = !Mo(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        });
        var ar = xe((s0, mu) => {
          var Ro = Dt();
          mu.exports = !Ro(function() {
            var e = function() {
            }.bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
          });
        });
        var At = xe((i0, du) => {
          var $o = ar(), or = Function.prototype.call;
          du.exports = $o ? or.bind(or) : function() {
            return or.apply(or, arguments);
          };
        });
        var vu = xe((hu) => {
          "use strict";
          var gu = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo = yu && !gu.call({ 1: 2 }, 1);
          hu.f = Vo ? function(r) {
            var t = yu(this, r);
            return !!t && t.enumerable;
          } : gu;
        });
        var lr = xe((o0, Cu) => {
          Cu.exports = function(e, r) {
            return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
          };
        });
        var mt = xe((l0, Au) => {
          var Eu = ar(), Fu = Function.prototype, Wr = Fu.call, Wo = Eu && Fu.bind.bind(Wr, Wr);
          Au.exports = Eu ? Wo : function(e) {
            return function() {
              return Wr.apply(e, arguments);
            };
          };
        });
        var Vt = xe((c0, xu) => {
          var Su = mt(), Ho = Su({}.toString), Go = Su("".slice);
          xu.exports = function(e) {
            return Go(Ho(e), 8, -1);
          };
        });
        var Tu = xe((p0, bu) => {
          var Uo = mt(), Jo = Dt(), zo = Vt(), Hr = Object, Xo = Uo("".split);
          bu.exports = Jo(function() {
            return !Hr("z").propertyIsEnumerable(0);
          }) ? function(e) {
            return zo(e) == "String" ? Xo(e, "") : Hr(e);
          } : Hr;
        });
        var cr = xe((f0, Bu) => {
          Bu.exports = function(e) {
            return e == null;
          };
        });
        var Gr = xe((D0, Nu) => {
          var Ko = cr(), Yo = TypeError;
          Nu.exports = function(e) {
            if (Ko(e))
              throw Yo("Can't call method on " + e);
            return e;
          };
        });
        var pr = xe((m0, wu) => {
          var Qo = Tu(), Zo = Gr();
          wu.exports = function(e) {
            return Qo(Zo(e));
          };
        });
        var Jr = xe((d0, _u) => {
          var Ur = typeof document == "object" && document.all, el = typeof Ur > "u" && Ur !== void 0;
          _u.exports = { all: Ur, IS_HTMLDDA: el };
        });
        var ot = xe((g0, Iu) => {
          var Pu = Jr(), tl = Pu.all;
          Iu.exports = Pu.IS_HTMLDDA ? function(e) {
            return typeof e == "function" || e === tl;
          } : function(e) {
            return typeof e == "function";
          };
        });
        var St = xe((y0, Ou) => {
          var ku = ot(), Lu = Jr(), rl = Lu.all;
          Ou.exports = Lu.IS_HTMLDDA ? function(e) {
            return typeof e == "object" ? e !== null : ku(e) || e === rl;
          } : function(e) {
            return typeof e == "object" ? e !== null : ku(e);
          };
        });
        var Wt = xe((h0, ju) => {
          var zr = pt(), nl = ot(), ul = function(e) {
            return nl(e) ? e : void 0;
          };
          ju.exports = function(e, r) {
            return arguments.length < 2 ? ul(zr[e]) : zr[e] && zr[e][r];
          };
        });
        var Xr = xe((v0, qu) => {
          var sl = mt();
          qu.exports = sl({}.isPrototypeOf);
        });
        var Ru = xe((C0, Mu) => {
          var il = Wt();
          Mu.exports = il("navigator", "userAgent") || "";
        });
        var Ju = xe((E0, Uu) => {
          var Gu = pt(), Kr = Ru(), $u = Gu.process, Vu = Gu.Deno, Wu = $u && $u.versions || Vu && Vu.version, Hu = Wu && Wu.v8, dt, fr;
          Hu && (dt = Hu.split("."), fr = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));
          !fr && Kr && (dt = Kr.match(/Edge\/(\d+)/), (!dt || dt[1] >= 74) && (dt = Kr.match(/Chrome\/(\d+)/), dt && (fr = +dt[1])));
          Uu.exports = fr;
        });
        var Yr = xe((F0, Xu) => {
          var zu = Ju(), al = Dt();
          Xu.exports = !!Object.getOwnPropertySymbols && !al(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
          });
        });
        var Qr = xe((A0, Ku) => {
          var ol = Yr();
          Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == "symbol";
        });
        var Zr = xe((S0, Yu) => {
          var ll = Wt(), cl = ot(), pl = Xr(), fl = Qr(), Dl = Object;
          Yu.exports = fl ? function(e) {
            return typeof e == "symbol";
          } : function(e) {
            var r = ll("Symbol");
            return cl(r) && pl(r.prototype, Dl(e));
          };
        });
        var Dr = xe((x0, Qu) => {
          var ml = String;
          Qu.exports = function(e) {
            try {
              return ml(e);
            } catch {
              return "Object";
            }
          };
        });
        var Ht = xe((b0, Zu) => {
          var dl = ot(), gl = Dr(), yl = TypeError;
          Zu.exports = function(e) {
            if (dl(e))
              return e;
            throw yl(gl(e) + " is not a function");
          };
        });
        var mr = xe((T0, es) => {
          var hl = Ht(), vl = cr();
          es.exports = function(e, r) {
            var t = e[r];
            return vl(t) ? void 0 : hl(t);
          };
        });
        var rs = xe((B0, ts) => {
          var en = At(), tn = ot(), rn = St(), Cl = TypeError;
          ts.exports = function(e, r) {
            var t, s;
            if (r === "string" && tn(t = e.toString) && !rn(s = en(t, e)) || tn(t = e.valueOf) && !rn(s = en(t, e)) || r !== "string" && tn(t = e.toString) && !rn(s = en(t, e)))
              return s;
            throw Cl("Can't convert object to primitive value");
          };
        });
        var us = xe((N0, ns) => {
          ns.exports = false;
        });
        var dr = xe((w0, is) => {
          var ss = pt(), El = Object.defineProperty;
          is.exports = function(e, r) {
            try {
              El(ss, e, { value: r, configurable: true, writable: true });
            } catch {
              ss[e] = r;
            }
            return r;
          };
        });
        var gr = xe((_0, os) => {
          var Fl = pt(), Al = dr(), as = "__core-js_shared__", Sl = Fl[as] || Al(as, {});
          os.exports = Sl;
        });
        var nn = xe((P0, cs) => {
          var xl = us(), ls = gr();
          (cs.exports = function(e, r) {
            return ls[e] || (ls[e] = r !== void 0 ? r : {});
          })("versions", []).push({ version: "3.26.1", mode: xl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
        });
        var yr = xe((I0, ps) => {
          var bl = Gr(), Tl = Object;
          ps.exports = function(e) {
            return Tl(bl(e));
          };
        });
        var Ct = xe((k0, fs) => {
          var Bl = mt(), Nl = yr(), wl = Bl({}.hasOwnProperty);
          fs.exports = Object.hasOwn || function(r, t) {
            return wl(Nl(r), t);
          };
        });
        var un = xe((L0, Ds) => {
          var _l = mt(), Pl = 0, Il = Math.random(), kl = _l(1 .toString);
          Ds.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + kl(++Pl + Il, 36);
          };
        });
        var bt = xe((O0, hs) => {
          var Ll = pt(), Ol = nn(), ms = Ct(), jl = un(), ds = Yr(), ys = Qr(), It = Ol("wks"), xt = Ll.Symbol, gs = xt && xt.for, ql = ys ? xt : xt && xt.withoutSetter || jl;
          hs.exports = function(e) {
            if (!ms(It, e) || !(ds || typeof It[e] == "string")) {
              var r = "Symbol." + e;
              ds && ms(xt, e) ? It[e] = xt[e] : ys && gs ? It[e] = gs(r) : It[e] = ql(r);
            }
            return It[e];
          };
        });
        var Fs = xe((j0, Es) => {
          var Ml = At(), vs = St(), Cs = Zr(), Rl = mr(), $l = rs(), Vl = bt(), Wl = TypeError, Hl = Vl("toPrimitive");
          Es.exports = function(e, r) {
            if (!vs(e) || Cs(e))
              return e;
            var t = Rl(e, Hl), s;
            if (t) {
              if (r === void 0 && (r = "default"), s = Ml(t, e, r), !vs(s) || Cs(s))
                return s;
              throw Wl("Can't convert object to primitive value");
            }
            return r === void 0 && (r = "number"), $l(e, r);
          };
        });
        var hr = xe((q0, As) => {
          var Gl = Fs(), Ul = Zr();
          As.exports = function(e) {
            var r = Gl(e, "string");
            return Ul(r) ? r : r + "";
          };
        });
        var bs = xe((M0, xs) => {
          var Jl = pt(), Ss = St(), sn = Jl.document, zl = Ss(sn) && Ss(sn.createElement);
          xs.exports = function(e) {
            return zl ? sn.createElement(e) : {};
          };
        });
        var an = xe((R0, Ts) => {
          var Xl = yt(), Kl = Dt(), Yl = bs();
          Ts.exports = !Xl && !Kl(function() {
            return Object.defineProperty(Yl("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        });
        var on = xe((Ns) => {
          var Ql = yt(), Zl = At(), ec = vu(), tc = lr(), rc = pr(), nc = hr(), uc = Ct(), sc = an(), Bs = Object.getOwnPropertyDescriptor;
          Ns.f = Ql ? Bs : function(r, t) {
            if (r = rc(r), t = nc(t), sc)
              try {
                return Bs(r, t);
              } catch {
              }
            if (uc(r, t))
              return tc(!Zl(ec.f, r, t), r[t]);
          };
        });
        var _s = xe((V0, ws) => {
          var ic = yt(), ac = Dt();
          ws.exports = ic && ac(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        });
        var Tt = xe((W0, Ps) => {
          var oc = St(), lc = String, cc = TypeError;
          Ps.exports = function(e) {
            if (oc(e))
              return e;
            throw cc(lc(e) + " is not an object");
          };
        });
        var kt = xe((ks) => {
          var pc = yt(), fc = an(), Dc = _s(), vr = Tt(), Is = hr(), mc = TypeError, ln = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn = "enumerable", pn = "configurable", fn = "writable";
          ks.f = pc ? Dc ? function(r, t, s) {
            if (vr(r), t = Is(t), vr(s), typeof r == "function" && t === "prototype" && "value" in s && fn in s && !s[fn]) {
              var a = dc(r, t);
              a && a[fn] && (r[t] = s.value, s = { configurable: pn in s ? s[pn] : a[pn], enumerable: cn in s ? s[cn] : a[cn], writable: false });
            }
            return ln(r, t, s);
          } : ln : function(r, t, s) {
            if (vr(r), t = Is(t), vr(s), fc)
              try {
                return ln(r, t, s);
              } catch {
              }
            if ("get" in s || "set" in s)
              throw mc("Accessors not supported");
            return "value" in s && (r[t] = s.value), r;
          };
        });
        var Dn = xe((G0, Ls) => {
          var gc = yt(), yc = kt(), hc = lr();
          Ls.exports = gc ? function(e, r, t) {
            return yc.f(e, r, hc(1, t));
          } : function(e, r, t) {
            return e[r] = t, e;
          };
        });
        var qs = xe((U0, js) => {
          var mn = yt(), vc = Ct(), Os = Function.prototype, Cc = mn && Object.getOwnPropertyDescriptor, dn = vc(Os, "name"), Ec = dn && function() {
          }.name === "something", Fc = dn && (!mn || mn && Cc(Os, "name").configurable);
          js.exports = { EXISTS: dn, PROPER: Ec, CONFIGURABLE: Fc };
        });
        var yn = xe((J0, Ms) => {
          var Ac = mt(), Sc = ot(), gn = gr(), xc = Ac(Function.toString);
          Sc(gn.inspectSource) || (gn.inspectSource = function(e) {
            return xc(e);
          });
          Ms.exports = gn.inspectSource;
        });
        var Vs = xe((z0, $s) => {
          var bc = pt(), Tc = ot(), Rs = bc.WeakMap;
          $s.exports = Tc(Rs) && /native code/.test(String(Rs));
        });
        var Gs = xe((X0, Hs) => {
          var Bc = nn(), Nc = un(), Ws = Bc("keys");
          Hs.exports = function(e) {
            return Ws[e] || (Ws[e] = Nc(e));
          };
        });
        var hn = xe((K0, Us) => {
          Us.exports = {};
        });
        var Ks = xe((Y0, Xs) => {
          var wc = Vs(), zs = pt(), _c = St(), Pc = Dn(), vn = Ct(), Cn = gr(), Ic = Gs(), kc = hn(), Js = "Object already initialized", En = zs.TypeError, Lc = zs.WeakMap, Cr, Gt, Er, Oc = function(e) {
            return Er(e) ? Gt(e) : Cr(e, {});
          }, jc = function(e) {
            return function(r) {
              var t;
              if (!_c(r) || (t = Gt(r)).type !== e)
                throw En("Incompatible receiver, " + e + " required");
              return t;
            };
          };
          wc || Cn.state ? (gt = Cn.state || (Cn.state = new Lc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, Cr = function(e, r) {
            if (gt.has(e))
              throw En(Js);
            return r.facade = e, gt.set(e, r), r;
          }, Gt = function(e) {
            return gt.get(e) || {};
          }, Er = function(e) {
            return gt.has(e);
          }) : (Bt = Ic("state"), kc[Bt] = true, Cr = function(e, r) {
            if (vn(e, Bt))
              throw En(Js);
            return r.facade = e, Pc(e, Bt, r), r;
          }, Gt = function(e) {
            return vn(e, Bt) ? e[Bt] : {};
          }, Er = function(e) {
            return vn(e, Bt);
          });
          var gt, Bt;
          Xs.exports = { set: Cr, get: Gt, has: Er, enforce: Oc, getterFor: jc };
        });
        var An = xe((Q0, Qs) => {
          var qc = Dt(), Mc = ot(), Fr = Ct(), Fn = yt(), Rc = qs().CONFIGURABLE, $c = yn(), Ys = Ks(), Vc = Ys.enforce, Wc = Ys.get, Ar = Object.defineProperty, Hc = Fn && !qc(function() {
            return Ar(function() {
            }, "length", { value: 8 }).length !== 8;
          }), Gc = String(String).split("String"), Uc = Qs.exports = function(e, r, t) {
            String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Fr(e, "name") || Rc && e.name !== r) && (Fn ? Ar(e, "name", { value: r, configurable: true }) : e.name = r), Hc && t && Fr(t, "arity") && e.length !== t.arity && Ar(e, "length", { value: t.arity });
            try {
              t && Fr(t, "constructor") && t.constructor ? Fn && Ar(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
            } catch {
            }
            var s = Vc(e);
            return Fr(s, "source") || (s.source = Gc.join(typeof r == "string" ? r : "")), e;
          };
          Function.prototype.toString = Uc(function() {
            return Mc(this) && Wc(this).source || $c(this);
          }, "toString");
        });
        var ei = xe((Z0, Zs) => {
          var Jc = ot(), zc = kt(), Xc = An(), Kc = dr();
          Zs.exports = function(e, r, t, s) {
            s || (s = {});
            var a = s.enumerable, n = s.name !== void 0 ? s.name : r;
            if (Jc(t) && Xc(t, n, s), s.global)
              a ? e[r] = t : Kc(r, t);
            else {
              try {
                s.unsafe ? e[r] && (a = true) : delete e[r];
              } catch {
              }
              a ? e[r] = t : zc.f(e, r, { value: t, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
            }
            return e;
          };
        });
        var ri = xe((ey, ti) => {
          var Yc = Math.ceil, Qc = Math.floor;
          ti.exports = Math.trunc || function(r) {
            var t = +r;
            return (t > 0 ? Qc : Yc)(t);
          };
        });
        var Sr = xe((ty, ni) => {
          var Zc = ri();
          ni.exports = function(e) {
            var r = +e;
            return r !== r || r === 0 ? 0 : Zc(r);
          };
        });
        var si = xe((ry, ui) => {
          var ep = Sr(), tp = Math.max, rp = Math.min;
          ui.exports = function(e, r) {
            var t = ep(e);
            return t < 0 ? tp(t + r, 0) : rp(t, r);
          };
        });
        var ai = xe((ny, ii) => {
          var np = Sr(), up = Math.min;
          ii.exports = function(e) {
            return e > 0 ? up(np(e), 9007199254740991) : 0;
          };
        });
        var Lt = xe((uy, oi) => {
          var sp = ai();
          oi.exports = function(e) {
            return sp(e.length);
          };
        });
        var pi = xe((sy, ci) => {
          var ip = pr(), ap = si(), op = Lt(), li = function(e) {
            return function(r, t, s) {
              var a = ip(r), n = op(a), u = ap(s, n), i;
              if (e && t != t) {
                for (; n > u; )
                  if (i = a[u++], i != i)
                    return true;
              } else
                for (; n > u; u++)
                  if ((e || u in a) && a[u] === t)
                    return e || u || 0;
              return !e && -1;
            };
          };
          ci.exports = { includes: li(true), indexOf: li(false) };
        });
        var mi = xe((iy, Di) => {
          var lp = mt(), Sn = Ct(), cp = pr(), pp = pi().indexOf, fp = hn(), fi = lp([].push);
          Di.exports = function(e, r) {
            var t = cp(e), s = 0, a = [], n;
            for (n in t)
              !Sn(fp, n) && Sn(t, n) && fi(a, n);
            for (; r.length > s; )
              Sn(t, n = r[s++]) && (~pp(a, n) || fi(a, n));
            return a;
          };
        });
        var gi = xe((ay, di) => {
          di.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        });
        var hi = xe((yi) => {
          var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
          yi.f = Object.getOwnPropertyNames || function(r) {
            return Dp(r, dp);
          };
        });
        var Ci = xe((vi) => {
          vi.f = Object.getOwnPropertySymbols;
        });
        var Fi = xe((cy, Ei) => {
          var gp = Wt(), yp = mt(), hp = hi(), vp = Ci(), Cp = Tt(), Ep = yp([].concat);
          Ei.exports = gp("Reflect", "ownKeys") || function(r) {
            var t = hp.f(Cp(r)), s = vp.f;
            return s ? Ep(t, s(r)) : t;
          };
        });
        var xi = xe((py, Si) => {
          var Ai = Ct(), Fp = Fi(), Ap = on(), Sp = kt();
          Si.exports = function(e, r, t) {
            for (var s = Fp(r), a = Sp.f, n = Ap.f, u = 0; u < s.length; u++) {
              var i = s[u];
              !Ai(e, i) && !(t && Ai(t, i)) && a(e, i, n(r, i));
            }
          };
        });
        var Ti = xe((fy, bi) => {
          var xp = Dt(), bp = ot(), Tp = /#|\.prototype\./, Ut = function(e, r) {
            var t = Np[Bp(e)];
            return t == _p ? true : t == wp ? false : bp(r) ? xp(r) : !!r;
          }, Bp = Ut.normalize = function(e) {
            return String(e).replace(Tp, ".").toLowerCase();
          }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
          bi.exports = Ut;
        });
        var Jt = xe((Dy, Bi) => {
          var xn = pt(), Pp = on().f, Ip = Dn(), kp = ei(), Lp = dr(), Op = xi(), jp = Ti();
          Bi.exports = function(e, r) {
            var t = e.target, s = e.global, a = e.stat, n, u, i, l, p, y;
            if (s ? u = xn : a ? u = xn[t] || Lp(t, {}) : u = (xn[t] || {}).prototype, u)
              for (i in r) {
                if (p = r[i], e.dontCallGetSet ? (y = Pp(u, i), l = y && y.value) : l = u[i], n = jp(s ? i : t + (a ? "." : "#") + i, e.forced), !n && l !== void 0) {
                  if (typeof p == typeof l)
                    continue;
                  Op(p, l);
                }
                (e.sham || l && l.sham) && Ip(p, "sham", true), kp(u, i, p, e);
              }
          };
        });
        var bn = xe((my, Ni) => {
          var qp = Vt();
          Ni.exports = Array.isArray || function(r) {
            return qp(r) == "Array";
          };
        });
        var _i = xe((dy, wi) => {
          var Mp = TypeError, Rp = 9007199254740991;
          wi.exports = function(e) {
            if (e > Rp)
              throw Mp("Maximum allowed index exceeded");
            return e;
          };
        });
        var Ii = xe((gy, Pi) => {
          var $p = Vt(), Vp = mt();
          Pi.exports = function(e) {
            if ($p(e) === "Function")
              return Vp(e);
          };
        });
        var Tn = xe((yy, Li) => {
          var ki = Ii(), Wp = Ht(), Hp = ar(), Gp = ki(ki.bind);
          Li.exports = function(e, r) {
            return Wp(e), r === void 0 ? e : Hp ? Gp(e, r) : function() {
              return e.apply(r, arguments);
            };
          };
        });
        var Bn = xe((hy, ji) => {
          "use strict";
          var Up = bn(), Jp = Lt(), zp = _i(), Xp = Tn(), Oi = function(e, r, t, s, a, n, u, i) {
            for (var l = a, p = 0, y = u ? Xp(u, i) : false, h, g; p < s; )
              p in t && (h = y ? y(t[p], p, r) : t[p], n > 0 && Up(h) ? (g = Jp(h), l = Oi(e, r, h, g, l, n - 1) - 1) : (zp(l + 1), e[l] = h), l++), p++;
            return l;
          };
          ji.exports = Oi;
        });
        var Ri = xe((vy, Mi) => {
          var Kp = bt(), Yp = Kp("toStringTag"), qi = {};
          qi[Yp] = "z";
          Mi.exports = String(qi) === "[object z]";
        });
        var Nn = xe((Cy, $i) => {
          var Qp = Ri(), Zp = ot(), xr = Vt(), ef = bt(), tf = ef("toStringTag"), rf = Object, nf = xr(function() {
            return arguments;
          }()) == "Arguments", uf = function(e, r) {
            try {
              return e[r];
            } catch {
            }
          };
          $i.exports = Qp ? xr : function(e) {
            var r, t, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = uf(r = rf(e), tf)) == "string" ? t : nf ? xr(r) : (s = xr(r)) == "Object" && Zp(r.callee) ? "Arguments" : s;
          };
        });
        var Ji = xe((Ey, Ui) => {
          var sf = mt(), af = Dt(), Vi = ot(), of = Nn(), lf = Wt(), cf = yn(), Wi = function() {
          }, pf = [], Hi = lf("Reflect", "construct"), wn = /^\s*(?:class|function)\b/, ff = sf(wn.exec), Df = !wn.exec(Wi), zt = function(r) {
            if (!Vi(r))
              return false;
            try {
              return Hi(Wi, pf, r), true;
            } catch {
              return false;
            }
          }, Gi = function(r) {
            if (!Vi(r))
              return false;
            switch (of(r)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return Df || !!ff(wn, cf(r));
            } catch {
              return true;
            }
          };
          Gi.sham = true;
          Ui.exports = !Hi || af(function() {
            var e;
            return zt(zt.call) || !zt(Object) || !zt(function() {
              e = true;
            }) || e;
          }) ? Gi : zt;
        });
        var Yi = xe((Fy, Ki) => {
          var zi = bn(), mf = Ji(), df = St(), gf = bt(), yf = gf("species"), Xi = Array;
          Ki.exports = function(e) {
            var r;
            return zi(e) && (r = e.constructor, mf(r) && (r === Xi || zi(r.prototype)) ? r = void 0 : df(r) && (r = r[yf], r === null && (r = void 0))), r === void 0 ? Xi : r;
          };
        });
        var _n = xe((Ay, Qi) => {
          var hf = Yi();
          Qi.exports = function(e, r) {
            return new (hf(e))(r === 0 ? 0 : r);
          };
        });
        var Zi = xe(() => {
          "use strict";
          var vf = Jt(), Cf = Bn(), Ef = Ht(), Ff = yr(), Af = Lt(), Sf = _n();
          vf({ target: "Array", proto: true }, { flatMap: function(r) {
            var t = Ff(this), s = Af(t), a;
            return Ef(r), a = Sf(t, 0), a.length = Cf(a, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;
          } });
        });
        var Pn = xe((by, ea) => {
          ea.exports = {};
        });
        var ra = xe((Ty, ta) => {
          var xf = bt(), bf = Pn(), Tf = xf("iterator"), Bf = Array.prototype;
          ta.exports = function(e) {
            return e !== void 0 && (bf.Array === e || Bf[Tf] === e);
          };
        });
        var In = xe((By, ua) => {
          var Nf = Nn(), na = mr(), wf = cr(), _f = Pn(), Pf = bt(), If = Pf("iterator");
          ua.exports = function(e) {
            if (!wf(e))
              return na(e, If) || na(e, "@@iterator") || _f[Nf(e)];
          };
        });
        var ia = xe((Ny, sa) => {
          var kf = At(), Lf = Ht(), Of = Tt(), jf = Dr(), qf = In(), Mf = TypeError;
          sa.exports = function(e, r) {
            var t = arguments.length < 2 ? qf(e) : r;
            if (Lf(t))
              return Of(kf(t, e));
            throw Mf(jf(e) + " is not iterable");
          };
        });
        var la = xe((wy, oa) => {
          var Rf = At(), aa = Tt(), $f = mr();
          oa.exports = function(e, r, t) {
            var s, a;
            aa(e);
            try {
              if (s = $f(e, "return"), !s) {
                if (r === "throw")
                  throw t;
                return t;
              }
              s = Rf(s, e);
            } catch (n) {
              a = true, s = n;
            }
            if (r === "throw")
              throw t;
            if (a)
              throw s;
            return aa(s), t;
          };
        });
        var ma = xe((_y, Da) => {
          var Vf = Tn(), Wf = At(), Hf = Tt(), Gf = Dr(), Uf = ra(), Jf = Lt(), ca = Xr(), zf = ia(), Xf = In(), pa = la(), Kf = TypeError, br = function(e, r) {
            this.stopped = e, this.result = r;
          }, fa = br.prototype;
          Da.exports = function(e, r, t) {
            var s = t && t.that, a = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = Vf(r, s), p, y, h, g, c, f, F, _ = function(E) {
              return p && pa(p, "normal", E), new br(true, E);
            }, w = function(E) {
              return a ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);
            };
            if (n)
              p = e.iterator;
            else if (u)
              p = e;
            else {
              if (y = Xf(e), !y)
                throw Kf(Gf(e) + " is not iterable");
              if (Uf(y)) {
                for (h = 0, g = Jf(e); g > h; h++)
                  if (c = w(e[h]), c && ca(fa, c))
                    return c;
                return new br(false);
              }
              p = zf(e, y);
            }
            for (f = n ? e.next : p.next; !(F = Wf(f, p)).done; ) {
              try {
                c = w(F.value);
              } catch (E) {
                pa(p, "throw", E);
              }
              if (typeof c == "object" && c && ca(fa, c))
                return c;
            }
            return new br(false);
          };
        });
        var ga = xe((Py, da) => {
          "use strict";
          var Yf = hr(), Qf = kt(), Zf = lr();
          da.exports = function(e, r, t) {
            var s = Yf(r);
            s in e ? Qf.f(e, s, Zf(0, t)) : e[s] = t;
          };
        });
        var ya = xe(() => {
          var eD = Jt(), tD = ma(), rD = ga();
          eD({ target: "Object", stat: true }, { fromEntries: function(r) {
            var t = {};
            return tD(r, function(s, a) {
              rD(t, s, a);
            }, { AS_ENTRIES: true }), t;
          } });
        });
        var Ca = xe((Ly, va) => {
          var ha = An(), nD = kt();
          va.exports = function(e, r, t) {
            return t.get && ha(t.get, r, { getter: true }), t.set && ha(t.set, r, { setter: true }), nD.f(e, r, t);
          };
        });
        var Fa = xe((Oy, Ea) => {
          "use strict";
          var uD = Tt();
          Ea.exports = function() {
            var e = uD(this), r = "";
            return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
          };
        });
        var xa = xe(() => {
          var sD = pt(), iD = yt(), aD = Ca(), oD = Fa(), lD = Dt(), Aa = sD.RegExp, Sa = Aa.prototype, cD = iD && lD(function() {
            var e = true;
            try {
              Aa(".", "d");
            } catch {
              e = false;
            }
            var r = {}, t = "", s = e ? "dgimsy" : "gimsy", a = function(l, p) {
              Object.defineProperty(r, l, { get: function() {
                return t += p, true;
              } });
            }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
            e && (n.hasIndices = "d");
            for (var u in n)
              a(u, n[u]);
            var i = Object.getOwnPropertyDescriptor(Sa, "flags").get.call(r);
            return i !== s || t !== s;
          });
          cD && aD(Sa, "flags", { configurable: true, get: oD });
        });
        var ba = xe(() => {
          var pD = Jt(), kn = pt();
          pD({ global: true, forced: kn.globalThis !== kn }, { globalThis: kn });
        });
        var Ta = xe(() => {
          ba();
        });
        var Ba = xe(() => {
          "use strict";
          var fD = Jt(), DD = Bn(), mD = yr(), dD = Lt(), gD = Sr(), yD = _n();
          fD({ target: "Array", proto: true }, { flat: function() {
            var r = arguments.length ? arguments[0] : void 0, t = mD(this), s = dD(t), a = yD(t, 0);
            return a.length = DD(a, t, t, s, 0, r === void 0 ? 1 : gD(r)), a;
          } });
        });
        var e0 = xe((Uy, jo) => {
          var hD = ["cliName", "cliCategory", "cliDescription"], vD = ["_"], CD = ["languageId"];
          function Hn(e, r) {
            if (e == null)
              return {};
            var t = ED(e, r), s, a;
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (a = 0; a < n.length; a++)
                s = n[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t[s] = e[s]);
            }
            return t;
          }
          function ED(e, r) {
            if (e == null)
              return {};
            var t = {}, s = Object.keys(e), a, n;
            for (n = 0; n < s.length; n++)
              a = s[n], !(r.indexOf(a) >= 0) && (t[a] = e[a]);
            return t;
          }
          Zi();
          ya();
          xa();
          Ta();
          Ba();
          var FD = Object.create, _r = Object.defineProperty, AD = Object.getOwnPropertyDescriptor, Gn = Object.getOwnPropertyNames, SD = Object.getPrototypeOf, xD = Object.prototype.hasOwnProperty, ht = (e, r) => function() {
            return e && (r = (0, e[Gn(e)[0]])(e = 0)), r;
          }, te = (e, r) => function() {
            return r || (0, e[Gn(e)[0]])((r = { exports: {} }).exports, r), r.exports;
          }, Kt = (e, r) => {
            for (var t in r)
              _r(e, t, { get: r[t], enumerable: true });
          }, Pa = (e, r, t, s) => {
            if (r && typeof r == "object" || typeof r == "function")
              for (let a of Gn(r))
                !xD.call(e, a) && a !== t && _r(e, a, { get: () => r[a], enumerable: !(s = AD(r, a)) || s.enumerable });
            return e;
          }, bD = (e, r, t) => (t = e != null ? FD(SD(e)) : {}, Pa(r || !e || !e.__esModule ? _r(t, "default", { value: e, enumerable: true }) : t, e)), ft = (e) => Pa(_r({}, "__esModule", { value: true }), e), wt, ne = ht({ "<define:process>"() {
            wt = { env: {}, argv: [] };
          } }), Ia = te({ "package.json"(e, r) {
            r.exports = { version: "2.8.6" };
          } }), TD = te({ "node_modules/diff/lib/diff/base.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
            function r() {
            }
            r.prototype = { diff: function(n, u) {
              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
              typeof i == "function" && (l = i, i = {}), this.options = i;
              var p = this;
              function y(N) {
                return l ? (setTimeout(function() {
                  l(void 0, N);
                }, 0), true) : N;
              }
              n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
              var h = u.length, g = n.length, c = 1, f = h + g, F = [{ newPos: -1, components: [] }], _ = this.extractCommon(F[0], u, n, 0);
              if (F[0].newPos + 1 >= h && _ + 1 >= g)
                return y([{ value: this.join(u), count: u.length }]);
              function w() {
                for (var N = -1 * c; N <= c; N += 2) {
                  var x = void 0, I = F[N - 1], P = F[N + 1], $ = (P ? P.newPos : 0) - N;
                  I && (F[N - 1] = void 0);
                  var D = I && I.newPos + 1 < h, T = P && 0 <= $ && $ < g;
                  if (!D && !T) {
                    F[N] = void 0;
                    continue;
                  }
                  if (!D || T && I.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, true)) : (x = I, x.newPos++, p.pushComponent(x.components, true, void 0)), $ = p.extractCommon(x, u, n, N), x.newPos + 1 >= h && $ + 1 >= g)
                    return y(t(p, x.components, u, n, p.useLongestToken));
                  F[N] = x;
                }
                c++;
              }
              if (l)
                (function N() {
                  setTimeout(function() {
                    if (c > f)
                      return l();
                    w() || N();
                  }, 0);
                })();
              else
                for (; c <= f; ) {
                  var E = w();
                  if (E)
                    return E;
                }
            }, pushComponent: function(n, u, i) {
              var l = n[n.length - 1];
              l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
            }, extractCommon: function(n, u, i, l) {
              for (var p = u.length, y = i.length, h = n.newPos, g = h - l, c = 0; h + 1 < p && g + 1 < y && this.equals(u[h + 1], i[g + 1]); )
                h++, g++, c++;
              return c && n.components.push({ count: c }), n.newPos = h, g;
            }, equals: function(n, u) {
              return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
            }, removeEmpty: function(n) {
              for (var u = [], i = 0; i < n.length; i++)
                n[i] && u.push(n[i]);
              return u;
            }, castInput: function(n) {
              return n;
            }, tokenize: function(n) {
              return n.split("");
            }, join: function(n) {
              return n.join("");
            } };
            function t(a, n, u, i, l) {
              for (var p = 0, y = n.length, h = 0, g = 0; p < y; p++) {
                var c = n[p];
                if (c.removed) {
                  if (c.value = a.join(i.slice(g, g + c.count)), g += c.count, p && n[p - 1].added) {
                    var F = n[p - 1];
                    n[p - 1] = n[p], n[p] = F;
                  }
                } else {
                  if (!c.added && l) {
                    var f = u.slice(h, h + c.count);
                    f = f.map(function(w, E) {
                      var N = i[g + E];
                      return N.length > w.length ? N : w;
                    }), c.value = a.join(f);
                  } else
                    c.value = a.join(u.slice(h, h + c.count));
                  h += c.count, c.added || (g += c.count);
                }
              }
              var _ = n[y - 1];
              return y > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n[y - 2].value += _.value, n.pop()), n;
            }
            function s(a) {
              return { newPos: a.newPos, components: a.components.slice(0) };
            }
          } }), BD = te({ "node_modules/diff/lib/diff/array.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
            var r = t(TD());
            function t(n) {
              return n && n.__esModule ? n : { default: n };
            }
            var s = new r.default();
            e.arrayDiff = s, s.tokenize = function(n) {
              return n.slice();
            }, s.join = s.removeEmpty = function(n) {
              return n;
            };
            function a(n, u, i) {
              return s.diff(n, u, i);
            }
          } }), Un = te({ "src/document/doc-builders.js"(e, r) {
            "use strict";
            ne();
            function t(C) {
              return { type: "concat", parts: C };
            }
            function s(C) {
              return { type: "indent", contents: C };
            }
            function a(C, o) {
              return { type: "align", contents: o, n: C };
            }
            function n(C) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
            }
            function u(C) {
              return a(Number.NEGATIVE_INFINITY, C);
            }
            function i(C) {
              return a({ type: "root" }, C);
            }
            function l(C) {
              return a(-1, C);
            }
            function p(C, o) {
              return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
            }
            function y(C) {
              return { type: "fill", parts: C };
            }
            function h(C, o) {
              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return { type: "if-break", breakContents: C, flatContents: o, groupId: d.groupId };
            }
            function g(C, o) {
              return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
            }
            function c(C) {
              return { type: "line-suffix", contents: C };
            }
            var f = { type: "line-suffix-boundary" }, F = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N = { type: "line" }, x = { type: "line", soft: true }, I = t([w, F]), P = t([E, F]), $ = { type: "cursor", placeholder: Symbol("cursor") };
            function D(C, o) {
              let d = [];
              for (let v = 0; v < o.length; v++)
                v !== 0 && d.push(C), d.push(o[v]);
              return t(d);
            }
            function T(C, o, d) {
              let v = C;
              if (o > 0) {
                for (let S = 0; S < Math.floor(o / d); ++S)
                  v = s(v);
                v = a(o % d, v), v = a(Number.NEGATIVE_INFINITY, v);
              }
              return v;
            }
            function m(C, o) {
              return { type: "label", label: C, contents: o };
            }
            r.exports = { concat: t, join: D, line: N, softline: x, hardline: I, literalline: P, group: n, conditionalGroup: p, fill: y, lineSuffix: c, lineSuffixBoundary: f, cursor: $, breakParent: F, ifBreak: h, trim: _, indent: s, indentIfBreak: g, align: a, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: E, label: m };
          } }), Jn = te({ "src/common/end-of-line.js"(e, r) {
            "use strict";
            ne();
            function t(u) {
              let i = u.indexOf("\r");
              return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
            }
            function s(u) {
              switch (u) {
                case "cr":
                  return "\r";
                case "crlf":
                  return `\r
`;
                default:
                  return `
`;
              }
            }
            function a(u, i) {
              let l;
              switch (i) {
                case `
`:
                  l = /\n/g;
                  break;
                case "\r":
                  l = /\r/g;
                  break;
                case `\r
`:
                  l = /\r\n/g;
                  break;
                default:
                  throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
              }
              let p = u.match(l);
              return p ? p.length : 0;
            }
            function n(u) {
              return u.replace(/\r\n?/g, `
`);
            }
            r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n };
          } }), lt = te({ "src/utils/get-last.js"(e, r) {
            "use strict";
            ne();
            var t = (s) => s[s.length - 1];
            r.exports = t;
          } });
          function ND() {
            let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
            return new RegExp(r, e ? void 0 : "g");
          }
          var wD = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
            ne();
          } });
          function _D(e) {
            if (typeof e != "string")
              throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
            return e.replace(ND(), "");
          }
          var PD = ht({ "node_modules/strip-ansi/index.js"() {
            ne(), wD();
          } });
          function ID(e) {
            return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
          }
          var kD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
            ne();
          } }), LD = te({ "node_modules/emoji-regex/index.js"(e, r) {
            "use strict";
            ne(), r.exports = function() {
              return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
            };
          } }), ka = {};
          Kt(ka, { default: () => OD });
          function OD(e) {
            if (typeof e != "string" || e.length === 0 || (e = _D(e), e.length === 0))
              return 0;
            e = e.replace((0, La.default)(), "  ");
            let r = 0;
            for (let t = 0; t < e.length; t++) {
              let s = e.codePointAt(t);
              s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += ID(s) ? 2 : 1);
            }
            return r;
          }
          var La, jD = ht({ "node_modules/string-width/index.js"() {
            ne(), PD(), kD(), La = bD(LD());
          } }), Oa = te({ "src/utils/get-string-width.js"(e, r) {
            "use strict";
            ne();
            var t = (jD(), ft(ka)).default, s = /[^\x20-\x7F]/;
            function a(n) {
              return n ? s.test(n) ? t(n) : n.length : 0;
            }
            r.exports = a;
          } }), Yt = te({ "src/document/doc-utils.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { literalline: s, join: a } = Un(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
              if (Array.isArray(o))
                return o;
              if (o.type !== "concat" && o.type !== "fill")
                throw new Error("Expect doc type to be `concat` or `fill`.");
              return o.parts;
            }, i = {};
            function l(o, d, v, S) {
              let b = [o];
              for (; b.length > 0; ) {
                let B = b.pop();
                if (B === i) {
                  v(b.pop());
                  continue;
                }
                if (v && b.push(B, i), !d || d(B) !== false)
                  if (n(B) || B.type === "fill") {
                    let k = u(B);
                    for (let M = k.length, R = M - 1; R >= 0; --R)
                      b.push(k[R]);
                  } else if (B.type === "if-break")
                    B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
                  else if (B.type === "group" && B.expandedStates)
                    if (S)
                      for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M)
                        b.push(B.expandedStates[M]);
                    else
                      b.push(B.contents);
                  else
                    B.contents && b.push(B.contents);
              }
            }
            function p(o, d) {
              let v = /* @__PURE__ */ new Map();
              return S(o);
              function S(B) {
                if (v.has(B))
                  return v.get(B);
                let k = b(B);
                return v.set(B, k), k;
              }
              function b(B) {
                if (Array.isArray(B))
                  return d(B.map(S));
                if (B.type === "concat" || B.type === "fill") {
                  let k = B.parts.map(S);
                  return d(Object.assign(Object.assign({}, B), {}, { parts: k }));
                }
                if (B.type === "if-break") {
                  let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
                  return d(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
                }
                if (B.type === "group" && B.expandedStates) {
                  let k = B.expandedStates.map(S), M = k[0];
                  return d(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
                }
                if (B.contents) {
                  let k = S(B.contents);
                  return d(Object.assign(Object.assign({}, B), {}, { contents: k }));
                }
                return d(B);
              }
            }
            function y(o, d, v) {
              let S = v, b = false;
              function B(k) {
                let M = d(k);
                if (M !== void 0 && (b = true, S = M), b)
                  return false;
              }
              return l(o, B), S;
            }
            function h(o) {
              if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
                return true;
            }
            function g(o) {
              return y(o, h, false);
            }
            function c(o) {
              if (o.length > 0) {
                let d = t(o);
                !d.expandedStates && !d.break && (d.break = "propagated");
              }
              return null;
            }
            function f(o) {
              let d = /* @__PURE__ */ new Set(), v = [];
              function S(B) {
                if (B.type === "break-parent" && c(v), B.type === "group") {
                  if (v.push(B), d.has(B))
                    return false;
                  d.add(B);
                }
              }
              function b(B) {
                B.type === "group" && v.pop().break && c(v);
              }
              l(o, S, b, true);
            }
            function F(o) {
              return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
            }
            function _(o) {
              return p(o, F);
            }
            var w = (o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent";
            function E(o) {
              if (!o)
                return o;
              if (n(o) || o.type === "fill") {
                let d = u(o);
                for (; d.length > 1 && w(...d.slice(-2)); )
                  d.length -= 2;
                if (d.length > 0) {
                  let v = E(t(d));
                  d[d.length - 1] = v;
                }
                return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
              }
              switch (o.type) {
                case "align":
                case "indent":
                case "indent-if-break":
                case "group":
                case "line-suffix":
                case "label": {
                  let d = E(o.contents);
                  return Object.assign(Object.assign({}, o), {}, { contents: d });
                }
                case "if-break": {
                  let d = E(o.breakContents), v = E(o.flatContents);
                  return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: v });
                }
              }
              return o;
            }
            function N(o) {
              return E(I(o));
            }
            function x(o) {
              switch (o.type) {
                case "fill":
                  if (o.parts.every((v) => v === ""))
                    return "";
                  break;
                case "group":
                  if (!o.contents && !o.id && !o.break && !o.expandedStates)
                    return "";
                  if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                    return o.contents;
                  break;
                case "align":
                case "indent":
                case "indent-if-break":
                case "line-suffix":
                  if (!o.contents)
                    return "";
                  break;
                case "if-break":
                  if (!o.flatContents && !o.breakContents)
                    return "";
                  break;
              }
              if (!n(o))
                return o;
              let d = [];
              for (let v of u(o)) {
                if (!v)
                  continue;
                let [S, ...b] = n(v) ? u(v) : [v];
                typeof S == "string" && typeof t(d) == "string" ? d[d.length - 1] += S : d.push(S), d.push(...b);
              }
              return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            function I(o) {
              return p(o, (d) => x(d));
            }
            function P(o) {
              let d = [], v = o.filter(Boolean);
              for (; v.length > 0; ) {
                let S = v.shift();
                if (S) {
                  if (n(S)) {
                    v.unshift(...u(S));
                    continue;
                  }
                  if (d.length > 0 && typeof t(d) == "string" && typeof S == "string") {
                    d[d.length - 1] += S;
                    continue;
                  }
                  d.push(S);
                }
              }
              return d;
            }
            function $(o) {
              return p(o, (d) => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P(d.parts) }) : d);
            }
            function D(o) {
              return p(o, (d) => typeof d == "string" && d.includes(`
`) ? T(d) : d);
            }
            function T(o) {
              let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
              return a(d, o.split(`
`)).parts;
            }
            function m(o) {
              if (o.type === "line")
                return true;
            }
            function C(o) {
              return y(o, m, false);
            }
            r.exports = { isConcat: n, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: p, propagateBreaks: f, removeLines: _, stripTrailingHardline: N, normalizeParts: P, normalizeDoc: $, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
          } }), qD = te({ "src/document/doc-printer.js"(e, r) {
            "use strict";
            ne();
            var { convertEndOfLineToChars: t } = Jn(), s = lt(), a = Oa(), { fill: n, cursor: u, indent: i } = Un(), { isConcat: l, getDocParts: p } = Yt(), y, h = 1, g = 2;
            function c() {
              return { value: "", length: 0, queue: [] };
            }
            function f(x, I) {
              return _(x, { type: "indent" }, I);
            }
            function F(x, I, P) {
              return I === Number.NEGATIVE_INFINITY ? x.root || c() : I < 0 ? _(x, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x), {}, { root: x }) : _(x, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x;
            }
            function _(x, I, P) {
              let $ = I.type === "dedent" ? x.queue.slice(0, -1) : [...x.queue, I], D = "", T = 0, m = 0, C = 0;
              for (let k of $)
                switch (k.type) {
                  case "indent":
                    v(), P.useTabs ? o(1) : d(P.tabWidth);
                    break;
                  case "stringAlign":
                    v(), D += k.n, T += k.n.length;
                    break;
                  case "numberAlign":
                    m += 1, C += k.n;
                    break;
                  default:
                    throw new Error(`Unexpected type '${k.type}'`);
                }
              return b(), Object.assign(Object.assign({}, x), {}, { value: D, length: T, queue: $ });
              function o(k) {
                D += "	".repeat(k), T += P.tabWidth * k;
              }
              function d(k) {
                D += " ".repeat(k), T += k;
              }
              function v() {
                P.useTabs ? S() : b();
              }
              function S() {
                m > 0 && o(m), B();
              }
              function b() {
                C > 0 && d(C), B();
              }
              function B() {
                m = 0, C = 0;
              }
            }
            function w(x) {
              if (x.length === 0)
                return 0;
              let I = 0;
              for (; x.length > 0 && typeof s(x) == "string" && /^[\t ]*$/.test(s(x)); )
                I += x.pop().length;
              if (x.length > 0 && typeof s(x) == "string") {
                let P = s(x).replace(/[\t ]*$/, "");
                I += s(x).length - P.length, x[x.length - 1] = P;
              }
              return I;
            }
            function E(x, I, P, $, D) {
              let T = I.length, m = [x], C = [];
              for (; P >= 0; ) {
                if (m.length === 0) {
                  if (T === 0)
                    return true;
                  m.push(I[--T]);
                  continue;
                }
                let { mode: o, doc: d } = m.pop();
                if (typeof d == "string")
                  C.push(d), P -= a(d);
                else if (l(d) || d.type === "fill") {
                  let v = p(d);
                  for (let S = v.length - 1; S >= 0; S--)
                    m.push({ mode: o, doc: v[S] });
                } else
                  switch (d.type) {
                    case "indent":
                    case "align":
                    case "indent-if-break":
                    case "label":
                      m.push({ mode: o, doc: d.contents });
                      break;
                    case "trim":
                      P += w(C);
                      break;
                    case "group": {
                      if (D && d.break)
                        return false;
                      let v = d.break ? h : o, S = d.expandedStates && v === h ? s(d.expandedStates) : d.contents;
                      m.push({ mode: v, doc: S });
                      break;
                    }
                    case "if-break": {
                      let S = (d.groupId ? y[d.groupId] || g : o) === h ? d.breakContents : d.flatContents;
                      S && m.push({ mode: o, doc: S });
                      break;
                    }
                    case "line":
                      if (o === h || d.hard)
                        return true;
                      d.soft || (C.push(" "), P--);
                      break;
                    case "line-suffix":
                      $ = true;
                      break;
                    case "line-suffix-boundary":
                      if ($)
                        return false;
                      break;
                  }
              }
              return false;
            }
            function N(x, I) {
              y = {};
              let P = I.printWidth, $ = t(I.endOfLine), D = 0, T = [{ ind: c(), mode: h, doc: x }], m = [], C = false, o = [];
              for (; T.length > 0; ) {
                let { ind: v, mode: S, doc: b } = T.pop();
                if (typeof b == "string") {
                  let B = $ !== `
` ? b.replace(/\n/g, $) : b;
                  m.push(B), D += a(B);
                } else if (l(b)) {
                  let B = p(b);
                  for (let k = B.length - 1; k >= 0; k--)
                    T.push({ ind: v, mode: S, doc: B[k] });
                } else
                  switch (b.type) {
                    case "cursor":
                      m.push(u.placeholder);
                      break;
                    case "indent":
                      T.push({ ind: f(v, I), mode: S, doc: b.contents });
                      break;
                    case "align":
                      T.push({ ind: F(v, b.n, I), mode: S, doc: b.contents });
                      break;
                    case "trim":
                      D -= w(m);
                      break;
                    case "group":
                      switch (S) {
                        case g:
                          if (!C) {
                            T.push({ ind: v, mode: b.break ? h : g, doc: b.contents });
                            break;
                          }
                        case h: {
                          C = false;
                          let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
                          if (!b.break && E(B, T, k, M))
                            T.push(B);
                          else if (b.expandedStates) {
                            let R = s(b.expandedStates);
                            if (b.break) {
                              T.push({ ind: v, mode: h, doc: R });
                              break;
                            } else
                              for (let q = 1; q < b.expandedStates.length + 1; q++)
                                if (q >= b.expandedStates.length) {
                                  T.push({ ind: v, mode: h, doc: R });
                                  break;
                                } else {
                                  let J = b.expandedStates[q], L = { ind: v, mode: g, doc: J };
                                  if (E(L, T, k, M)) {
                                    T.push(L);
                                    break;
                                  }
                                }
                          } else
                            T.push({ ind: v, mode: h, doc: b.contents });
                          break;
                        }
                      }
                      b.id && (y[b.id] = s(T).mode);
                      break;
                    case "fill": {
                      let B = P - D, { parts: k } = b;
                      if (k.length === 0)
                        break;
                      let [M, R] = k, q = { ind: v, mode: g, doc: M }, J = { ind: v, mode: h, doc: M }, L = E(q, [], B, o.length > 0, true);
                      if (k.length === 1) {
                        L ? T.push(q) : T.push(J);
                        break;
                      }
                      let Q = { ind: v, mode: g, doc: R }, V = { ind: v, mode: h, doc: R };
                      if (k.length === 2) {
                        L ? T.push(Q, q) : T.push(V, J);
                        break;
                      }
                      k.splice(0, 2);
                      let j = { ind: v, mode: S, doc: n(k) }, Y = k[0];
                      E({ ind: v, mode: g, doc: [M, R, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);
                      break;
                    }
                    case "if-break":
                    case "indent-if-break": {
                      let B = b.groupId ? y[b.groupId] : S;
                      if (B === h) {
                        let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                        k && T.push({ ind: v, mode: S, doc: k });
                      }
                      if (B === g) {
                        let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                        k && T.push({ ind: v, mode: S, doc: k });
                      }
                      break;
                    }
                    case "line-suffix":
                      o.push({ ind: v, mode: S, doc: b.contents });
                      break;
                    case "line-suffix-boundary":
                      o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
                      break;
                    case "line":
                      switch (S) {
                        case g:
                          if (b.hard)
                            C = true;
                          else {
                            b.soft || (m.push(" "), D += 1);
                            break;
                          }
                        case h:
                          if (o.length > 0) {
                            T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                            break;
                          }
                          b.literal ? v.root ? (m.push($, v.root.value), D = v.root.length) : (m.push($), D = 0) : (D -= w(m), m.push($ + v.value), D = v.length);
                          break;
                      }
                      break;
                    case "label":
                      T.push({ ind: v, mode: S, doc: b.contents });
                      break;
                    default:
                  }
                T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
              }
              let d = m.indexOf(u.placeholder);
              if (d !== -1) {
                let v = m.indexOf(u.placeholder, d + 1), S = m.slice(0, d).join(""), b = m.slice(d + 1, v).join(""), B = m.slice(v + 1).join("");
                return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
              }
              return { formatted: m.join("") };
            }
            r.exports = { printDocToString: N };
          } }), MD = te({ "src/document/doc-debug.js"(e, r) {
            "use strict";
            ne();
            var { isConcat: t, getDocParts: s } = Yt();
            function a(u) {
              if (!u)
                return "";
              if (t(u)) {
                let i = [];
                for (let l of s(u))
                  if (t(l))
                    i.push(...a(l).parts);
                  else {
                    let p = a(l);
                    p !== "" && i.push(p);
                  }
                return { type: "concat", parts: i };
              }
              return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
            }
            function n(u) {
              let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
              return p(a(u));
              function p(h, g, c) {
                if (typeof h == "string")
                  return JSON.stringify(h);
                if (t(h)) {
                  let f = s(h).map(p).filter(Boolean);
                  return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
                }
                if (h.type === "line") {
                  let f = Array.isArray(c) && c[g + 1] && c[g + 1].type === "break-parent";
                  return h.literal ? f ? "literalline" : "literallineWithoutBreakParent" : h.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
                }
                if (h.type === "break-parent")
                  return Array.isArray(c) && c[g - 1] && c[g - 1].type === "line" && c[g - 1].hard ? void 0 : "breakParent";
                if (h.type === "trim")
                  return "trim";
                if (h.type === "indent")
                  return "indent(" + p(h.contents) + ")";
                if (h.type === "align")
                  return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(h.contents) + ")" : h.n < 0 ? "dedent(" + p(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + p(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + p(h.contents) + ")";
                if (h.type === "if-break")
                  return "ifBreak(" + p(h.breakContents) + (h.flatContents ? ", " + p(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + `, { groupId: ${y(h.groupId)} }` : "") + ")";
                if (h.type === "indent-if-break") {
                  let f = [];
                  h.negate && f.push("negate: true"), h.groupId && f.push(`groupId: ${y(h.groupId)}`);
                  let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                  return `indentIfBreak(${p(h.contents)}${F})`;
                }
                if (h.type === "group") {
                  let f = [];
                  h.break && h.break !== "propagated" && f.push("shouldBreak: true"), h.id && f.push(`id: ${y(h.id)}`);
                  let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                  return h.expandedStates ? `conditionalGroup([${h.expandedStates.map((_) => p(_)).join(",")}]${F})` : `group(${p(h.contents)}${F})`;
                }
                if (h.type === "fill")
                  return `fill([${h.parts.map((f) => p(f)).join(", ")}])`;
                if (h.type === "line-suffix")
                  return "lineSuffix(" + p(h.contents) + ")";
                if (h.type === "line-suffix-boundary")
                  return "lineSuffixBoundary";
                if (h.type === "label")
                  return `label(${JSON.stringify(h.label)}, ${p(h.contents)})`;
                throw new Error("Unknown doc type " + h.type);
              }
              function y(h) {
                if (typeof h != "symbol")
                  return JSON.stringify(String(h));
                if (h in i)
                  return i[h];
                let g = String(h).slice(7, -1) || "symbol";
                for (let c = 0; ; c++) {
                  let f = g + (c > 0 ? ` #${c}` : "");
                  if (!l.has(f))
                    return l.add(f), i[h] = `Symbol.for(${JSON.stringify(f)})`;
                }
              }
            }
            r.exports = { printDocToDebug: n };
          } }), qe = te({ "src/document/index.js"(e, r) {
            "use strict";
            ne(), r.exports = { builders: Un(), printer: qD(), utils: Yt(), debug: MD() };
          } }), ja = {};
          Kt(ja, { default: () => RD });
          function RD(e) {
            if (typeof e != "string")
              throw new TypeError("Expected a string");
            return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
          }
          var $D = ht({ "node_modules/escape-string-regexp/index.js"() {
            ne();
          } }), qa = te({ "node_modules/semver/internal/debug.js"(e, r) {
            ne();
            var t = typeof wt == "object" && wt.env && wt.env.NODE_DEBUG && /\bsemver\b/i.test(wt.env.NODE_DEBUG) ? function() {
              for (var s = arguments.length, a = new Array(s), n = 0; n < s; n++)
                a[n] = arguments[n];
              return console.error("SEMVER", ...a);
            } : () => {
            };
            r.exports = t;
          } }), Ma = te({ "node_modules/semver/internal/constants.js"(e, r) {
            ne();
            var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
            r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n };
          } }), VD = te({ "node_modules/semver/internal/re.js"(e, r) {
            ne();
            var { MAX_SAFE_COMPONENT_LENGTH: t } = Ma(), s = qa();
            e = r.exports = {};
            var a = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p, y, h) => {
              let g = i++;
              s(p, g, y), u[p] = g, n[g] = y, a[g] = new RegExp(y, h ? "g" : void 0);
            };
            l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
          } }), WD = te({ "node_modules/semver/internal/parse-options.js"(e, r) {
            ne();
            var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((n) => a[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
            r.exports = s;
          } }), HD = te({ "node_modules/semver/internal/identifiers.js"(e, r) {
            ne();
            var t = /^[0-9]+$/, s = (n, u) => {
              let i = t.test(n), l = t.test(u);
              return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
            }, a = (n, u) => s(u, n);
            r.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
          } }), GD = te({ "node_modules/semver/classes/semver.js"(e, r) {
            ne();
            var t = qa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Ma(), { re: n, t: u } = VD(), i = WD(), { compareIdentifiers: l } = HD(), p = class {
              constructor(y, h) {
                if (h = i(h), y instanceof p) {
                  if (y.loose === !!h.loose && y.includePrerelease === !!h.includePrerelease)
                    return y;
                  y = y.version;
                } else if (typeof y != "string")
                  throw new TypeError(`Invalid Version: ${y}`);
                if (y.length > s)
                  throw new TypeError(`version is longer than ${s} characters`);
                t("SemVer", y, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
                let g = y.trim().match(h.loose ? n[u.LOOSE] : n[u.FULL]);
                if (!g)
                  throw new TypeError(`Invalid Version: ${y}`);
                if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > a || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > a || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                g[4] ? this.prerelease = g[4].split(".").map((c) => {
                  if (/^[0-9]+$/.test(c)) {
                    let f = +c;
                    if (f >= 0 && f < a)
                      return f;
                  }
                  return c;
                }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
              }
              format() {
                return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
              }
              toString() {
                return this.version;
              }
              compare(y) {
                if (t("SemVer.compare", this.version, this.options, y), !(y instanceof p)) {
                  if (typeof y == "string" && y === this.version)
                    return 0;
                  y = new p(y, this.options);
                }
                return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
              }
              compareMain(y) {
                return y instanceof p || (y = new p(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
              }
              comparePre(y) {
                if (y instanceof p || (y = new p(y, this.options)), this.prerelease.length && !y.prerelease.length)
                  return -1;
                if (!this.prerelease.length && y.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !y.prerelease.length)
                  return 0;
                let h = 0;
                do {
                  let g = this.prerelease[h], c = y.prerelease[h];
                  if (t("prerelease compare", h, g, c), g === void 0 && c === void 0)
                    return 0;
                  if (c === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === c)
                    continue;
                  return l(g, c);
                } while (++h);
              }
              compareBuild(y) {
                y instanceof p || (y = new p(y, this.options));
                let h = 0;
                do {
                  let g = this.build[h], c = y.build[h];
                  if (t("prerelease compare", h, g, c), g === void 0 && c === void 0)
                    return 0;
                  if (c === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === c)
                    continue;
                  return l(g, c);
                } while (++h);
              }
              inc(y, h) {
                switch (y) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                    break;
                  case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let g = this.prerelease.length;
                      for (; --g >= 0; )
                        typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                      g === -1 && this.prerelease.push(0);
                    }
                    h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                    break;
                  default:
                    throw new Error(`invalid increment argument: ${y}`);
                }
                return this.format(), this.raw = this.version, this;
              }
            };
            r.exports = p;
          } }), zn = te({ "node_modules/semver/functions/compare.js"(e, r) {
            ne();
            var t = GD(), s = (a, n, u) => new t(a, u).compare(new t(n, u));
            r.exports = s;
          } }), UD = te({ "node_modules/semver/functions/lt.js"(e, r) {
            ne();
            var t = zn(), s = (a, n, u) => t(a, n, u) < 0;
            r.exports = s;
          } }), JD = te({ "node_modules/semver/functions/gte.js"(e, r) {
            ne();
            var t = zn(), s = (a, n, u) => t(a, n, u) >= 0;
            r.exports = s;
          } }), zD = te({ "src/utils/arrayify.js"(e, r) {
            "use strict";
            ne(), r.exports = (t, s) => Object.entries(t).map((a) => {
              let [n, u] = a;
              return Object.assign({ [s]: n }, u);
            });
          } }), XD = te({ "node_modules/outdent/lib/index.js"(e, r) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
            function t() {
              for (var E = [], N = 0; N < arguments.length; N++)
                E[N] = arguments[N];
            }
            function s() {
              return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
            }
            function a() {
              return { add: t, delete: t, get: t, set: t, has: function(E) {
                return false;
              } };
            }
            var n = Object.prototype.hasOwnProperty, u = function(E, N) {
              return n.call(E, N);
            };
            function i(E, N) {
              for (var x in N)
                u(N, x) && (E[x] = N[x]);
              return E;
            }
            var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
            function c(E, N, x) {
              var I = 0, P = E[0].match(h);
              P && (I = P[1].length);
              var $ = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($, "g");
              N && (E = E.slice(1));
              var T = x.newline, m = x.trimLeadingNewline, C = x.trimTrailingNewline, o = typeof T == "string", d = E.length, v = E.map(function(S, b) {
                return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === d - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                  return T;
                })), S;
              });
              return v;
            }
            function f(E, N) {
              for (var x = "", I = 0, P = E.length; I < P; I++)
                x += E[I], I < P - 1 && (x += N[I]);
              return x;
            }
            function F(E) {
              return u(E, "raw") && u(E, "length");
            }
            function _(E) {
              var N = s(), x = s();
              function I($) {
                for (var D = [], T = 1; T < arguments.length; T++)
                  D[T - 1] = arguments[T];
                if (F($)) {
                  var m = $, C = (D[0] === I || D[0] === w) && g.test(m[0]) && y.test(m[1]), o = C ? x : N, d = o.get(m);
                  if (d || (d = c(m, C, E), o.set(m, d)), D.length === 0)
                    return d[0];
                  var v = f(d, C ? D.slice(1) : D);
                  return v;
                } else
                  return _(i(i({}, E), $ || {}));
              }
              var P = i(I, { string: function($) {
                return c([$], false, E)[0];
              } });
              return P;
            }
            var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
            if (e.outdent = w, e.default = w, typeof r < "u")
              try {
                r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
              } catch {
              }
          } }), KD = te({ "src/main/core-options.js"(e, r) {
            "use strict";
            ne();
            var { outdent: t } = XD(), s = "Config", a = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p = "Special", y = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
            r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: y };
          } }), Xn = te({ "src/main/support.js"(e, r) {
            "use strict";
            ne();
            var t = { compare: zn(), lt: UD(), gte: JD() }, s = zD(), a = Ia().version, n = KD().options;
            function u() {
              let { plugins: l = [], showUnreleased: p = false, showDeprecated: y = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a.split("-", 1)[0], c = l.flatMap((E) => E.languages || []).filter(F), f = s(Object.assign({}, ...l.map((E) => {
                let { options: N } = E;
                return N;
              }), n), "name").filter((E) => F(E) && _(E)).sort((E, N) => E.name === N.name ? 0 : E.name < N.name ? -1 : 1).map(w).map((E) => {
                E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F).sort((x, I) => t.compare(I.since, x.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x) => F(x) && _(x)), E.name === "parser" && i(E, c, l));
                let N = Object.fromEntries(l.filter((x) => x.defaultOptions && x.defaultOptions[E.name] !== void 0).map((x) => [x.name, x.defaultOptions[E.name]]));
                return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N });
              });
              return { languages: c, options: f };
              function F(E) {
                return p || !("since" in E) || E.since && t.gte(g, E.since);
              }
              function _(E) {
                return y || !("deprecated" in E) || E.deprecated && t.lt(g, E.deprecated);
              }
              function w(E) {
                if (h)
                  return E;
                let { cliName: N, cliCategory: x, cliDescription: I } = E;
                return Hn(E, hD);
              }
            }
            function i(l, p, y) {
              let h = new Set(l.choices.map((g) => g.value));
              for (let g of p)
                if (g.parsers) {
                  for (let c of g.parsers)
                    if (!h.has(c)) {
                      h.add(c);
                      let f = y.find((_) => _.parsers && _.parsers[c]), F = g.name;
                      f && f.name && (F += ` (plugin: ${f.name})`), l.choices.push({ value: c, description: F });
                    }
                }
            }
            r.exports = { getSupportInfo: u };
          } }), Kn = te({ "src/utils/is-non-empty-array.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              return Array.isArray(s) && s.length > 0;
            }
            r.exports = t;
          } }), Pr = te({ "src/utils/text/skip.js"(e, r) {
            "use strict";
            ne();
            function t(i) {
              return (l, p, y) => {
                let h = y && y.backwards;
                if (p === false)
                  return false;
                let { length: g } = l, c = p;
                for (; c >= 0 && c < g; ) {
                  let f = l.charAt(c);
                  if (i instanceof RegExp) {
                    if (!i.test(f))
                      return c;
                  } else if (!i.includes(f))
                    return c;
                  h ? c-- : c++;
                }
                return c === -1 || c === g ? c : false;
              };
            }
            var s = t(/\s/), a = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
            r.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n, skipEverythingButNewLine: u };
          } }), Ra = te({ "src/utils/text/skip-inline-comment.js"(e, r) {
            "use strict";
            ne();
            function t(s, a) {
              if (a === false)
                return false;
              if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
                for (let n = a + 2; n < s.length; ++n)
                  if (s.charAt(n) === "*" && s.charAt(n + 1) === "/")
                    return n + 2;
              }
              return a;
            }
            r.exports = t;
          } }), $a = te({ "src/utils/text/skip-trailing-comment.js"(e, r) {
            "use strict";
            ne();
            var { skipEverythingButNewLine: t } = Pr();
            function s(a, n) {
              return n === false ? false : a.charAt(n) === "/" && a.charAt(n + 1) === "/" ? t(a, n) : n;
            }
            r.exports = s;
          } }), Va = te({ "src/utils/text/skip-newline.js"(e, r) {
            "use strict";
            ne();
            function t(s, a, n) {
              let u = n && n.backwards;
              if (a === false)
                return false;
              let i = s.charAt(a);
              if (u) {
                if (s.charAt(a - 1) === "\r" && i === `
`)
                  return a - 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a - 1;
              } else {
                if (i === "\r" && s.charAt(a + 1) === `
`)
                  return a + 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a + 1;
              }
              return a;
            }
            r.exports = t;
          } }), YD = te({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
            "use strict";
            ne();
            var t = Ra(), s = Va(), a = $a(), { skipSpaces: n } = Pr();
            function u(i, l) {
              let p = null, y = l;
              for (; y !== p; )
                p = y, y = n(i, y), y = t(i, y), y = a(i, y), y = s(i, y);
              return y;
            }
            r.exports = u;
          } }), Ue = te({ "src/common/util.js"(e, r) {
            "use strict";
            ne();
            var { default: t } = ($D(), ft(ja)), s = lt(), { getSupportInfo: a } = Xn(), n = Kn(), u = Oa(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y } = Pr(), h = Ra(), g = $a(), c = Va(), f = YD(), F = (V) => V[V.length - 2];
            function _(V) {
              return (j, Y, ie) => {
                let ee = ie && ie.backwards;
                if (Y === false)
                  return false;
                let { length: ce } = j, W = Y;
                for (; W >= 0 && W < ce; ) {
                  let K = j.charAt(W);
                  if (V instanceof RegExp) {
                    if (!V.test(K))
                      return W;
                  } else if (!V.includes(K))
                    return W;
                  ee ? W-- : W++;
                }
                return W === -1 || W === ce ? W : false;
              };
            }
            function w(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c(V, ie, Y);
              return ie !== ee;
            }
            function E(V, j, Y) {
              for (let ie = j; ie < Y; ++ie)
                if (V.charAt(ie) === `
`)
                  return true;
              return false;
            }
            function N(V, j, Y) {
              let ie = Y(j) - 1;
              ie = l(V, ie, { backwards: true }), ie = c(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
              let ee = c(V, ie, { backwards: true });
              return ie !== ee;
            }
            function x(V, j) {
              let Y = null, ie = j;
              for (; ie !== Y; )
                Y = ie, ie = p(V, ie), ie = h(V, ie), ie = l(V, ie);
              return ie = g(V, ie), ie = c(V, ie), ie !== false && w(V, ie);
            }
            function I(V, j, Y) {
              return x(V, Y(j));
            }
            function P(V, j, Y) {
              return f(V, Y(j));
            }
            function $(V, j, Y) {
              return V.charAt(P(V, j, Y));
            }
            function D(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return l(V, Y.backwards ? j - 1 : j, Y) !== j;
            }
            function T(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
              for (let ee = Y; ee < V.length; ++ee)
                V[ee] === "	" ? ie = ie + j - ie % j : ie++;
              return ie;
            }
            function m(V, j) {
              let Y = V.lastIndexOf(`
`);
              return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
            }
            function C(V, j) {
              let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
              if (V.includes(ee.quote) || V.includes(ce.quote)) {
                let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
                W = K > de ? ce : ee;
              }
              return W;
            }
            function o(V, j) {
              let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
              return d(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
            }
            function d(V, j, Y) {
              let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
              return j + ce + j;
            }
            function v(V) {
              return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
            }
            function S(V, j) {
              let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
              return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
            }
            function b(V, j) {
              let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
              if (Y === null)
                return 0;
              let ie = /* @__PURE__ */ new Map(), ee = 0;
              for (let ce of Y) {
                let W = ce.length / j.length;
                ie.set(W, true), W > ee && (ee = W);
              }
              for (let ce = 1; ce < ee; ce++)
                if (!ie.get(ce))
                  return ce;
              return ee + 1;
            }
            function B(V, j) {
              (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
            }
            function k(V, j) {
              j.leading = true, j.trailing = false, B(V, j);
            }
            function M(V, j, Y) {
              j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
            }
            function R(V, j) {
              j.leading = false, j.trailing = true, B(V, j);
            }
            function q(V, j) {
              let { languages: Y } = a({ plugins: j.plugins }), ie = Y.find((ee) => {
                let { name: ce } = ee;
                return ce.toLowerCase() === V;
              }) || Y.find((ee) => {
                let { aliases: ce } = ee;
                return Array.isArray(ce) && ce.includes(V);
              }) || Y.find((ee) => {
                let { extensions: ce } = ee;
                return Array.isArray(ce) && ce.includes(`.${V}`);
              });
              return ie && ie.parsers[0];
            }
            function J(V) {
              return V && V.type === "front-matter";
            }
            function L(V) {
              let j = /* @__PURE__ */ new WeakMap();
              return function(Y) {
                return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
              };
            }
            function Q(V) {
              let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
              return Y.length > 20 && (Y = Y.slice(0, 19) + "\u2026"), j + (Y ? " " + Y : "");
            }
            r.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y, skipInlineComment: h, skipTrailingComment: g, skipNewline: c, isNextLineEmptyAfterIndex: x, isNextLineEmpty: I, isPreviousLineEmpty: N, hasNewline: w, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v, makeString: d, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
          } }), Wa = {};
          Kt(Wa, { basename: () => za, default: () => Ka, delimiter: () => Mn, dirname: () => Ja, extname: () => Xa, isAbsolute: () => Qn, join: () => Ga, normalize: () => Yn, relative: () => Ua, resolve: () => wr, sep: () => qn });
          function Ha(e, r) {
            for (var t = 0, s = e.length - 1; s >= 0; s--) {
              var a = e[s];
              a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
            }
            if (r)
              for (; t--; t)
                e.unshift("..");
            return e;
          }
          function wr() {
            for (var e = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
              var s = t >= 0 ? arguments[t] : "/";
              if (typeof s != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!s)
                continue;
              e = s + "/" + e, r = s.charAt(0) === "/";
            }
            return e = Ha(Zn(e.split("/"), function(a) {
              return !!a;
            }), !r).join("/"), (r ? "/" : "") + e || ".";
          }
          function Yn(e) {
            var r = Qn(e), t = Ya(e, -1) === "/";
            return e = Ha(Zn(e.split("/"), function(s) {
              return !!s;
            }), !r).join("/"), !e && !r && (e = "."), e && t && (e += "/"), (r ? "/" : "") + e;
          }
          function Qn(e) {
            return e.charAt(0) === "/";
          }
          function Ga() {
            var e = Array.prototype.slice.call(arguments, 0);
            return Yn(Zn(e, function(r, t) {
              if (typeof r != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return r;
            }).join("/"));
          }
          function Ua(e, r) {
            e = wr(e).substr(1), r = wr(r).substr(1);
            function t(p) {
              for (var y = 0; y < p.length && p[y] === ""; y++)
                ;
              for (var h = p.length - 1; h >= 0 && p[h] === ""; h--)
                ;
              return y > h ? [] : p.slice(y, h - y + 1);
            }
            for (var s = t(e.split("/")), a = t(r.split("/")), n = Math.min(s.length, a.length), u = n, i = 0; i < n; i++)
              if (s[i] !== a[i]) {
                u = i;
                break;
              }
            for (var l = [], i = u; i < s.length; i++)
              l.push("..");
            return l = l.concat(a.slice(u)), l.join("/");
          }
          function Ja(e) {
            var r = Ir(e), t = r[0], s = r[1];
            return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
          }
          function za(e, r) {
            var t = Ir(e)[2];
            return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
          }
          function Xa(e) {
            return Ir(e)[3];
          }
          function Zn(e, r) {
            if (e.filter)
              return e.filter(r);
            for (var t = [], s = 0; s < e.length; s++)
              r(e[s], s, e) && t.push(e[s]);
            return t;
          }
          var Na, Ir, qn, Mn, Ka, Ya, QD = ht({ "node-modules-polyfills:path"() {
            ne(), Na = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir = function(e) {
              return Na.exec(e).slice(1);
            }, qn = "/", Mn = ":", Ka = { extname: Xa, basename: za, dirname: Ja, sep: qn, delimiter: Mn, relative: Ua, join: Ga, isAbsolute: Qn, normalize: Yn, resolve: wr }, Ya = "ab".substr(-1) === "b" ? function(e, r, t) {
              return e.substr(r, t);
            } : function(e, r, t) {
              return r < 0 && (r = e.length + r), e.substr(r, t);
            };
          } }), ZD = te({ "node-modules-polyfills-commonjs:path"(e, r) {
            ne();
            var t = (QD(), ft(Wa));
            if (t && t.default) {
              r.exports = t.default;
              for (let s in t)
                r.exports[s] = t[s];
            } else
              t && (r.exports = t);
          } }), Qt = te({ "src/common/errors.js"(e, r) {
            "use strict";
            ne();
            var t = class extends Error {
            }, s = class extends Error {
            }, a = class extends Error {
            }, n = class extends Error {
            };
            r.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n };
          } }), vt = {};
          Kt(vt, { __assign: () => Nr, __asyncDelegator: () => fm, __asyncGenerator: () => pm, __asyncValues: () => Dm, __await: () => Xt, __awaiter: () => sm, __classPrivateFieldGet: () => ym, __classPrivateFieldSet: () => hm, __createBinding: () => am, __decorate: () => rm, __exportStar: () => om, __extends: () => em, __generator: () => im, __importDefault: () => gm, __importStar: () => dm, __makeTemplateObject: () => mm, __metadata: () => um, __param: () => nm, __read: () => Qa, __rest: () => tm, __spread: () => lm, __spreadArrays: () => cm, __values: () => Rn });
          function em(e, r) {
            Br(e, r);
            function t() {
              this.constructor = e;
            }
            e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
          }
          function tm(e, r) {
            var t = {};
            for (var s in e)
              Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function")
              for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
                r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
            return t;
          }
          function rm(e, r, t, s) {
            var a = arguments.length, n = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t) : s, u;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
              n = Reflect.decorate(e, r, t, s);
            else
              for (var i = e.length - 1; i >= 0; i--)
                (u = e[i]) && (n = (a < 3 ? u(n) : a > 3 ? u(r, t, n) : u(r, t)) || n);
            return a > 3 && n && Object.defineProperty(r, t, n), n;
          }
          function nm(e, r) {
            return function(t, s) {
              r(t, s, e);
            };
          }
          function um(e, r) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
              return Reflect.metadata(e, r);
          }
          function sm(e, r, t, s) {
            function a(n) {
              return n instanceof t ? n : new t(function(u) {
                u(n);
              });
            }
            return new (t || (t = Promise))(function(n, u) {
              function i(y) {
                try {
                  p(s.next(y));
                } catch (h) {
                  u(h);
                }
              }
              function l(y) {
                try {
                  p(s.throw(y));
                } catch (h) {
                  u(h);
                }
              }
              function p(y) {
                y.done ? n(y.value) : a(y.value).then(i, l);
              }
              p((s = s.apply(e, r || [])).next());
            });
          }
          function im(e, r) {
            var t = { label: 0, sent: function() {
              if (n[0] & 1)
                throw n[1];
              return n[1];
            }, trys: [], ops: [] }, s, a, n, u;
            return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
              return this;
            }), u;
            function i(p) {
              return function(y) {
                return l([p, y]);
              };
            }
            function l(p) {
              if (s)
                throw new TypeError("Generator is already executing.");
              for (; t; )
                try {
                  if (s = 1, a && (n = p[0] & 2 ? a.return : p[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, p[1])).done)
                    return n;
                  switch (a = 0, n && (p = [p[0] & 2, n.value]), p[0]) {
                    case 0:
                    case 1:
                      n = p;
                      break;
                    case 4:
                      return t.label++, { value: p[1], done: false };
                    case 5:
                      t.label++, a = p[1], p = [0];
                      continue;
                    case 7:
                      p = t.ops.pop(), t.trys.pop();
                      continue;
                    default:
                      if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                        t = 0;
                        continue;
                      }
                      if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {
                        t.label = p[1];
                        break;
                      }
                      if (p[0] === 6 && t.label < n[1]) {
                        t.label = n[1], n = p;
                        break;
                      }
                      if (n && t.label < n[2]) {
                        t.label = n[2], t.ops.push(p);
                        break;
                      }
                      n[2] && t.ops.pop(), t.trys.pop();
                      continue;
                  }
                  p = r.call(e, t);
                } catch (y) {
                  p = [6, y], a = 0;
                } finally {
                  s = n = 0;
                }
              if (p[0] & 5)
                throw p[1];
              return { value: p[0] ? p[1] : void 0, done: true };
            }
          }
          function am(e, r, t, s) {
            s === void 0 && (s = t), e[s] = r[t];
          }
          function om(e, r) {
            for (var t in e)
              t !== "default" && !r.hasOwnProperty(t) && (r[t] = e[t]);
          }
          function Rn(e) {
            var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], s = 0;
            if (t)
              return t.call(e);
            if (e && typeof e.length == "number")
              return { next: function() {
                return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
              } };
            throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function Qa(e, r) {
            var t = typeof Symbol == "function" && e[Symbol.iterator];
            if (!t)
              return e;
            var s = t.call(e), a, n = [], u;
            try {
              for (; (r === void 0 || r-- > 0) && !(a = s.next()).done; )
                n.push(a.value);
            } catch (i) {
              u = { error: i };
            } finally {
              try {
                a && !a.done && (t = s.return) && t.call(s);
              } finally {
                if (u)
                  throw u.error;
              }
            }
            return n;
          }
          function lm() {
            for (var e = [], r = 0; r < arguments.length; r++)
              e = e.concat(Qa(arguments[r]));
            return e;
          }
          function cm() {
            for (var e = 0, r = 0, t = arguments.length; r < t; r++)
              e += arguments[r].length;
            for (var s = Array(e), a = 0, r = 0; r < t; r++)
              for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a++)
                s[a] = n[u];
            return s;
          }
          function Xt(e) {
            return this instanceof Xt ? (this.v = e, this) : new Xt(e);
          }
          function pm(e, r, t) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var s = t.apply(e, r || []), a, n = [];
            return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
              return this;
            }, a;
            function u(g) {
              s[g] && (a[g] = function(c) {
                return new Promise(function(f, F) {
                  n.push([g, c, f, F]) > 1 || i(g, c);
                });
              });
            }
            function i(g, c) {
              try {
                l(s[g](c));
              } catch (f) {
                h(n[0][3], f);
              }
            }
            function l(g) {
              g.value instanceof Xt ? Promise.resolve(g.value.v).then(p, y) : h(n[0][2], g);
            }
            function p(g) {
              i("next", g);
            }
            function y(g) {
              i("throw", g);
            }
            function h(g, c) {
              g(c), n.shift(), n.length && i(n[0][0], n[0][1]);
            }
          }
          function fm(e) {
            var r, t;
            return r = {}, s("next"), s("throw", function(a) {
              throw a;
            }), s("return"), r[Symbol.iterator] = function() {
              return this;
            }, r;
            function s(a, n) {
              r[a] = e[a] ? function(u) {
                return (t = !t) ? { value: Xt(e[a](u)), done: a === "return" } : n ? n(u) : u;
              } : n;
            }
          }
          function Dm(e) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var r = e[Symbol.asyncIterator], t;
            return r ? r.call(e) : (e = typeof Rn == "function" ? Rn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
              return this;
            }, t);
            function s(n) {
              t[n] = e[n] && function(u) {
                return new Promise(function(i, l) {
                  u = e[n](u), a(i, l, u.done, u.value);
                });
              };
            }
            function a(n, u, i, l) {
              Promise.resolve(l).then(function(p) {
                n({ value: p, done: i });
              }, u);
            }
          }
          function mm(e, r) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
          }
          function dm(e) {
            if (e && e.__esModule)
              return e;
            var r = {};
            if (e != null)
              for (var t in e)
                Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);
            return r.default = e, r;
          }
          function gm(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function ym(e, r) {
            if (!r.has(e))
              throw new TypeError("attempted to get private field on non-instance");
            return r.get(e);
          }
          function hm(e, r, t) {
            if (!r.has(e))
              throw new TypeError("attempted to set private field on non-instance");
            return r.set(e, t), t;
          }
          var Br, Nr, Et = ht({ "node_modules/tslib/tslib.es6.js"() {
            ne(), Br = function(e, r) {
              return Br = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
                t.__proto__ = s;
              } || function(t, s) {
                for (var a in s)
                  s.hasOwnProperty(a) && (t[a] = s[a]);
              }, Br(e, r);
            }, Nr = function() {
              return Nr = Object.assign || function(r) {
                for (var t, s = 1, a = arguments.length; s < a; s++) {
                  t = arguments[s];
                  for (var n in t)
                    Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
                }
                return r;
              }, Nr.apply(this, arguments);
            };
          } }), Za = te({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
              if (r === null || typeof r != "object")
                return JSON.stringify(r);
              if (Array.isArray(r))
                return `[${r.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
              let t = Object.keys(r);
              return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`;
            }, pair: (r) => {
              let { key: t, value: s } = r;
              return e.apiDescriptor.value({ [t]: s });
            } };
          } }), vm = te({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Za(), e);
          } }), kr = te({ "scripts/build/shims/chalk.cjs"(e, r) {
            "use strict";
            ne();
            var t = (s) => s;
            t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
          } }), eo = te({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr();
            e.commonDeprecatedHandler = (t, s, a) => {
              let { descriptor: n } = a, u = [`${r.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
              return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n.key(s) : n.pair(s))}`), u.join("; ") + ".";
            };
          } }), Cm = te({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(eo(), e);
          } }), Em = te({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr();
            e.commonInvalidHandler = (t, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t))} value.`, `Expected ${r.default.blue(a.schemas[t].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(" ");
          } }), to = te({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Em(), e);
          } }), Fm = te({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
            "use strict";
            ne();
            var t = [], s = [];
            r.exports = function(a, n) {
              if (a === n)
                return 0;
              var u = a;
              a.length > n.length && (a = n, n = u);
              var i = a.length, l = n.length;
              if (i === 0)
                return l;
              if (l === 0)
                return i;
              for (; i > 0 && a.charCodeAt(~-i) === n.charCodeAt(~-l); )
                i--, l--;
              if (i === 0)
                return l;
              for (var p = 0; p < i && a.charCodeAt(p) === n.charCodeAt(p); )
                p++;
              if (i -= p, l -= p, i === 0)
                return l;
              for (var y, h, g, c, f = 0, F = 0; f < i; )
                s[p + f] = a.charCodeAt(p + f), t[f] = ++f;
              for (; F < l; )
                for (y = n.charCodeAt(p + F), g = F++, h = F, f = 0; f < i; f++)
                  c = y === s[p + f] ? g : g + 1, g = t[f], h = t[f] = g > h ? c > h ? h + 1 : c : c > g ? g + 1 : c;
              return h;
            };
          } }), ro = te({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr(), t = Fm();
            e.levenUnknownHandler = (s, a, n) => {
              let { descriptor: u, logger: i, schemas: l } = n, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a }))}.`], y = Object.keys(l).sort().find((h) => t(s, h) < 3);
              y && p.push(`Did you mean ${r.default.blue(u.key(y))}?`), i.warn(p.join(" "));
            };
          } }), Am = te({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(ro(), e);
          } }), Sm = te({ "node_modules/vnopts/lib/handlers/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Cm(), e), r.__exportStar(to(), e), r.__exportStar(Am(), e);
          } }), Ft = te({ "node_modules/vnopts/lib/schema.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
            function t(n, u) {
              let i = new n(u), l = Object.create(i);
              for (let p of r)
                p in u && (l[p] = a(u[p], i, s.prototype[p].length));
              return l;
            }
            e.createSchema = t;
            var s = class {
              constructor(n) {
                this.name = n.name;
              }
              static create(n) {
                return t(this, n);
              }
              default(n) {
              }
              expected(n) {
                return "nothing";
              }
              validate(n, u) {
                return false;
              }
              deprecated(n, u) {
                return false;
              }
              forward(n, u) {
              }
              redirect(n, u) {
              }
              overlap(n, u, i) {
                return n;
              }
              preprocess(n, u) {
                return n;
              }
              postprocess(n, u) {
                return n;
              }
            };
            e.Schema = s;
            function a(n, u, i) {
              return typeof n == "function" ? function() {
                for (var l = arguments.length, p = new Array(l), y = 0; y < l; y++)
                  p[y] = arguments[y];
                return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));
              } : () => n;
            }
          } }), xm = te({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              constructor(s) {
                super(s), this._sourceName = s.sourceName;
              }
              expected(s) {
                return s.schemas[this._sourceName].expected(s);
              }
              validate(s, a) {
                return a.schemas[this._sourceName].validate(s, a);
              }
              redirect(s, a) {
                return this._sourceName;
              }
            };
            e.AliasSchema = t;
          } }), bm = te({ "node_modules/vnopts/lib/schemas/any.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "anything";
              }
              validate() {
                return true;
              }
            };
            e.AnySchema = t;
          } }), Tm = te({ "node_modules/vnopts/lib/schemas/array.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt)), t = Ft(), s = class extends t.Schema {
              constructor(n) {
                var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
                super(Object.assign({}, l, { name: i })), this._valueSchema = u;
              }
              expected(n) {
                return `an array of ${this._valueSchema.expected(n)}`;
              }
              validate(n, u) {
                if (!Array.isArray(n))
                  return false;
                let i = [];
                for (let l of n) {
                  let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                  p !== true && i.push(p.value);
                }
                return i.length === 0 ? true : { value: i };
              }
              deprecated(n, u) {
                let i = [];
                for (let l of n) {
                  let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                  p !== false && i.push(...p.map((y) => {
                    let { value: h } = y;
                    return { value: [h] };
                  }));
                }
                return i;
              }
              forward(n, u) {
                let i = [];
                for (let l of n) {
                  let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                  i.push(...p.map(a));
                }
                return i;
              }
              redirect(n, u) {
                let i = [], l = [];
                for (let p of n) {
                  let y = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
                  "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a));
                }
                return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
              }
              overlap(n, u) {
                return n.concat(u);
              }
            };
            e.ArraySchema = s;
            function a(n) {
              let { from: u, to: i } = n;
              return { from: [u], to: i };
            }
          } }), Bm = te({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "true or false";
              }
              validate(s) {
                return typeof s == "boolean";
              }
            };
            e.BooleanSchema = t;
          } }), eu = te({ "node_modules/vnopts/lib/utils.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            function r(c, f) {
              let F = /* @__PURE__ */ Object.create(null);
              for (let _ of c) {
                let w = _[f];
                if (F[w])
                  throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
                F[w] = _;
              }
              return F;
            }
            e.recordFromArray = r;
            function t(c, f) {
              let F = /* @__PURE__ */ new Map();
              for (let _ of c) {
                let w = _[f];
                if (F.has(w))
                  throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
                F.set(w, _);
              }
              return F;
            }
            e.mapFromArray = t;
            function s() {
              let c = /* @__PURE__ */ Object.create(null);
              return (f) => {
                let F = JSON.stringify(f);
                return c[F] ? true : (c[F] = true, false);
              };
            }
            e.createAutoChecklist = s;
            function a(c, f) {
              let F = [], _ = [];
              for (let w of c)
                f(w) ? F.push(w) : _.push(w);
              return [F, _];
            }
            e.partition = a;
            function n(c) {
              return c === Math.floor(c);
            }
            e.isInt = n;
            function u(c, f) {
              if (c === f)
                return 0;
              let F = typeof c, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
              return F !== _ ? w.indexOf(F) - w.indexOf(_) : F !== "string" ? Number(c) - Number(f) : c.localeCompare(f);
            }
            e.comparePrimitive = u;
            function i(c) {
              return c === void 0 ? {} : c;
            }
            e.normalizeDefaultResult = i;
            function l(c, f) {
              return c === true ? true : c === false ? { value: f } : c;
            }
            e.normalizeValidateResult = l;
            function p(c, f) {
              let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return c === false ? false : c === true ? F ? true : [{ value: f }] : "value" in c ? [c] : c.length === 0 ? false : c;
            }
            e.normalizeDeprecatedResult = p;
            function y(c, f) {
              return typeof c == "string" || "key" in c ? { from: f, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f, to: c.to };
            }
            e.normalizeTransferResult = y;
            function h(c, f) {
              return c === void 0 ? [] : Array.isArray(c) ? c.map((F) => y(F, f)) : [y(c, f)];
            }
            e.normalizeForwardResult = h;
            function g(c, f) {
              let F = h(typeof c == "object" && "redirect" in c ? c.redirect : c, f);
              return F.length === 0 ? { remain: f, redirect: F } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: F } : { redirect: F };
            }
            e.normalizeRedirectResult = g;
          } }), Nm = te({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = eu(), s = class extends r.Schema {
              constructor(a) {
                super(a), this._choices = t.mapFromArray(a.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
              }
              expected(a) {
                let { descriptor: n } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
                return i.concat(l.join(" or ")).join(", ");
              }
              validate(a) {
                return this._choices.has(a);
              }
              deprecated(a) {
                let n = this._choices.get(a);
                return n && n.deprecated ? { value: a } : false;
              }
              forward(a) {
                let n = this._choices.get(a);
                return n ? n.forward : void 0;
              }
              redirect(a) {
                let n = this._choices.get(a);
                return n ? n.redirect : void 0;
              }
            };
            e.ChoiceSchema = s;
          } }), no = te({ "node_modules/vnopts/lib/schemas/number.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "a number";
              }
              validate(s, a) {
                return typeof s == "number";
              }
            };
            e.NumberSchema = t;
          } }), wm = te({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = eu(), t = no(), s = class extends t.NumberSchema {
              expected() {
                return "an integer";
              }
              validate(a, n) {
                return n.normalizeValidateResult(super.validate(a, n), a) === true && r.isInt(a);
              }
            };
            e.IntegerSchema = s;
          } }), _m = te({ "node_modules/vnopts/lib/schemas/string.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "a string";
              }
              validate(s) {
                return typeof s == "string";
              }
            };
            e.StringSchema = t;
          } }), Pm = te({ "node_modules/vnopts/lib/schemas/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(xm(), e), r.__exportStar(bm(), e), r.__exportStar(Tm(), e), r.__exportStar(Bm(), e), r.__exportStar(Nm(), e), r.__exportStar(wm(), e), r.__exportStar(no(), e), r.__exportStar(_m(), e);
          } }), Im = te({ "node_modules/vnopts/lib/defaults.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Za(), t = eo(), s = to(), a = ro();
            e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
          } }), km = te({ "node_modules/vnopts/lib/normalize.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Im(), t = eu();
            e.normalize = (a, n, u) => new s(n, u).normalize(a);
            var s = class {
              constructor(a, n) {
                let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: y = r.defaultDeprecatedHandler } = n || {};
                this._utils = { descriptor: i, logger: u || { warn: () => {
                } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y, this.cleanHistory();
              }
              cleanHistory() {
                this._hasDeprecationWarned = t.createAutoChecklist();
              }
              normalize(a) {
                let n = {}, u = [a], i = () => {
                  for (; u.length !== 0; ) {
                    let l = u.shift(), p = this._applyNormalization(l, n);
                    u.push(...p);
                  }
                };
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let p = this._utils.schemas[l];
                  if (!(l in n)) {
                    let y = t.normalizeDefaultResult(p.default(this._utils));
                    "value" in y && u.push({ [l]: y.value });
                  }
                }
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let p = this._utils.schemas[l];
                  l in n && (n[l] = p.postprocess(n[l], this._utils));
                }
                return n;
              }
              _applyNormalization(a, n) {
                let u = [], [i, l] = t.partition(Object.keys(a), (p) => p in this._utils.schemas);
                for (let p of i) {
                  let y = this._utils.schemas[p], h = y.preprocess(a[p], this._utils), g = t.normalizeValidateResult(y.validate(h, this._utils), h);
                  if (g !== true) {
                    let { value: w } = g, E = this._invalidHandler(p, w, this._utils);
                    throw typeof E == "string" ? new Error(E) : E;
                  }
                  let c = (w) => {
                    let { from: E, to: N } = w;
                    u.push(typeof N == "string" ? { [N]: E } : { [N.key]: N.value });
                  }, f = (w) => {
                    let { value: E, redirectTo: N } = w, x = t.normalizeDeprecatedResult(y.deprecated(E, this._utils), h, true);
                    if (x !== false)
                      if (x === true)
                        this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N, this._utils));
                      else
                        for (let { value: I } of x) {
                          let P = { key: p, value: I };
                          if (!this._hasDeprecationWarned(P)) {
                            let $ = typeof N == "string" ? { key: N, value: I } : N;
                            this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));
                          }
                        }
                  };
                  t.normalizeForwardResult(y.forward(h, this._utils), h).forEach(c);
                  let _ = t.normalizeRedirectResult(y.redirect(h, this._utils), h);
                  if (_.redirect.forEach(c), "remain" in _) {
                    let w = _.remain;
                    n[p] = p in n ? y.overlap(n[p], w, this._utils) : w, f({ value: w });
                  }
                  for (let { from: w, to: E } of _.redirect)
                    f({ value: w, redirectTo: E });
                }
                for (let p of l) {
                  let y = a[p], h = this._unknownHandler(p, y, this._utils);
                  if (h)
                    for (let g of Object.keys(h)) {
                      let c = { [g]: h[g] };
                      g in this._utils.schemas ? u.push(c) : Object.assign(n, c);
                    }
                }
                return u;
              }
            };
            e.Normalizer = s;
          } }), Lm = te({ "node_modules/vnopts/lib/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(vm(), e), r.__exportStar(Sm(), e), r.__exportStar(Pm(), e), r.__exportStar(km(), e), r.__exportStar(Ft(), e);
          } }), Om = te({ "src/main/options-normalizer.js"(e, r) {
            "use strict";
            ne();
            var t = Lm(), s = lt(), a = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
              let { key: c, value: f } = g;
              return f === false ? `--no-${c}` : f === true ? a.key(c) : f === "" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f}`;
            } }, n = (g) => {
              let { colorsModule: c, levenshteinDistance: f } = g;
              return class extends t.ChoiceSchema {
                constructor(_) {
                  let { name: w, flags: E } = _;
                  super({ name: w, choices: E }), this._flags = [...E].sort();
                }
                preprocess(_, w) {
                  if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                    let E = this._flags.find((N) => f(N, _) < 3);
                    if (E)
                      return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(E))}?`].join(" ")), E;
                  }
                  return _;
                }
                expected() {
                  return "a flag";
                }
              };
            }, u;
            function i(g, c) {
              let { logger: f = false, isCLI: F = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
                let o = C.schemas, { _: d } = o, v = Hn(o, vD);
                return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v }));
              }, x = F ? a : t.apiDescriptor, I = l(c, { isCLI: F, colorsModule: w, levenshteinDistance: E }), P = new t.Normalizer(I, { logger: f, unknown: N, descriptor: x }), $ = f !== false;
              $ && u && (P._hasDeprecationWarned = u);
              let D = P.normalize(g);
              return $ && (u = P._hasDeprecationWarned), F && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
            }
            function l(g, c) {
              let { isCLI: f, colorsModule: F, levenshteinDistance: _ } = c, w = [];
              f && w.push(t.AnySchema.create({ name: "_" }));
              for (let E of g)
                w.push(p(E, { isCLI: f, optionInfos: g, colorsModule: F, levenshteinDistance: _ })), E.alias && f && w.push(t.AliasSchema.create({ name: E.alias, sourceName: E.name }));
              return w;
            }
            function p(g, c) {
              let { isCLI: f, optionInfos: F, colorsModule: _, levenshteinDistance: w } = c, { name: E } = g;
              if (E === "plugin-search-dir" || E === "pluginSearchDirs")
                return t.AnySchema.create({ name: E, preprocess(P) {
                  return P === false || (P = Array.isArray(P) ? P : [P]), P;
                }, validate(P) {
                  return P === false ? true : P.every(($) => typeof $ == "string");
                }, expected() {
                  return "false or paths to plugin search dir";
                } });
              let N = { name: E }, x, I = {};
              switch (g.type) {
                case "int":
                  x = t.IntegerSchema, f && (N.preprocess = Number);
                  break;
                case "string":
                  x = t.StringSchema;
                  break;
                case "choice":
                  x = t.ChoiceSchema, N.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
                  break;
                case "boolean":
                  x = t.BooleanSchema;
                  break;
                case "flag":
                  x = n({ colorsModule: _, levenshteinDistance: w }), N.flags = F.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                  break;
                case "path":
                  x = t.StringSchema;
                  break;
                default:
                  throw new Error(`Unexpected type ${g.type}`);
              }
              if (g.exception ? N.validate = (P, $, D) => g.exception(P) || $.validate(P, D) : N.validate = (P, $, D) => P === void 0 || $.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f && !g.array) {
                let P = N.preprocess || (($) => $);
                N.preprocess = ($, D, T) => D.preprocess(P(Array.isArray($) ? s($) : $), T);
              }
              return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x.create(N) })) : x.create(Object.assign(Object.assign({}, N), I));
            }
            function y(g, c, f) {
              return i(g, c, f);
            }
            function h(g, c, f) {
              return i(g, c, Object.assign({ isCLI: true }, f));
            }
            r.exports = { normalizeApiOptions: y, normalizeCliOptions: h };
          } }), ut = te({ "src/language-js/loc.js"(e, r) {
            "use strict";
            ne();
            var t = Kn();
            function s(l) {
              var p, y;
              let h = l.range ? l.range[0] : l.start, g = (p = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p !== void 0 ? p : l.decorators;
              return t(g) ? Math.min(s(g[0]), h) : h;
            }
            function a(l) {
              return l.range ? l.range[1] : l.end;
            }
            function n(l, p) {
              let y = s(l);
              return Number.isInteger(y) && y === s(p);
            }
            function u(l, p) {
              let y = a(l);
              return Number.isInteger(y) && y === a(p);
            }
            function i(l, p) {
              return n(l, p) && u(l, p);
            }
            r.exports = { locStart: s, locEnd: a, hasSameLocStart: n, hasSameLoc: i };
          } }), jm = te({ "src/main/load-parser.js"(e, r) {
            ne(), r.exports = () => {
            };
          } }), qm = te({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
            "use strict";
            ne();
            var t = kr(), s = { shouldHighlight: () => false, getChalk: () => t };
            r.exports = s;
          } }), Mm = te({ "node_modules/@babel/code-frame/lib/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
            var r = qm(), t = false;
            function s(l) {
              return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
            }
            var a = /\r\n|[\n\r\u2028\u2029]/;
            function n(l, p, y) {
              let h = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h, l.end), { linesAbove: c = 2, linesBelow: f = 3 } = y || {}, F = h.line, _ = h.column, w = g.line, E = g.column, N = Math.max(F - (c + 1), 0), x = Math.min(p.length, w + f);
              F === -1 && (N = 0), w === -1 && (x = p.length);
              let I = w - F, P = {};
              if (I)
                for (let $ = 0; $ <= I; $++) {
                  let D = $ + F;
                  if (!_)
                    P[D] = true;
                  else if ($ === 0) {
                    let T = p[D - 1].length;
                    P[D] = [_, T - _ + 1];
                  } else if ($ === I)
                    P[D] = [0, E];
                  else {
                    let T = p[D - $].length;
                    P[D] = [0, T];
                  }
                }
              else
                _ === E ? _ ? P[F] = [_, 0] : P[F] = true : P[F] = [_, E - _];
              return { start: N, end: x, markerLines: P };
            }
            function u(l, p) {
              let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (y.highlightCode || y.forceColor) && (0, r.shouldHighlight)(y), g = (0, r.getChalk)(y), c = s(g), f = ($, D) => h ? $(D) : D, F = l.split(a), { start: _, end: w, markerLines: E } = n(p, F, y), N = p.start && typeof p.start.column == "number", x = String(w).length, P = (h ? (0, r.default)(l, y) : l).split(a, w).slice(_, w).map(($, D) => {
                let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x)} |`, o = E[T], d = !E[T + 1];
                if (o) {
                  let v = "";
                  if (Array.isArray(o)) {
                    let S = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                    v = [`
 `, f(c.gutter, C.replace(/\d/g, " ")), " ", S, f(c.marker, "^").repeat(b)].join(""), d && y.message && (v += " " + f(c.message, y.message));
                  }
                  return [f(c.marker, ">"), f(c.gutter, C), $.length > 0 ? ` ${$}` : "", v].join("");
                } else
                  return ` ${f(c.gutter, C)}${$.length > 0 ? ` ${$}` : ""}`;
              }).join(`
`);
              return y.message && !N && (P = `${" ".repeat(x + 1)}${y.message}
${P}`), h ? g.reset(P) : P;
            }
            function i(l, p, y) {
              let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              if (!t) {
                t = true;
                let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                if (wt.emitWarning)
                  wt.emitWarning(c, "DeprecationWarning");
                else {
                  let f = new Error(c);
                  f.name = "DeprecationWarning", console.warn(new Error(c));
                }
              }
              return y = Math.max(y, 0), u(l, { start: { column: y, line: p } }, h);
            }
          } }), tu = te({ "src/main/parser.js"(e, r) {
            "use strict";
            ne();
            var { ConfigError: t } = Qt(), s = ut(), a = jm(), { locStart: n, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
            function p(g) {
              let c = {};
              for (let f of g.plugins)
                if (f.parsers)
                  for (let F of i(f.parsers))
                    Object.defineProperty(c, F, l(f.parsers, F));
              return c;
            }
            function y(g) {
              let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g);
              if (typeof g.parser == "function")
                return { parse: g.parser, astFormat: "estree", locStart: n, locEnd: u };
              if (typeof g.parser == "string") {
                if (Object.prototype.hasOwnProperty.call(c, g.parser))
                  return c[g.parser];
                throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
              }
            }
            function h(g, c) {
              let f = p(c), F = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
                return f[w].parse;
              } }]))), _ = y(c, f);
              try {
                return _.preprocess && (g = _.preprocess(g, c)), { text: g, ast: _.parse(g, F, c) };
              } catch (w) {
                let { loc: E } = w;
                if (E) {
                  let { codeFrameColumns: N } = Mm();
                  throw w.codeFrame = N(g, E, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
                }
                throw w;
              }
            }
            r.exports = { parse: h, resolveParser: y };
          } }), uo = te({ "src/main/options.js"(e, r) {
            "use strict";
            ne();
            var t = ZD(), { UndefinedParserError: s } = Qt(), { getSupportInfo: a } = Xn(), n = Om(), { resolveParser: u } = tu(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
            function l(h) {
              let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, h), f = a({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, F = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x) => x.default !== void 0).map((x) => [x.name, x.default])));
              if (!c.parser) {
                if (!c.filepath)
                  (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
                else if (c.parser = y(c.filepath, c.plugins), !c.parser)
                  throw new s(`No parser could be inferred for file: ${c.filepath}`);
              }
              let _ = u(n.normalizeApiOptions(c, [f.find((x) => x.name === "parser")], { passThrough: true, logger: false }));
              c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
              let w = p(c);
              c.printer = w.printers[c.astFormat];
              let E = Object.fromEntries(f.filter((x) => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map((x) => [x.name, x.pluginDefaults[w.name]])), N = Object.assign(Object.assign({}, F), E);
              for (let [x, I] of Object.entries(N))
                (c[x] === null || c[x] === void 0) && (c[x] = I);
              return c.parser === "json" && (c.trailingComma = "none"), n.normalizeApiOptions(c, f, Object.assign({ passThrough: Object.keys(i) }, g));
            }
            function p(h) {
              let { astFormat: g } = h;
              if (!g)
                throw new Error("getPlugin() requires astFormat to be set");
              let c = h.plugins.find((f) => f.printers && f.printers[g]);
              if (!c)
                throw new Error(`Couldn't find plugin for AST format "${g}"`);
              return c;
            }
            function y(h, g) {
              let c = t.basename(h).toLowerCase(), F = a({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c));
              return F && F.parsers[0];
            }
            r.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
          } }), Rm = te({ "src/main/massage-ast.js"(e, r) {
            "use strict";
            ne();
            function t(s, a, n) {
              if (Array.isArray(s))
                return s.map((p) => t(p, a, n)).filter(Boolean);
              if (!s || typeof s != "object")
                return s;
              let u = a.printer.massageAstNode, i;
              u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
              let l = {};
              for (let [p, y] of Object.entries(s))
                !i.has(p) && typeof y != "function" && (l[p] = t(y, a, s));
              if (u) {
                let p = u(s, l, n);
                if (p === null)
                  return;
                if (p)
                  return p;
              }
              return l;
            }
            r.exports = t;
          } }), Zt = te({ "scripts/build/shims/assert.cjs"(e, r) {
            "use strict";
            ne();
            var t = () => {
            };
            t.ok = t, t.strictEqual = t, r.exports = t;
          } }), et = te({ "src/main/comments.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { builders: { line: s, hardline: a, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p } } = qe(), { hasNewline: y, skipNewline: h, skipSpaces: g, isPreviousLineEmpty: c, addLeadingComment: f, addDanglingComment: F, addTrailingComment: _ } = Ue(), w = /* @__PURE__ */ new WeakMap();
            function E(k, M, R) {
              if (!k)
                return;
              let { printer: q, locStart: J, locEnd: L } = M;
              if (R) {
                if (q.canAttachComment && q.canAttachComment(k)) {
                  let V;
                  for (V = R.length - 1; V >= 0 && !(J(R[V]) <= J(k) && L(R[V]) <= L(k)); --V)
                    ;
                  R.splice(V + 1, 0, k);
                  return;
                }
              } else if (w.has(k))
                return w.get(k);
              let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
                let [j] = V;
                return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
              }).map((V) => {
                let [, j] = V;
                return j;
              });
              if (Q) {
                R || (R = [], w.set(k, R));
                for (let V of Q)
                  E(V, M, R);
                return R;
              }
            }
            function N(k, M, R, q) {
              let { locStart: J, locEnd: L } = R, Q = J(M), V = L(M), j = E(k, R), Y, ie, ee = 0, ce = j.length;
              for (; ee < ce; ) {
                let W = ee + ce >> 1, K = j[W], de = J(K), ue = L(K);
                if (de <= Q && V <= ue)
                  return N(K, M, R, K);
                if (ue <= Q) {
                  Y = K, ee = W + 1;
                  continue;
                }
                if (V <= de) {
                  ie = K, ce = W;
                  continue;
                }
                throw new Error("Comment location overlaps with node location");
              }
              if (q && q.type === "TemplateLiteral") {
                let { quasis: W } = q, K = C(W, M, R);
                Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);
              }
              return { enclosingNode: q, precedingNode: Y, followingNode: ie };
            }
            var x = () => false;
            function I(k, M, R, q) {
              if (!Array.isArray(k))
                return;
              let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x, endOfLine: ie = x, remaining: ee = x } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q)), {}, { comment: W, text: R, options: q, ast: M, isLastComment: k.length - 1 === K }));
              for (let [W, K] of ce.entries()) {
                let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U, options: Z, ast: se, isLastComment: fe } = K;
                if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                  if (L(de) - L(se) <= 0) {
                    f(se, de);
                    continue;
                  }
                  if (Q(de) - Q(se) >= 0) {
                    _(se, de);
                    continue;
                  }
                }
                let ge;
                if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $(U, Z, ce, W))
                  de.placement = "ownLine", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : F(Fe || se, de));
                else if (D(U, Z, ce, W))
                  de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de));
                else if (de.placement = "remaining", !ee(...ge))
                  if (ue && z) {
                    let he = J.length;
                    he > 0 && J[he - 1].followingNode !== z && T(J, U, Z), J.push(K);
                  } else
                    ue ? _(ue, de) : z ? f(z, de) : F(Fe || se, de);
              }
              if (T(J, R, q), !j)
                for (let W of k)
                  delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
            }
            var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
            function $(k, M, R, q) {
              let { comment: J, precedingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = Q(J);
              if (L)
                for (let Y = q - 1; Y >= 0; Y--) {
                  let { comment: ie, precedingNode: ee } = R[Y];
                  if (ee !== L || !P(k.slice(V(ie), j)))
                    break;
                  j = Q(ie);
                }
              return y(k, j, { backwards: true });
            }
            function D(k, M, R, q) {
              let { comment: J, followingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = V(J);
              if (L)
                for (let Y = q + 1; Y < R.length; Y++) {
                  let { comment: ie, followingNode: ee } = R[Y];
                  if (ee !== L || !P(k.slice(j, Q(ie))))
                    break;
                  j = V(ie);
                }
              return y(k, j);
            }
            function T(k, M, R) {
              let q = k.length;
              if (q === 0)
                return;
              let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q) || /^[\s(]*$/, j = R.locStart(L), Y;
              for (Y = q; Y > 0; --Y) {
                let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
                t.strictEqual(ee, J), t.strictEqual(ce, L);
                let W = M.slice(R.locEnd(ie), j);
                if (V.test(W))
                  j = R.locStart(ie);
                else
                  break;
              }
              for (let [ie, { comment: ee }] of k.entries())
                ie < Y ? _(J, ee) : f(L, ee);
              for (let ie of [J, L])
                ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));
              k.length = 0;
            }
            function m(k, M) {
              let R = k.getValue();
              return R.printed = true, M.printer.printComment(k, M);
            }
            function C(k, M, R) {
              let q = R.locStart(M) - 1;
              for (let J = 1; J < k.length; ++J)
                if (q < R.locStart(k[J]))
                  return J - 1;
              return 0;
            }
            function o(k, M) {
              let R = k.getValue(), q = [m(k, M)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M;
              if (J.isBlockComment && J.isBlockComment(R)) {
                let ie = y(L, V(R)) ? y(L, Q(R), { backwards: true }) ? a : s : " ";
                q.push(ie);
              } else
                q.push(a);
              let Y = h(L, g(L, V(R)));
              return Y !== false && y(L, Y) && q.push(a), q;
            }
            function d(k, M) {
              let R = k.getValue(), q = m(k, M), { printer: J, originalText: L, locStart: Q } = M, V = J.isBlockComment && J.isBlockComment(R);
              if (y(L, Q(R), { backwards: true })) {
                let Y = c(L, R, Q);
                return i([a, Y ? a : "", q]);
              }
              let j = [" ", q];
              return V || (j = [i(j), n]), j;
            }
            function v(k, M, R, q) {
              let J = [], L = k.getValue();
              return !L || !L.comments || (k.each(() => {
                let Q = k.getValue();
                !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M));
              }, "comments"), J.length === 0) ? "" : R ? l(a, J) : u([a, l(a, J)]);
            }
            function S(k, M, R) {
              let q = k.getValue();
              if (!q)
                return {};
              let J = q.comments || [];
              R && (J = J.filter((j) => !R.has(j)));
              let L = q === M.cursorNode;
              if (J.length === 0) {
                let j = L ? p : "";
                return { leading: j, trailing: j };
              }
              let Q = [], V = [];
              return k.each(() => {
                let j = k.getValue();
                if (R && R.has(j))
                  return;
                let { leading: Y, trailing: ie } = j;
                Y ? Q.push(o(k, M)) : ie && V.push(d(k, M));
              }, "comments"), L && (Q.unshift(p), V.push(p)), { leading: Q, trailing: V };
            }
            function b(k, M, R, q) {
              let { leading: J, trailing: L } = S(k, R, q);
              return !J && !L ? M : [J, M, L];
            }
            function B(k) {
              if (k)
                for (let M of k) {
                  if (!M.printed)
                    throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                  delete M.printed;
                }
            }
            r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
          } }), $m = te({ "src/common/ast-path.js"(e, r) {
            "use strict";
            ne();
            var t = lt();
            function s(u, i) {
              let l = a(u.stack, i);
              return l === -1 ? null : u.stack[l];
            }
            function a(u, i) {
              for (let l = u.length - 1; l >= 0; l -= 2) {
                let p = u[l];
                if (p && !Array.isArray(p) && --i < 0)
                  return l;
              }
              return -1;
            }
            var n = class {
              constructor(u) {
                this.stack = [u];
              }
              getName() {
                let { stack: u } = this, { length: i } = u;
                return i > 1 ? u[i - 2] : null;
              }
              getValue() {
                return t(this.stack);
              }
              getNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u);
              }
              getParentNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u + 1);
              }
              call(u) {
                let { stack: i } = this, { length: l } = i, p = t(i);
                for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h[g - 1] = arguments[g];
                for (let f of h)
                  p = p[f], i.push(f, p);
                let c = u(this);
                return i.length = l, c;
              }
              callParent(u) {
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), p = this.stack.splice(l + 1), y = u(this);
                return this.stack.push(...p), y;
              }
              each(u) {
                let { stack: i } = this, { length: l } = i, p = t(i);
                for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h[g - 1] = arguments[g];
                for (let c of h)
                  p = p[c], i.push(c, p);
                for (let c = 0; c < p.length; ++c)
                  i.push(c, p[c]), u(this, c, p), i.length -= 2;
                i.length = l;
              }
              map(u) {
                let i = [];
                for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
                  p[y - 1] = arguments[y];
                return this.each((h, g, c) => {
                  i[g] = u(h, g, c);
                }, ...p), i;
              }
              try(u) {
                let { stack: i } = this, l = [...i];
                try {
                  return u();
                } finally {
                  i.length = 0, i.push(...l);
                }
              }
              match() {
                let u = this.stack.length - 1, i = null, l = this.stack[u--];
                for (var p = arguments.length, y = new Array(p), h = 0; h < p; h++)
                  y[h] = arguments[h];
                for (let g of y) {
                  if (l === void 0)
                    return false;
                  let c = null;
                  if (typeof i == "number" && (c = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c))
                    return false;
                  i = this.stack[u--], l = this.stack[u--];
                }
                return true;
              }
              findAncestor(u) {
                let i = this.stack.length - 1, l = null, p = this.stack[i--];
                for (; p; ) {
                  let y = null;
                  if (typeof l == "number" && (y = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, y))
                    return p;
                  l = this.stack[i--], p = this.stack[i--];
                }
              }
            };
            r.exports = n;
          } }), Vm = te({ "src/main/multiparser.js"(e, r) {
            "use strict";
            ne();
            var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = uo(), a = et();
            function n(i, l, p, y) {
              if (p.printer.embed && p.embeddedLanguageFormatting === "auto")
                return p.printer.embed(i, l, (h, g, c) => u(h, g, p, y, c), p);
            }
            function u(i, l, p, y) {
              let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c = tu().parse(i, g), { ast: f } = c;
              i = c.text;
              let F = f.comments;
              delete f.comments, a.attach(F, f, i, g), g[Symbol.for("comments")] = F || [], g[Symbol.for("tokens")] = f.tokens || [];
              let _ = y(f, g);
              return a.ensureAllCommentsPrinted(F), h ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
            }
            r.exports = { printSubtree: n };
          } }), Wm = te({ "src/main/ast-to-doc.js"(e, r) {
            "use strict";
            ne();
            var t = $m(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n } } = qe(), { printComments: u } = et(), i = Vm();
            function l(h, g) {
              let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
              f.preprocess && (h = f.preprocess(h, g));
              let F = /* @__PURE__ */ new Map(), _ = new t(h), w = E();
              return c > 0 && (w = a([s, w], c, g.tabWidth)), n(w), w;
              function E(x, I) {
                return x === void 0 || x === _ ? N(I) : Array.isArray(x) ? _.call(() => N(I), ...x) : _.call(() => N(I), x);
              }
              function N(x) {
                let I = _.getValue(), P = I && typeof I == "object" && x === void 0;
                if (P && F.has(I))
                  return F.get(I);
                let $ = y(_, g, E, x);
                return P && F.set(I, $), $;
              }
            }
            function p(h, g) {
              let { originalText: c, [Symbol.for("comments")]: f, locStart: F, locEnd: _ } = g, w = F(h), E = _(h), N = /* @__PURE__ */ new Set();
              for (let x of f)
                F(x) >= w && _(x) <= E && (x.printed = true, N.add(x));
              return { doc: c.slice(w, E), printedComments: N };
            }
            function y(h, g, c, f) {
              let F = h.getValue(), { printer: _ } = g, w, E;
              if (_.hasPrettierIgnore && _.hasPrettierIgnore(h))
                ({ doc: w, printedComments: E } = p(F, g));
              else {
                if (F)
                  try {
                    w = i.printSubtree(h, c, g, l);
                  } catch (N) {
                    if (globalThis.PRETTIER_DEBUG)
                      throw N;
                  }
                w || (w = _.print(h, g, c, f));
              }
              return (!_.willPrintOwnComments || !_.willPrintOwnComments(h, g)) && (w = u(h, w, g, E)), w;
            }
            r.exports = l;
          } }), Hm = te({ "src/main/range-util.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), s = et(), a = (f) => {
              let { parser: F } = f;
              return F === "json" || F === "json5" || F === "json-stringify";
            };
            function n(f, F) {
              let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([F.node, ...F.parentNodes]);
              return _.find((E) => y.has(E.type) && w.has(E));
            }
            function u(f) {
              let F = f.length - 1;
              for (; ; ) {
                let _ = f[F];
                if (_ && (_.type === "Program" || _.type === "File"))
                  F--;
                else
                  break;
              }
              return f.slice(0, F + 1);
            }
            function i(f, F, _) {
              let { locStart: w, locEnd: E } = _, N = f.node, x = F.node;
              if (N === x)
                return { startNode: N, endNode: x };
              let I = w(f.node);
              for (let $ of u(F.parentNodes))
                if (w($) >= I)
                  x = $;
                else
                  break;
              let P = E(F.node);
              for (let $ of u(f.parentNodes)) {
                if (E($) <= P)
                  N = $;
                else
                  break;
                if (N === x)
                  break;
              }
              return { startNode: N, endNode: x };
            }
            function l(f, F, _, w) {
              let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N = arguments.length > 5 ? arguments[5] : void 0, { locStart: x, locEnd: I } = _, P = x(f), $ = I(f);
              if (!(F > $ || F < P || N === "rangeEnd" && F === P || N === "rangeStart" && F === $)) {
                for (let D of s.getSortedChildNodes(f, _)) {
                  let T = l(D, F, _, w, [f, ...E], N);
                  if (T)
                    return T;
                }
                if (!w || w(f, E[0]))
                  return { node: f, parentNodes: E };
              }
            }
            function p(f, F) {
              return F !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
            }
            var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
            function g(f, F, _) {
              if (!F)
                return false;
              switch (f.parser) {
                case "flow":
                case "babel":
                case "babel-flow":
                case "babel-ts":
                case "typescript":
                case "acorn":
                case "espree":
                case "meriyah":
                case "__babel_estree":
                  return p(F.type, _ && _.type);
                case "json":
                case "json5":
                case "json-stringify":
                  return y.has(F.type);
                case "graphql":
                  return h.has(F.kind);
                case "vue":
                  return F.tag !== "root";
              }
              return false;
            }
            function c(f, F, _) {
              let { rangeStart: w, rangeEnd: E, locStart: N, locEnd: x } = F;
              t.ok(E > w);
              let I = f.slice(w, E).search(/\S/), P = I === -1;
              if (!P)
                for (w += I; E > w && !/\S/.test(f[E - 1]); --E)
                  ;
              let $ = l(_, w, F, (C, o) => g(F, C, o), [], "rangeStart"), D = P ? $ : l(_, E, F, (C) => g(F, C), [], "rangeEnd");
              if (!$ || !D)
                return { rangeStart: 0, rangeEnd: 0 };
              let T, m;
              if (a(F)) {
                let C = n($, D);
                T = C, m = C;
              } else
                ({ startNode: T, endNode: m } = i($, D, F));
              return { rangeStart: Math.min(N(T), N(m)), rangeEnd: Math.max(x(T), x(m)) };
            }
            r.exports = { calculateRange: c, findNodeAtOffset: l };
          } }), Gm = te({ "src/main/core.js"(e, r) {
            "use strict";
            ne();
            var { diffArrays: t } = BD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: n } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Jn(), y = uo().normalize, h = Rm(), g = et(), c = tu(), f = Wm(), F = Hm(), _ = "\uFEFF", w = Symbol("cursor");
            function E(m, C, o) {
              let d = C.comments;
              return d && (delete C.comments, g.attach(d, C, m, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, d;
            }
            function N(m, C) {
              let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              if (!m || m.trim().length === 0)
                return { formatted: "", cursorOffset: -1, comments: [] };
              let { ast: d, text: v } = c.parse(m, C);
              if (C.cursorOffset >= 0) {
                let k = F.findNodeAtOffset(d, C.cursorOffset, C);
                k && k.node && (C.cursorNode = k.node);
              }
              let S = E(v, d, C), b = f(d, C, o), B = s(b, C);
              if (g.ensureAllCommentsPrinted(S), o > 0) {
                let k = B.formatted.trim();
                B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
              }
              if (C.cursorOffset >= 0) {
                let k, M, R, q, J;
                if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q = 0, J = B.formatted), M === J)
                  return { formatted: B.formatted, cursorOffset: q + R, comments: S };
                let L = [...M];
                L.splice(R, 0, w);
                let Q = [...J], V = t(L, Q), j = q;
                for (let Y of V)
                  if (Y.removed) {
                    if (Y.value.includes(w))
                      break;
                  } else
                    j += Y.count;
                return { formatted: B.formatted, cursorOffset: j, comments: S };
              }
              return { formatted: B.formatted, cursorOffset: -1, comments: S };
            }
            function x(m, C) {
              let { ast: o, text: d } = c.parse(m, C), { rangeStart: v, rangeEnd: S } = F.calculateRange(d, C, o), b = d.slice(v, S), B = Math.min(v, d.lastIndexOf(`
`, v) + 1), k = d.slice(B, v).match(/^\s*/)[0], M = n(k, C.tabWidth), R = N(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q = R.formatted.trimEnd(), { cursorOffset: J } = C;
              J > S ? J += q.length - b.length : R.cursorOffset >= 0 && (J = R.cursorOffset + v);
              let L = d.slice(0, v) + q + d.slice(S);
              if (C.endOfLine !== "lf") {
                let Q = i(C.endOfLine);
                J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
              }
              return { formatted: L, cursorOffset: J, comments: R.comments };
            }
            function I(m, C, o) {
              return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
            }
            function P(m, C) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: v } = C;
              return o = I(m, o, -1), d = I(m, d, 0), v = I(m, v, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v });
            }
            function $(m, C) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
              if (b && (m = m.slice(1), o--, d--, v--), S === "auto" && (S = u(m)), m.includes("\r")) {
                let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
                o -= B(o), d -= B(d), v -= B(v), m = p(m);
              }
              return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S })) };
            }
            function D(m, C) {
              let o = c.resolveParser(C);
              return !o.hasPragma || o.hasPragma(m);
            }
            function T(m, C) {
              let { hasBOM: o, text: d, options: v } = $(m, y(C));
              if (v.rangeStart >= v.rangeEnd && d !== "" || v.requirePragma && !D(d, v))
                return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
              let S;
              return v.rangeStart > 0 || v.rangeEnd < d.length ? S = x(d, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(d, v) && (d = v.printer.insertPragma(d)), S = N(d, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
            }
            r.exports = { formatWithCursor: T, parse(m, C, o) {
              let { text: d, options: v } = $(m, y(C)), S = c.parse(d, v);
              return o && (S.ast = h(S.ast, v)), S;
            }, formatAST(m, C) {
              C = y(C);
              let o = f(m, C);
              return s(o, C);
            }, formatDoc(m, C) {
              return T(a(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
            }, printToDoc(m, C) {
              C = y(C);
              let { ast: o, text: d } = c.parse(m, C);
              return E(d, o, C), f(o, C);
            }, printDocToString(m, C) {
              return s(m, y(C));
            } };
          } }), Um = te({ "src/common/util-shared.js"(e, r) {
            "use strict";
            ne();
            var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D } = Ue();
            r.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D };
          } }), _t = te({ "src/utils/create-language.js"(e, r) {
            "use strict";
            ne(), r.exports = function(t, s) {
              let { languageId: a } = t, n = Hn(t, CD);
              return Object.assign(Object.assign({ linguistLanguageId: a }, n), s(t));
            };
          } }), Jm = te({ "node_modules/esutils/lib/ast.js"(e, r) {
            ne(), function() {
              "use strict";
              function t(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "ArrayExpression":
                  case "AssignmentExpression":
                  case "BinaryExpression":
                  case "CallExpression":
                  case "ConditionalExpression":
                  case "FunctionExpression":
                  case "Identifier":
                  case "Literal":
                  case "LogicalExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ObjectExpression":
                  case "SequenceExpression":
                  case "ThisExpression":
                  case "UnaryExpression":
                  case "UpdateExpression":
                    return true;
                }
                return false;
              }
              function s(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "DoWhileStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "WhileStatement":
                    return true;
                }
                return false;
              }
              function a(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "BlockStatement":
                  case "BreakStatement":
                  case "ContinueStatement":
                  case "DebuggerStatement":
                  case "DoWhileStatement":
                  case "EmptyStatement":
                  case "ExpressionStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "IfStatement":
                  case "LabeledStatement":
                  case "ReturnStatement":
                  case "SwitchStatement":
                  case "ThrowStatement":
                  case "TryStatement":
                  case "VariableDeclaration":
                  case "WhileStatement":
                  case "WithStatement":
                    return true;
                }
                return false;
              }
              function n(l) {
                return a(l) || l != null && l.type === "FunctionDeclaration";
              }
              function u(l) {
                switch (l.type) {
                  case "IfStatement":
                    return l.alternate != null ? l.alternate : l.consequent;
                  case "LabeledStatement":
                  case "ForStatement":
                  case "ForInStatement":
                  case "WhileStatement":
                  case "WithStatement":
                    return l.body;
                }
                return null;
              }
              function i(l) {
                var p;
                if (l.type !== "IfStatement" || l.alternate == null)
                  return false;
                p = l.consequent;
                do {
                  if (p.type === "IfStatement" && p.alternate == null)
                    return true;
                  p = u(p);
                } while (p);
                return false;
              }
              r.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
            }();
          } }), so = te({ "node_modules/esutils/lib/code.js"(e, r) {
            ne(), function() {
              "use strict";
              var t, s, a, n, u, i;
              s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
              function l(E) {
                return 48 <= E && E <= 57;
              }
              function p(E) {
                return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
              }
              function y(E) {
                return E >= 48 && E <= 55;
              }
              a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
              function h(E) {
                return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a.indexOf(E) >= 0;
              }
              function g(E) {
                return E === 10 || E === 13 || E === 8232 || E === 8233;
              }
              function c(E) {
                if (E <= 65535)
                  return String.fromCharCode(E);
                var N = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x = String.fromCharCode((E - 65536) % 1024 + 56320);
                return N + x;
              }
              for (n = new Array(128), i = 0; i < 128; ++i)
                n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
              for (u = new Array(128), i = 0; i < 128; ++i)
                u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
              function f(E) {
                return E < 128 ? n[E] : s.NonAsciiIdentifierStart.test(c(E));
              }
              function F(E) {
                return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c(E));
              }
              function _(E) {
                return E < 128 ? n[E] : t.NonAsciiIdentifierStart.test(c(E));
              }
              function w(E) {
                return E < 128 ? u[E] : t.NonAsciiIdentifierPart.test(c(E));
              }
              r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: y, isWhiteSpace: h, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: F, isIdentifierStartES6: _, isIdentifierPartES6: w };
            }();
          } }), zm = te({ "node_modules/esutils/lib/keyword.js"(e, r) {
            ne(), function() {
              "use strict";
              var t = so();
              function s(f) {
                switch (f) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }
              function a(f, F) {
                return !F && f === "yield" ? false : n(f, F);
              }
              function n(f, F) {
                if (F && s(f))
                  return true;
                switch (f.length) {
                  case 2:
                    return f === "if" || f === "in" || f === "do";
                  case 3:
                    return f === "var" || f === "for" || f === "new" || f === "try";
                  case 4:
                    return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                  case 5:
                    return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                  case 6:
                    return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                  case 7:
                    return f === "default" || f === "finally" || f === "extends";
                  case 8:
                    return f === "function" || f === "continue" || f === "debugger";
                  case 10:
                    return f === "instanceof";
                  default:
                    return false;
                }
              }
              function u(f, F) {
                return f === "null" || f === "true" || f === "false" || a(f, F);
              }
              function i(f, F) {
                return f === "null" || f === "true" || f === "false" || n(f, F);
              }
              function l(f) {
                return f === "eval" || f === "arguments";
              }
              function p(f) {
                var F, _, w;
                if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w)))
                  return false;
                for (F = 1, _ = f.length; F < _; ++F)
                  if (w = f.charCodeAt(F), !t.isIdentifierPartES5(w))
                    return false;
                return true;
              }
              function y(f, F) {
                return (f - 55296) * 1024 + (F - 56320) + 65536;
              }
              function h(f) {
                var F, _, w, E, N;
                if (f.length === 0)
                  return false;
                for (N = t.isIdentifierStartES6, F = 0, _ = f.length; F < _; ++F) {
                  if (w = f.charCodeAt(F), 55296 <= w && w <= 56319) {
                    if (++F, F >= _ || (E = f.charCodeAt(F), !(56320 <= E && E <= 57343)))
                      return false;
                    w = y(w, E);
                  }
                  if (!N(w))
                    return false;
                  N = t.isIdentifierPartES6;
                }
                return true;
              }
              function g(f, F) {
                return p(f) && !u(f, F);
              }
              function c(f, F) {
                return h(f) && !i(f, F);
              }
              r.exports = { isKeywordES5: a, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: h, isIdentifierES5: g, isIdentifierES6: c };
            }();
          } }), Xm = te({ "node_modules/esutils/lib/utils.js"(e) {
            ne(), function() {
              "use strict";
              e.ast = Jm(), e.code = so(), e.keyword = zm();
            }();
          } }), Pt = te({ "src/language-js/utils/is-block-comment.js"(e, r) {
            "use strict";
            ne();
            var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
            r.exports = s;
          } }), Km = te({ "src/language-js/utils/is-node-matches.js"(e, r) {
            "use strict";
            ne();
            function t(a, n) {
              let u = n.split(".");
              for (let i = u.length - 1; i >= 0; i--) {
                let l = u[i];
                if (i === 0)
                  return a.type === "Identifier" && a.name === l;
                if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l)
                  return false;
                a = a.object;
              }
            }
            function s(a, n) {
              return n.some((u) => t(a, u));
            }
            r.exports = s;
          } }), Ke = te({ "src/language-js/utils/index.js"(e, r) {
            "use strict";
            ne();
            var t = Xm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue(), { locStart: p, locEnd: y, hasSameLocStart: h } = ut(), g = Pt(), c = Km(), f = "(?:(?=.)\\s)", F = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
            function w(O) {
              var me, _e;
              return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F.test(O.trailingComments[0].value);
            }
            function E(O) {
              let me = O == null ? void 0 : O[0];
              return g(me) && _.test(me.value);
            }
            function N(O, me) {
              if (!O || typeof O != "object")
                return false;
              if (Array.isArray(O))
                return O.some((He) => N(He, me));
              let _e = me(O);
              return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N(He, me));
            }
            function x(O) {
              return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st(O) || O.type === "TSNonNullExpression";
            }
            function I(O) {
              var me, _e, He, Ge, it, Qe;
              return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;
            }
            function P(O, me) {
              if (me.expressions)
                return ["expressions", 0];
              if (me.left)
                return ["left"];
              if (me.test)
                return ["test"];
              if (me.object)
                return ["object"];
              if (me.callee)
                return ["callee"];
              if (me.tag)
                return ["tag"];
              if (me.argument)
                return ["argument"];
              if (me.expression)
                return ["expression"];
              throw new Error("Unexpected node has no left side.");
            }
            function $(O) {
              return O = new Set(O), (me) => O.has(me == null ? void 0 : me.type);
            }
            var D = $(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
            function m(O) {
              let me = O.getParentNode();
              return O.getName() === "declaration" && T(me) ? me : null;
            }
            var C = $(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
            function o(O) {
              return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
            }
            function d(O) {
              return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
            }
            function v(O) {
              return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
            }
            var S = $(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $(["FunctionExpression", "ArrowFunctionExpression"]);
            function B(O) {
              return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
            }
            function k(O) {
              return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
            }
            var M = $(["JSXElement", "JSXFragment"]);
            function R(O, me) {
              if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
                return false;
              let _e = me.getNode();
              if (!_e.expression || !M(_e.expression))
                return false;
              let He = me.getParentNode();
              return He.type === "Program" && He.body.length === 1;
            }
            function q(O) {
              return O.kind === "get" || O.kind === "set";
            }
            function J(O) {
              return q(O) || h(O, O.value);
            }
            function L(O) {
              return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
            }
            function Q(O) {
              return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h(O, O.typeAnnotation);
            }
            var V = $(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
            function j(O) {
              return ue(O) || O.type === "BindExpression" && Boolean(O.object);
            }
            var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
            function ie(O) {
              return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
            }
            function ee(O) {
              let me = /^(?:before|after)(?:Each|All)$/;
              return O.callee.type === "Identifier" && me.test(O.callee.name) && O.arguments.length === 1;
            }
            var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
            function W(O) {
              return c(O, ce);
            }
            function K(O, me) {
              if (O.type !== "CallExpression")
                return false;
              if (O.arguments.length === 1) {
                if (k(O) && me && K(me))
                  return b(O.arguments[0]);
                if (ee(O))
                  return k(O.arguments[0]);
              } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee))
                return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
              return false;
            }
            var de = $(["CallExpression", "OptionalCallExpression"]), ue = $(["MemberExpression", "OptionalMemberExpression"]);
            function Fe(O) {
              let me = "expressions";
              O.type === "TSTemplateLiteralType" && (me = "types");
              let _e = O[me];
              return _e.length === 0 ? false : _e.every((He) => {
                if (Me(He))
                  return false;
                if (He.type === "Identifier" || He.type === "ThisExpression")
                  return true;
                if (ue(He)) {
                  let Ge = He;
                  for (; ue(Ge); )
                    if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me(Ge)))
                      return false;
                  return Ge.type === "Identifier" || Ge.type === "ThisExpression";
                }
                return false;
              });
            }
            function z(O, me) {
              return O === "+" || O === "-" ? O + me : me;
            }
            function U(O, me) {
              let _e = p(me), He = n(O, y(me));
              return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
            }
            function Z(O, me) {
              return M(me) ? Oe(me) : Me(me, Te.Leading, (_e) => a(O, y(_e)));
            }
            function se(O, me) {
              return me.parser !== "json" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me.parser === "babel-ts" && O.type === "ClassProperty" || me.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
            }
            function fe(O) {
              return /^(?:\d+|\d+\.\d+)$/.test(O);
            }
            function ge(O, me) {
              let _e = /^[fx]?(?:describe|it|test)$/;
              return me.type === "TaggedTemplateExpression" && me.quasi === O && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && _e.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && _e.test(me.tag.object.object.name));
            }
            function he(O) {
              return O.quasis.some((me) => me.value.raw.includes(`
`));
            }
            function we(O, me) {
              return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a(me, p(O), { backwards: true });
            }
            function ke(O) {
              if (!Me(O))
                return false;
              let me = s(ae(O, Te.Dangling));
              return me && !g(me);
            }
            function Re(O) {
              if (O.length <= 1)
                return false;
              let me = 0;
              for (let _e of O)
                if (b(_e)) {
                  if (me += 1, me > 1)
                    return true;
                } else if (de(_e)) {
                  for (let He of _e.arguments)
                    if (b(He))
                      return true;
                }
              return false;
            }
            function Ne(O) {
              let me = O.getValue(), _e = O.getParentNode();
              return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;
            }
            function Pe(O, me) {
              if (me >= 2)
                return false;
              let _e = (Qe) => Pe(Qe, me + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
              if (He && l(He) > 5)
                return false;
              if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import")
                return true;
              if (O.type === "TemplateLiteral")
                return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
              if (O.type === "ObjectExpression")
                return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
              if (O.type === "ArrayExpression")
                return O.elements.every((Qe) => Qe === null || _e(Qe));
              if (tt(O))
                return (O.type === "ImportExpression" || Pe(O.callee, me)) && Ye(O).every(_e);
              if (ue(O))
                return Pe(O.object, me) && Pe(O.property, me);
              let Ge = { "!": true, "-": true, "+": true, "~": true };
              if (O.type === "UnaryExpression" && Ge[O.operator])
                return Pe(O.argument, me);
              let it = { "++": true, "--": true };
              return O.type === "UpdateExpression" && it[O.operator] ? Pe(O.argument, me) : O.type === "TSNonNullExpression" ? Pe(O.expression, me) : false;
            }
            function oe(O) {
              var me, _e;
              return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;
            }
            function H(O) {
              return O;
            }
            function pe(O) {
              return O.filepath && /\.tsx$/i.test(O.filepath);
            }
            function X(O) {
              let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
              return O.trailingComma === "es5" && me === "es5" || O.trailingComma === "all" && (me === "all" || me === "es5");
            }
            function le(O, me) {
              switch (O.type) {
                case "BinaryExpression":
                case "LogicalExpression":
                case "AssignmentExpression":
                case "NGPipeExpression":
                  return le(O.left, me);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return le(O.object, me);
                case "TaggedTemplateExpression":
                  return O.tag.type === "FunctionExpression" ? false : le(O.tag, me);
                case "CallExpression":
                case "OptionalCallExpression":
                  return O.callee.type === "FunctionExpression" ? false : le(O.callee, me);
                case "ConditionalExpression":
                  return le(O.test, me);
                case "UpdateExpression":
                  return !O.prefix && le(O.argument, me);
                case "BindExpression":
                  return O.object && le(O.object, me);
                case "SequenceExpression":
                  return le(O.expressions[0], me);
                case "TSSatisfiesExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                  return le(O.expression, me);
                default:
                  return me(O);
              }
            }
            var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
            function A(O, me) {
              return !(re(me) !== re(O) || O === "**" || Ae[O] && Ae[me] || me === "%" && Ee[O] || O === "%" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);
            }
            var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me) => O.map((_e) => [_e, me])));
            function re(O) {
              return G.get(O);
            }
            function ye(O) {
              return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
            }
            function Ce(O) {
              var me;
              if (O.rest)
                return true;
              let _e = ve(O);
              return ((me = s(_e)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
            }
            var Be = /* @__PURE__ */ new WeakMap();
            function ve(O) {
              if (Be.has(O))
                return Be.get(O);
              let me = [];
              return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;
            }
            function ze(O, me) {
              let _e = O.getValue(), He = 0, Ge = (it) => me(it, He++);
              _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
            }
            var be = /* @__PURE__ */ new WeakMap();
            function Ye(O) {
              if (be.has(O))
                return be.get(O);
              let me = O.arguments;
              return O.type === "ImportExpression" && (me = [O.source], O.attributes && me.push(O.attributes)), be.set(O, me), me;
            }
            function Se(O, me) {
              let _e = O.getValue();
              _e.type === "ImportExpression" ? (O.call((He) => me(He, 0), "source"), _e.attributes && O.call((He) => me(He, 1), "attributes")) : O.each(me, "arguments");
            }
            function Ie(O) {
              return O.value.trim() === "prettier-ignore" && !O.unignore;
            }
            function Oe(O) {
              return O && (O.prettierIgnore || Me(O, Te.PrettierIgnore));
            }
            function Je(O) {
              let me = O.getValue();
              return Oe(me);
            }
            var Te = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me) => {
              if (typeof O == "function" && (me = O, O = 0), O || me)
                return (_e, He, Ge) => !(O & Te.Leading && !_e.leading || O & Te.Trailing && !_e.trailing || O & Te.Dangling && (_e.leading || _e.trailing) || O & Te.Block && !g(_e) || O & Te.Line && !D(_e) || O & Te.First && He !== 0 || O & Te.Last && He !== Ge.length - 1 || O & Te.PrettierIgnore && !Ie(_e) || me && !me(_e));
            };
            function Me(O, me, _e) {
              if (!u(O == null ? void 0 : O.comments))
                return false;
              let He = je(me, _e);
              return He ? O.comments.some(He) : true;
            }
            function ae(O, me, _e) {
              if (!Array.isArray(O == null ? void 0 : O.comments))
                return [];
              let He = je(me, _e);
              return He ? O.comments.filter(He) : O.comments;
            }
            var nt = (O, me) => {
              let { originalText: _e } = me;
              return i(_e, y(O));
            };
            function tt(O) {
              return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
            }
            function Ve(O) {
              return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
            }
            function We(O) {
              return Boolean(O.__isUsingHackPipeline);
            }
            var Xe = Symbol("ifWithoutBlockAndSameLineComment");
            function st(O) {
              return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
            }
            r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x, hasNode: N, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U, isFunctionCompositionArgs: Re, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye, shouldFlatten: A, startsWithNoLookaheadToken: le, getPrecedence: re, hasComment: Me, getComments: ae, CommentCheckFlags: Te, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st };
          } }), jt = te({ "src/language-js/print/template-literal.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { getStringWidth: s, getIndentSize: a } = Ue(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p, align: y, lineSuffixBoundary: h, addAlignmentToDoc: g }, printer: { printDocToString: c }, utils: { mapDoc: f } } = qe(), { isBinaryish: F, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: E, isMemberExpression: N, isTSTypeExpression: x } = Ke();
            function I(C, o, d) {
              let v = C.getValue();
              if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
                let R = P(C, d, o);
                if (R)
                  return R;
              }
              let b = "expressions";
              v.type === "TSTemplateLiteralType" && (b = "types");
              let B = [], k = C.map(o, b), M = w(v);
              return M && (k = k.map((R) => c(R, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h, "`"), C.each((R) => {
                let q = R.getName();
                if (B.push(o()), q < k.length) {
                  let { tabWidth: J } = d, L = R.getValue(), Q = a(L.value.raw, J), V = k[q];
                  if (!M) {
                    let Y = v[b][q];
                    (E(Y) || N(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x(Y) || F(Y)) && (V = [p([i, V]), i]);
                  }
                  let j = Q === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);
                  B.push(l(["${", j, h, "}"]));
                }
              }, "quasis"), B.push("`"), B;
            }
            function P(C, o, d) {
              let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
              if (S.length > 1 || S.some((b) => b.length > 0)) {
                o.__inJestEach = true;
                let b = C.map(d, "expressions");
                o.__inJestEach = false;
                let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
                for (let L = 1; L < v.quasis.length; L++) {
                  let Q = t(M), V = k[L - 1];
                  Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
                }
                let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q = Array.from({ length: R }).fill(0), J = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
                for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak))
                  for (let [Q, V] of L.entries())
                    q[Q] = Math.max(q[Q], s(V));
                return B.push(h, "`", p([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q[V] - s(Q))))))]), u, "`"), B;
              }
            }
            function $(C, o) {
              let d = C.getValue(), v = o();
              return E(d) && (v = l([p([i, v]), i])), ["${", v, h, "}"];
            }
            function D(C, o) {
              return C.map((d) => $(d, o), "expressions");
            }
            function T(C, o) {
              return f(C, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m(d) : d);
            }
            function m(C) {
              return C.replace(/([\\`]|\${)/g, "\\$1");
            }
            r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
          } }), Ym = te({ "src/language-js/embed/markdown.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: n } } = qe(), { escapeTemplateCharacters: u } = jt();
            function i(p, y, h) {
              let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, E) => "\\".repeat(E.length / 2) + "`"), f = l(c), F = f !== "";
              F && (c = c.replace(new RegExp(`^${f}`, "gm"), ""));
              let _ = u(h(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
              return ["`", F ? t([s, _]) : [a, n(_)], s, "`"];
            }
            function l(p) {
              let y = p.match(/^([^\S\n]*)\S/m);
              return y === null ? "" : y[1];
            }
            r.exports = i;
          } }), Qm = te({ "src/language-js/embed/css.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, hardline: a, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = jt();
            function y(c, f, F) {
              let _ = c.getValue(), w = _.quasis.map((P) => P.value.raw), E = 0, N = w.reduce((P, $, D) => D === 0 ? $ : P + "@prettier-placeholder-" + E++ + "-id" + $, ""), x = F(N, { parser: "scss" }, { stripTrailingHardline: true }), I = p(c, f);
              return h(x, _, I);
            }
            function h(c, f, F) {
              if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
                return "``";
              let w = g(c, F);
              if (!w)
                throw new Error("Couldn't insert all the expressions");
              return ["`", s([a, w]), n, "`"];
            }
            function g(c, f) {
              if (!t(f))
                return c;
              let F = 0, _ = u(l(c), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((E, N) => N % 2 === 0 ? i(E) : (F++, f[E])));
              return f.length === F ? _ : null;
            }
            r.exports = y;
          } }), Zm = te({ "src/language-js/embed/graphql.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = jt();
            function i(p, y, h) {
              let g = p.getValue(), c = g.quasis.length;
              if (c === 1 && g.quasis[0].value.raw.trim() === "")
                return "``";
              let f = u(p, y), F = [];
              for (let _ = 0; _ < c; _++) {
                let w = g.quasis[_], E = _ === 0, N = _ === c - 1, x = w.value.cooked, I = x.split(`
`), P = I.length, $ = f[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
                if (!N && /#[^\n\r]*$/.test(I[P - 1]))
                  return null;
                let C = null;
                m ? C = l(I) : C = h(x, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !E && D && F.push(""), F.push(C), !N && T && F.push("")) : !E && !N && D && F.push(""), $ && F.push($);
              }
              return ["`", t([a, s(a, F)]), a, "`"];
            }
            function l(p) {
              let y = [], h = false, g = p.map((c) => c.trim());
              for (let [c, f] of g.entries())
                f !== "" && (g[c - 1] === "" && h ? y.push([a, f]) : y.push(f), h = true);
              return y.length === 0 ? null : s(a, y);
            }
            r.exports = i;
          } }), ed = te({ "src/language-js/embed/html.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t, line: s, hardline: a, group: n }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt(), p = 0;
            function y(h, g, c, f, F) {
              let { parser: _ } = F, w = h.getValue(), E = p;
              p = p + 1 >>> 0;
              let N = (d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${E}_IN_JS`, x = w.quasis.map((d, v, S) => v === S.length - 1 ? d.value.cooked : d.value.cooked + N(v)).join(""), I = i(h, g);
              if (I.length === 0 && x.trim().length === 0)
                return "``";
              let P = new RegExp(N("(\\d+)"), "g"), $ = 0, D = c(x, { parser: _, __onHtmlRoot(d) {
                $ = d.children.length;
              } }, { stripTrailingHardline: true }), T = u(D, (d) => {
                if (typeof d != "string")
                  return d;
                let v = [], S = d.split(P);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  if (b % 2 === 0) {
                    B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
                    continue;
                  }
                  let k = Number(B);
                  v.push(I[k]);
                }
                return v;
              }), m = /^\s/.test(x) ? " " : "", C = /\s$/.test(x) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a : m && C ? s : null;
              return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m, $ > 1 ? t(n(T)) : n(T), C, "`"]);
            }
            r.exports = y;
          } }), td = te({ "src/language-js/embed.js"(e, r) {
            "use strict";
            ne();
            var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), n = Ym(), u = Qm(), i = Zm(), l = ed();
            function p(D) {
              if (g(D) || _(D) || w(D) || c(D))
                return "css";
              if (x(D))
                return "graphql";
              if (P(D))
                return "html";
              if (f(D))
                return "angular";
              if (h(D))
                return "markdown";
            }
            function y(D, T, m, C) {
              let o = D.getValue();
              if (o.type !== "TemplateLiteral" || $(o))
                return;
              let d = p(D);
              if (d) {
                if (d === "markdown")
                  return n(D, T, m);
                if (d === "css")
                  return u(D, T, m);
                if (d === "graphql")
                  return i(D, T, m);
                if (d === "html" || d === "angular")
                  return l(D, T, m, C, { parser: d });
              }
            }
            function h(D) {
              let T = D.getValue(), m = D.getParentNode();
              return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
            }
            function g(D) {
              let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
              return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
            }
            function c(D) {
              return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...F);
            }
            function f(D) {
              return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...F);
            }
            var F = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
            function _(D) {
              let T = D.getParentNode();
              if (!T || T.type !== "TaggedTemplateExpression")
                return false;
              let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
              switch (m.type) {
                case "MemberExpression":
                  return E(m.object) || N(m);
                case "CallExpression":
                  return E(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (E(m.callee.object.object) || N(m.callee.object)) || m.callee.object.type === "CallExpression" && E(m.callee.object.callee));
                case "Identifier":
                  return m.name === "css";
                default:
                  return false;
              }
            }
            function w(D) {
              let T = D.getParentNode(), m = D.getParentNode(1);
              return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
            }
            function E(D) {
              return D.type === "Identifier" && D.name === "styled";
            }
            function N(D) {
              return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
            }
            function x(D) {
              let T = D.getValue(), m = D.getParentNode();
              return I(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
            }
            function I(D, T) {
              return t(D, s.Block | s.Leading, (m) => {
                let { value: C } = m;
                return C === ` ${T} `;
              });
            }
            function P(D) {
              return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
            }
            function $(D) {
              let { quasis: T } = D;
              return T.some((m) => {
                let { value: { cooked: C } } = m;
                return C === null;
              });
            }
            r.exports = y;
          } }), rd = te({ "src/language-js/clean.js"(e, r) {
            "use strict";
            ne();
            var t = Pt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
              for (let i of u.quasis)
                delete i.value;
            };
            function n(u, i, l) {
              if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
                return null;
              if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h) => h.name.name === "jsx"))
                for (let { type: h, expression: g } of i.children)
                  h === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a(g);
              u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
              let p = u.expression || u.callee;
              if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
                let h = u.expression.arguments[0].properties;
                for (let [g, c] of i.expression.arguments[0].properties.entries())
                  switch (h[g].key.name) {
                    case "styles":
                      c.value.type === "ArrayExpression" && a(c.value.elements[0]);
                      break;
                    case "template":
                      c.value.type === "TemplateLiteral" && a(c.value);
                      break;
                  }
              }
              if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
                var y;
                (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t(g) && ["GraphQL", "HTML"].some((c) => g.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
              }
              if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
                return i.types[0];
            }
            n.ignoredProperties = s, r.exports = n;
          } }), io = {};
          Kt(io, { EOL: () => Wn, arch: () => nd, cpus: () => Do, default: () => vo, endianness: () => ao, freemem: () => po, getNetworkInterfaces: () => ho, hostname: () => oo, loadavg: () => lo, networkInterfaces: () => yo, platform: () => ud, release: () => go, tmpDir: () => $n, tmpdir: () => Vn, totalmem: () => fo, type: () => mo, uptime: () => co });
          function ao() {
            if (typeof Tr > "u") {
              var e = new ArrayBuffer(2), r = new Uint8Array(e), t = new Uint16Array(e);
              if (r[0] = 1, r[1] = 2, t[0] === 258)
                Tr = "BE";
              else if (t[0] === 513)
                Tr = "LE";
              else
                throw new Error("unable to figure out endianess");
            }
            return Tr;
          }
          function oo() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
          }
          function lo() {
            return [];
          }
          function co() {
            return 0;
          }
          function po() {
            return Number.MAX_VALUE;
          }
          function fo() {
            return Number.MAX_VALUE;
          }
          function Do() {
            return [];
          }
          function mo() {
            return "Browser";
          }
          function go() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
          }
          function yo() {
          }
          function ho() {
          }
          function nd() {
            return "javascript";
          }
          function ud() {
            return "browser";
          }
          function $n() {
            return "/tmp";
          }
          var Tr, Vn, Wn, vo, sd = ht({ "node-modules-polyfills:os"() {
            ne(), Vn = $n, Wn = `
`, vo = { EOL: Wn, tmpdir: Vn, tmpDir: $n, networkInterfaces: yo, getNetworkInterfaces: ho, release: go, type: mo, cpus: Do, totalmem: fo, freemem: po, uptime: co, loadavg: lo, hostname: oo, endianness: ao };
          } }), id = te({ "node-modules-polyfills-commonjs:os"(e, r) {
            ne();
            var t = (sd(), ft(io));
            if (t && t.default) {
              r.exports = t.default;
              for (let s in t)
                r.exports[s] = t[s];
            } else
              t && (r.exports = t);
          } }), ad = te({ "node_modules/detect-newline/index.js"(e, r) {
            "use strict";
            ne();
            var t = (s) => {
              if (typeof s != "string")
                throw new TypeError("Expected a string");
              let a = s.match(/(?:\r?\n)/g) || [];
              if (a.length === 0)
                return;
              let n = a.filter((i) => i === `\r
`).length, u = a.length - n;
              return n > u ? `\r
` : `
`;
            };
            r.exports = t, r.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
          } }), od = te({ "node_modules/jest-docblock/build/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c, e.parse = F, e.parseWithComments = _, e.print = w, e.strip = f;
            function r() {
              let N = id();
              return r = function() {
                return N;
              }, N;
            }
            function t() {
              let N = s(ad());
              return t = function() {
                return N;
              }, N;
            }
            function s(N) {
              return N && N.__esModule ? N : { default: N };
            }
            var a = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, g = [];
            function c(N) {
              let x = N.match(u);
              return x ? x[0].trimLeft() : "";
            }
            function f(N) {
              let x = N.match(u);
              return x && x[0] ? N.substring(x[0].length) : N;
            }
            function F(N) {
              return _(N).pragmas;
            }
            function _(N) {
              let x = (0, t().default)(N) || r().EOL;
              N = N.replace(n, "").replace(a, "").replace(h, "$1");
              let I = "";
              for (; I !== N; )
                I = N, N = N.replace(p, `${x}$1 $2${x}`);
              N = N.replace(l, "").trimRight();
              let P = /* @__PURE__ */ Object.create(null), $ = N.replace(y, "").replace(l, "").trimRight(), D;
              for (; D = y.exec(N); ) {
                let T = D[2].replace(i, "");
                typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
              }
              return { comments: $, pragmas: P };
            }
            function w(N) {
              let { comments: x = "", pragmas: I = {} } = N, P = (0, t().default)(x) || r().EOL, $ = "/**", D = " *", T = " */", m = Object.keys(I), C = m.map((d) => E(d, I[d])).reduce((d, v) => d.concat(v), []).map((d) => `${D} ${d}${P}`).join("");
              if (!x) {
                if (m.length === 0)
                  return "";
                if (m.length === 1 && !Array.isArray(I[m[0]])) {
                  let d = I[m[0]];
                  return `${$} ${E(m[0], d)[0]}${T}`;
                }
              }
              let o = x.split(P).map((d) => `${D} ${d}`).join(P) + P;
              return $ + P + (x ? o : "") + (x && m.length ? D + P : "") + C + T;
            }
            function E(N, x) {
              return g.concat(x).map((I) => `@${N} ${I}`.trim());
            }
          } }), ld = te({ "src/language-js/utils/get-shebang.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              if (!s.startsWith("#!"))
                return "";
              let a = s.indexOf(`
`);
              return a === -1 ? s : s.slice(0, a);
            }
            r.exports = t;
          } }), Co = te({ "src/language-js/pragma.js"(e, r) {
            "use strict";
            ne();
            var { parseWithComments: t, strip: s, extract: a, print: n } = od(), { normalizeEndOfLine: u } = Jn(), i = ld();
            function l(h) {
              let g = i(h);
              g && (h = h.slice(g.length + 1));
              let c = a(h), { pragmas: f, comments: F } = t(c);
              return { shebang: g, text: h, pragmas: f, comments: F };
            }
            function p(h) {
              let g = Object.keys(l(h).pragmas);
              return g.includes("prettier") || g.includes("format");
            }
            function y(h) {
              let { shebang: g, text: c, pragmas: f, comments: F } = l(h), _ = s(c), w = n({ pragmas: Object.assign({ format: "" }, f), comments: F.trimStart() });
              return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
            }
            r.exports = { hasPragma: p, insertPragma: y };
          } }), cd = te({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
            "use strict";
            ne();
            var t = Pt();
            function s(a) {
              return t(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
            }
            r.exports = s;
          } }), Eo = te({ "src/language-js/comments.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h } = Ue(), { getFunctionParameters: g, isPrettierIgnoreComment: c, isJsxNode: f, hasFlowShorthandAnnotationComment: F, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: E, getCallArguments: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isLineComment: $, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: C, locEnd: o } = ut(), d = Pt(), v = cd();
            function S(De) {
              return [H, Fe, Q, q, J, L, ie, he, se, ge, we, ke, ce, z, U].some((A) => A(De));
            }
            function b(De) {
              return [R, Fe, V, we, q, J, L, ie, z, Z, fe, ge, Pe, U, X].some((A) => A(De));
            }
            function B(De) {
              return [H, q, J, j, ue, ce, ge, de, K, pe, U, oe].some((A) => A(De));
            }
            function k(De, A) {
              let G = (De.body || De.properties).find((re) => {
                let { type: ye } = re;
                return ye !== "EmptyStatement";
              });
              G ? i(G, A) : p(De, A);
            }
            function M(De, A) {
              De.type === "BlockStatement" ? k(De, A) : i(De, A);
            }
            function R(De) {
              let { comment: A, followingNode: G } = De;
              return G && v(A) ? (i(G, A), true) : false;
            }
            function q(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye)
                return false;
              if (n(Ce, A, o) === ")")
                return l(G, A), true;
              if (G === re.consequent && ye === re.alternate) {
                if (G.type === "BlockStatement")
                  l(G, A);
                else {
                  let ve = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
                  ve && ze ? p(G, A, m) : p(re, A);
                }
                return true;
              }
              return ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "IfStatement" ? (M(ye.consequent, A), true) : re.consequent === ye ? (i(ye, A), true) : false;
            }
            function J(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye ? false : n(Ce, A, o) === ")" ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : re.body === ye ? (i(ye, A), true) : false;
            }
            function L(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye ? false : re.type === "CatchClause" && G ? (l(G, A), true) : ye.type === "BlockStatement" ? (k(ye, A), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A), true) : ye.type === "CatchClause" ? (M(ye.body, A), true) : false;
            }
            function Q(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              return I(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A), true) : false;
            }
            function V(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De, Be = G && !u(Ce, o(G), C(A));
              return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye ? (i(ye, A), true) : false;
            }
            function j(De) {
              let { comment: A, precedingNode: G, enclosingNode: re } = De;
              return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A), true) : false;
            }
            var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
            function ie(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              if (Y.has(re == null ? void 0 : re.type)) {
                if (h(re.decorators) && !(ye && ye.type === "Decorator"))
                  return l(t(re.decorators), A), true;
                if (re.body && ye === re.body)
                  return k(re.body, A), true;
                if (ye) {
                  if (re.superClass && ye === re.superClass && G && (G === re.id || G === re.typeParameters))
                    return l(G, A), true;
                  for (let Ce of ["implements", "extends", "mixins"])
                    if (re[Ce] && ye === re[Ce][0])
                      return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce), true;
                }
              }
              return false;
            }
            var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
            function ce(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
              return re && G && n(ye, A, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n(ye, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
            }
            var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
            function K(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
              return n(ye, A, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
            }
            function de(De) {
              let { comment: A, enclosingNode: G, text: re } = De;
              if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
                return false;
              let ye = y(re, A, o);
              return ye !== false && re.slice(ye, ye + 2) === "=>" ? (p(G, A), true) : false;
            }
            function ue(De) {
              let { comment: A, enclosingNode: G, text: re } = De;
              return n(re, A, o) !== ")" ? false : G && (le(G) && g(G).length === 0 || E(G) && N(G).length === 0) ? (p(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p(G.value, A), true) : false;
            }
            function Fe(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le(re) && n(Ce, A, o) === ")")
                return l(G, A), true;
              if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
                let Be = (() => {
                  let ve = g(re);
                  if (ve.length > 0)
                    return a(Ce, o(t(ve)));
                  let ze = a(Ce, o(re.id));
                  return ze !== false && a(Ce, ze + 1);
                })();
                if (C(A) > Be)
                  return k(ye, A), true;
              }
              return false;
            }
            function z(De) {
              let { comment: A, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
            }
            function U(De) {
              let { comment: A, enclosingNode: G } = De;
              return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
            }
            function Z(De) {
              let { comment: A, precedingNode: G, enclosingNode: re } = De;
              return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), true) : false;
            }
            function se(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c(A) && (ye.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c(A) && (ye.types[0].prettierIgnore = true, A.unignore = true), false);
            }
            function fe(De) {
              let { comment: A, enclosingNode: G } = De;
              return P(G) ? (i(G, A), true) : false;
            }
            function ge(De) {
              let { comment: A, enclosingNode: G, followingNode: re, ast: ye, isLastComment: Ce } = De;
              return ye && ye.body && ye.body.length === 0 ? (Ce ? p(ye, A) : i(ye, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h(G.directives) ? (Ce ? p(G, A) : i(G, A), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A), true) : false;
            }
            function he(De) {
              let { comment: A, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
            }
            function we(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, text: ye } = De;
              if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier")
                return i(re, A), true;
              let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
              return (Ce || Be) && s(ye, o(A)) ? (l(G, A), true) : false;
            }
            function ke(De) {
              let { comment: A, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
            }
            var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
            function Pe(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              return Re.has(G == null ? void 0 : G.type) && re && (Ne.has(re.type) || d(A)) ? (i(re, A), true) : false;
            }
            function oe(De) {
              let { comment: A, enclosingNode: G, followingNode: re, text: ye } = De;
              return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye, A, o) === ";" ? (l(G, A), true) : false;
            }
            function H(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              if (c(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint)
                return G.prettierIgnore = true, A.unignore = true, true;
            }
            function pe(De) {
              let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i(ye.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
            }
            function X(De) {
              let { comment: A, enclosingNode: G, followingNode: re } = De;
              return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $(A) ? k(re, A) : p(G, A), true);
            }
            function le(De) {
              return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
            }
            function Ae(De, A) {
              if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !h(De.value.typeParameters) && De.value.body)
                return [...De.decorators || [], De.key, De.value.body];
            }
            function Ee(De) {
              let A = De.getValue(), G = De.getParentNode(), re = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
              return (A && (f(A) || F(A) || x(G) && re(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
            }
            r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
          } }), qt = te({ "src/language-js/needs-parens.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), s = Kn(), { getFunctionParameters: a, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: y, shouldFlatten: h, getPrecedence: g, isCallExpression: c, isMemberExpression: f, isObjectProperty: F, isTSTypeExpression: _ } = Ke();
            function w(D, T) {
              let m = D.getParentNode();
              if (!m)
                return false;
              let C = D.getName(), o = D.getNode();
              if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D))
                return true;
              if (E(o))
                return false;
              if (T.parser !== "flow" && u(D.getValue()))
                return true;
              if (o.type === "Identifier") {
                if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement")
                  return true;
                if (o.name === "let") {
                  var d;
                  let S = (d = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d === void 0 ? void 0 : d.left;
                  if (S && y(S, (b) => b === o))
                    return true;
                }
                if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
                  let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                  if (b && y(b, (B) => B === o))
                    return true;
                }
                return false;
              }
              if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
                var v;
                let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
                if (S && y(S, (b) => b === o))
                  return true;
              }
              switch (m.type) {
                case "ParenthesizedExpression":
                  return false;
                case "ClassDeclaration":
                case "ClassExpression": {
                  if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                    return true;
                  break;
                }
                case "ExportDefaultDeclaration":
                  return $(D, T) || o.type === "SequenceExpression";
                case "Decorator": {
                  if (C === "expression") {
                    if (f(o) && o.computed)
                      return true;
                    let S = false, b = false, B = o;
                    for (; B; )
                      switch (B.type) {
                        case "MemberExpression":
                          b = true, B = B.object;
                          break;
                        case "CallExpression":
                          if (b || S)
                            return T.parser !== "typescript";
                          S = true, B = B.callee;
                          break;
                        case "Identifier":
                          return false;
                        case "TaggedTemplateExpression":
                          return T.parser !== "typescript";
                        default:
                          return true;
                      }
                    return true;
                  }
                  break;
                }
                case "ArrowFunctionExpression": {
                  if (C === "body" && o.type !== "SequenceExpression" && y(o, (S) => S.type === "ObjectExpression"))
                    return true;
                  break;
                }
              }
              switch (o.type) {
                case "UpdateExpression":
                  if (m.type === "UnaryExpression")
                    return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
                case "UnaryExpression":
                  switch (m.type) {
                    case "UnaryExpression":
                      return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "TaggedTemplateExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "BinaryExpression":
                      return C === "left" && m.operator === "**";
                    case "TSNonNullExpression":
                      return true;
                    default:
                      return false;
                  }
                case "BinaryExpression": {
                  if (m.type === "UpdateExpression" || o.operator === "in" && N(D))
                    return true;
                  if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                    let S = D.getParentNode(1);
                    if (S.type === "BinaryExpression" && S.operator === "|>")
                      return true;
                  }
                }
                case "TSTypeAssertion":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "LogicalExpression":
                  switch (m.type) {
                    case "TSSatisfiesExpression":
                    case "TSAsExpression":
                      return !_(o);
                    case "ConditionalExpression":
                      return _(o);
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ClassExpression":
                    case "ClassDeclaration":
                      return C === "superClass";
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                      return C === "left" && (o.type === "TSTypeAssertion" || _(o));
                    case "LogicalExpression":
                      if (o.type === "LogicalExpression")
                        return m.operator !== o.operator;
                    case "BinaryExpression": {
                      let { operator: S, type: b } = o;
                      if (!S && b !== "TSTypeAssertion")
                        return true;
                      let B = g(S), k = m.operator, M = g(k);
                      return M > B || C === "right" && M === B || M === B && !h(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p(k);
                    }
                    default:
                      return false;
                  }
                case "SequenceExpression":
                  switch (m.type) {
                    case "ReturnStatement":
                      return false;
                    case "ForStatement":
                      return false;
                    case "ExpressionStatement":
                      return C !== "expression";
                    case "ArrowFunctionExpression":
                      return C !== "body";
                    default:
                      return true;
                  }
                case "YieldExpression":
                  if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression")
                    return true;
                case "AwaitExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ConditionalExpression":
                      return C === "test";
                    case "BinaryExpression":
                      return !(!o.argument && m.operator === "|>");
                    default:
                      return false;
                  }
                case "TSConditionalType":
                case "TSFunctionType":
                case "TSConstructorType":
                  if (C === "extendsType" && m.type === "TSConditionalType") {
                    if (o.type === "TSConditionalType")
                      return true;
                    let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                    if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
                      return true;
                  }
                  if (C === "checkType" && m.type === "TSConditionalType")
                    return true;
                case "TSUnionType":
                case "TSIntersectionType":
                  if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
                    return true;
                case "TSInferType":
                  if (o.type === "TSInferType" && m.type === "TSRestType")
                    return false;
                case "TSTypeOperator":
                  return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
                case "TSTypeQuery":
                  return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
                case "TypeofTypeAnnotation":
                  return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C === "elementType" && m.type === "ArrayTypeAnnotation";
                case "ArrayTypeAnnotation":
                  return m.type === "NullableTypeAnnotation";
                case "IntersectionTypeAnnotation":
                case "UnionTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "NullableTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "FunctionTypeAnnotation": {
                  let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
                  return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
                }
                case "OptionalIndexedAccessType":
                  return C === "objectType" && m.type === "IndexedAccessType";
                case "StringLiteral":
                case "NumericLiteral":
                case "Literal":
                  if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                    let S = D.getParentNode(1);
                    return S.type === "Program" || S.type === "BlockStatement";
                  }
                  return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
                case "AssignmentExpression": {
                  let S = D.getParentNode(1);
                  return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
                }
                case "ConditionalExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ConditionalExpression":
                      return C === "test";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    default:
                      return false;
                  }
                case "FunctionExpression":
                  switch (m.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "TaggedTemplateExpression":
                      return true;
                    default:
                      return false;
                  }
                case "ArrowFunctionExpression":
                  switch (m.type) {
                    case "BinaryExpression":
                      return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion":
                      return true;
                    case "ConditionalExpression":
                      return C === "test";
                    default:
                      return false;
                  }
                case "ClassExpression":
                  if (s(o.decorators))
                    return true;
                  switch (m.type) {
                    case "NewExpression":
                      return C === "callee";
                    default:
                      return false;
                  }
                case "OptionalMemberExpression":
                case "OptionalCallExpression": {
                  let S = D.getParentNode(1);
                  if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m)
                    return true;
                }
                case "CallExpression":
                case "MemberExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                  if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                    let S = o;
                    for (; S; )
                      switch (S.type) {
                        case "CallExpression":
                        case "OptionalCallExpression":
                          return true;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "BindExpression":
                          S = S.object;
                          break;
                        case "TaggedTemplateExpression":
                          S = S.tag;
                          break;
                        case "TSNonNullExpression":
                          S = S.expression;
                          break;
                        default:
                          return false;
                      }
                  }
                  return false;
                case "BindExpression":
                  return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f(m);
                case "NGPipeExpression":
                  return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
                case "JSXFragment":
                case "JSXElement":
                  return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !F(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
                case "TypeAnnotation":
                  return C === "returnType" && m.type === "ArrowFunctionExpression" && x(o);
              }
              return false;
            }
            function E(D) {
              return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
            }
            function N(D) {
              let T = 0, m = D.getValue();
              for (; m; ) {
                let C = D.getParentNode(T++);
                if (C && C.type === "ForStatement" && C.init === m)
                  return true;
                m = C;
              }
              return false;
            }
            function x(D) {
              return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }
            function I(D) {
              switch (D.type) {
                case "ObjectExpression":
                  return true;
                default:
                  return false;
              }
            }
            function P(D) {
              let T = D.getValue(), m = D.getParentNode(), C = D.getName();
              switch (m.type) {
                case "NGPipeExpression":
                  if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C)
                    return D.callParent(P);
                  break;
                case "ObjectProperty":
                  if (C === "value") {
                    let o = D.getParentNode(1);
                    return t(o.properties) === m;
                  }
                  break;
                case "BinaryExpression":
                case "LogicalExpression":
                  if (C === "right")
                    return D.callParent(P);
                  break;
                case "ConditionalExpression":
                  if (C === "alternate")
                    return D.callParent(P);
                  break;
                case "UnaryExpression":
                  if (m.prefix)
                    return D.callParent(P);
                  break;
              }
              return false;
            }
            function $(D, T) {
              let m = D.getValue(), C = D.getParentNode();
              return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $(o, T), ...n(D, m));
            }
            r.exports = w;
          } }), Fo = te({ "src/language-js/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            function t(s, a) {
              switch (a.parser) {
                case "json":
                case "json5":
                case "json-stringify":
                case "__js_expression":
                case "__vue_expression":
                case "__vue_ts_expression":
                  return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
                default:
                  return s;
              }
            }
            r.exports = t;
          } }), pd = te({ "src/language-js/print/html-binding.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, line: s, group: a, softline: n, indent: u } } = qe();
            function i(p, y, h) {
              let g = p.getValue();
              if (y.__onHtmlBindingRoot && p.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
                if (y.__isVueForBindingLeft)
                  return p.call((c) => {
                    let f = t([",", s], c.map(h, "params")), { params: F } = c.getValue();
                    return F.length === 1 ? f : ["(", u([n, a(f)]), n, ")"];
                  }, "program", "body", 0);
                if (y.__isVueBindings)
                  return p.call((c) => t([",", s], c.map(h, "params")), "program", "body", 0);
              }
            }
            function l(p) {
              switch (p.type) {
                case "MemberExpression":
                  switch (p.property.type) {
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                      return l(p.object);
                  }
                  return false;
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
          } }), ru = te({ "src/language-js/print/binaryish.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t } = et(), { getLast: s } = Ue(), { builders: { join: a, line: n, softline: u, group: i, indent: l, align: p, indentIfBreak: y }, utils: { cleanDoc: h, getDocParts: g, isConcat: c } } = qe(), { hasLeadingOwnLineComment: f, isBinaryish: F, isJsxNode: _, shouldFlatten: w, hasComment: E, CommentCheckFlags: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $ } = Ke(), D = 0;
            function T(o, d, v) {
              let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $(d) && S.operator === "|>", R = m(o, v, d, false, k);
              if (k)
                return R;
              if (M)
                return i(R);
              if (x(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed)
                return i([l([u, ...R]), u]);
              let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F(S.left) && w(S.operator, S.left.operator);
              if (q || C(S) && !L || !C(S) && J)
                return i(R);
              if (R.length === 0)
                return "";
              let Q = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R.slice(0, V === -1 ? 1 : V + 1), Y = R.slice(j.length, Q ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
              if (!Q)
                return ee;
              let ce = s(R);
              return i([ee, y(ce, { groupId: ie })]);
            }
            function m(o, d, v, S, b) {
              let B = o.getValue();
              if (!F(B))
                return [i(d())];
              let k = [];
              w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, d, v, true, b), "left") : k.push(i(d("left")));
              let M = C(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f(v.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a([n, ": "], o.map(d, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
              if (M)
                L = [q, " ", d("right"), J];
              else {
                let ie = $(v) && q === "|>" ? o.call((ee) => m(ee, d, v, true, b), "right") : d("right");
                L = [R ? n : "", q, R ? " " : n, ie, J];
              }
              let Q = o.getParentNode(), V = E(B.left, N.Trailing | N.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
              if (k.push(R ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && E(B)) {
                let Y = h(t(o, k, v));
                return c(Y) || Y.type === "fill" ? g(Y) : [Y];
              }
              return k;
            }
            function C(o) {
              return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
            }
            r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
          } }), fd = te({ "src/language-js/print/angular.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, line: s, group: a } } = qe(), { hasNode: n, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = ru();
            function p(g, c, f) {
              let F = g.getValue();
              if (F.type.startsWith("NG"))
                switch (F.type) {
                  case "NGRoot":
                    return [f("node"), u(F.node) ? " //" + i(F.node)[0].value.trimEnd() : ""];
                  case "NGPipeExpression":
                    return l(g, c, f);
                  case "NGChainedExpression":
                    return a(t([";", s], g.map((_) => h(_) ? f() : ["(", f(), ")"], "expressions")));
                  case "NGEmptyExpression":
                    return "";
                  case "NGQuotedExpression":
                    return [F.prefix, ": ", F.value.trim()];
                  case "NGMicrosyntax":
                    return g.map((_, w) => [w === 0 ? "" : y(_.getValue(), w, F) ? " " : [";", s], f()], "body");
                  case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F.name) ? F.name : JSON.stringify(F.name);
                  case "NGMicrosyntaxExpression":
                    return [f("expression"), F.alias === null ? "" : [" as ", f("alias")]];
                  case "NGMicrosyntaxKeyedExpression": {
                    let _ = g.getName(), w = g.getParentNode(), E = y(F, _, w) || (_ === 1 && (F.key.name === "then" || F.key.name === "else") || _ === 2 && F.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
                    return [f("key"), E ? " " : ": ", f("expression")];
                  }
                  case "NGMicrosyntaxLet":
                    return ["let ", f("key"), F.value === null ? "" : [" = ", f("value")]];
                  case "NGMicrosyntaxAs":
                    return [f("key"), " as ", f("alias")];
                  default:
                    throw new Error(`Unknown Angular node type: ${JSON.stringify(F.type)}.`);
                }
            }
            function y(g, c, f) {
              return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
            }
            function h(g) {
              return n(g.getValue(), (c) => {
                switch (c.type) {
                  case void 0:
                    return false;
                  case "CallExpression":
                  case "OptionalCallExpression":
                  case "AssignmentExpression":
                    return true;
                }
              });
            }
            r.exports = { printAngular: p };
          } }), Dd = te({ "src/language-js/print/jsx.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t, printDanglingComments: s, printCommentsSeparately: a } = et(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, fill: h, ifBreak: g, lineSuffixBoundary: c, join: f }, utils: { willBreak: F } } = qe(), { getLast: _, getPreferredQuote: w } = Ue(), { isJsxNode: E, rawText: N, isCallExpression: x, isStringLiteral: I, isBinaryish: P, hasComment: $, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke(), m = qt(), { willPrintOwnComments: C } = Eo(), o = (U) => U === "" || U === n || U === u || U === i;
            function d(U, Z, se) {
              let fe = U.getValue();
              if (fe.type === "JSXElement" && de(fe))
                return [se("openingElement"), se("closingElement")];
              let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
              if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
                return [ge, ...U.map(se, "children"), he];
              fe.children = fe.children.map((A) => Fe(A) ? { type: "JSXText", value: " ", raw: " " } : A);
              let we = fe.children.some(E), ke = fe.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = F(ge) || we || Re || ke, Pe = U.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe ? " " : g([oe, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U, Z, se, H, pe), le = fe.children.some((A) => ue(A));
              for (let A = X.length - 2; A >= 0; A--) {
                let G = X[A] === "" && X[A + 1] === "", re = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
                re && le || G || ye || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);
              }
              for (; X.length > 0 && o(_(X)); )
                X.pop();
              for (; X.length > 1 && o(X[0]) && o(X[1]); )
                X.shift(), X.shift();
              let Ae = [];
              for (let [A, G] of X.entries()) {
                if (G === H) {
                  if (A === 1 && X[A - 1] === "") {
                    if (X.length === 2) {
                      Ae.push(oe);
                      continue;
                    }
                    Ae.push([oe, u]);
                    continue;
                  } else if (A === X.length - 1) {
                    Ae.push(oe);
                    continue;
                  } else if (X[A - 1] === "" && X[A - 2] === u) {
                    Ae.push(oe);
                    continue;
                  }
                }
                Ae.push(G), F(G) && (Ne = true);
              }
              let Ee = le ? h(Ae) : l(Ae, { shouldBreak: true });
              if (Pe)
                return Ee;
              let De = l([ge, p([u, Ee]), u, he]);
              return Ne ? De : y([l([ge, ...X, he]), De]);
            }
            function v(U, Z, se, fe, ge) {
              let he = [];
              return U.each((we, ke, Re) => {
                let Ne = we.getValue();
                if (Ne.type === "JSXText") {
                  let Pe = N(Ne);
                  if (ue(Ne)) {
                    let oe = Pe.split(ce);
                    if (oe[0] === "") {
                      if (he.push(""), oe.shift(), /\n/.test(oe[0])) {
                        let pe = Re[ke + 1];
                        he.push(b(ge, oe[1], Ne, pe));
                      } else
                        he.push(fe);
                      oe.shift();
                    }
                    let H;
                    if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0)
                      return;
                    for (let [pe, X] of oe.entries())
                      pe % 2 === 1 ? he.push(n) : he.push(X);
                    if (H !== void 0)
                      if (/\n/.test(H)) {
                        let pe = Re[ke + 1];
                        he.push(b(ge, _(he), Ne, pe));
                      } else
                        he.push(fe);
                    else {
                      let pe = Re[ke + 1];
                      he.push(S(ge, _(he), Ne, pe));
                    }
                  } else
                    /\n/.test(Pe) ? Pe.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
                } else {
                  let Pe = se();
                  he.push(Pe);
                  let oe = Re[ke + 1];
                  if (oe && ue(oe)) {
                    let pe = K(N(oe)).split(ce)[0];
                    he.push(S(ge, pe, Ne, oe));
                  } else
                    he.push(u);
                }
              }, "children"), he;
            }
            function S(U, Z, se, fe) {
              return U ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
            }
            function b(U, Z, se, fe) {
              return U ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
            }
            function B(U, Z, se) {
              let fe = U.getParentNode();
              if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
                return Z;
              let he = U.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x, (ke) => ke.type === "JSXExpressionContainer"), we = m(U, se);
              return l([we ? "" : g("("), p([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
            }
            function k(U, Z, se) {
              let fe = U.getValue(), ge = [];
              if (ge.push(se("name")), fe.value) {
                let he;
                if (I(fe.value)) {
                  let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe } = w(ke, Z.jsxSingleQuote ? "'" : '"');
                  ke = ke.replace(Pe, Re);
                  let { leading: oe, trailing: H } = U.call(() => a(U, Z), "value");
                  he = [oe, Ne, ke, Ne, H];
                } else
                  he = se("value");
                ge.push("=", he);
              }
              return ge;
            }
            function M(U, Z, se) {
              let fe = U.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || E(we) && (he.type === "ConditionalExpression" || P(he)));
              return ge(fe.expression, U.getParentNode(0)) ? l(["{", se("expression"), c, "}"]) : l(["{", p([i, se("expression")]), i, c, "}"]);
            }
            function R(U, Z, se) {
              let fe = U.getValue(), ge = fe.name && $(fe.name) || fe.typeParameters && $(fe.typeParameters);
              if (fe.selfClosing && fe.attributes.length === 0 && !ge)
                return ["<", se("name"), se("typeParameters"), " />"];
              if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$(fe.attributes[0]))
                return l(["<", se("name"), se("typeParameters"), " ", ...U.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
              let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;
              return l(["<", se("name"), se("typeParameters"), p(U.map(() => [we, se()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: he });
            }
            function q(U, Z, se) {
              return U.selfClosing ? [n, "/>"] : J(U, Z, se) ? [">"] : [i, ">"];
            }
            function J(U, Z, se) {
              let fe = U.attributes.length > 0 && $(_(U.attributes), D.Trailing);
              return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;
            }
            function L(U, Z, se) {
              let fe = U.getValue(), ge = [];
              ge.push("</");
              let he = se("name");
              return $(fe.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
            }
            function Q(U, Z) {
              let se = U.getValue(), fe = $(se), ge = $(se, D.Line), he = se.type === "JSXOpeningFragment";
              return [he ? "<" : "</", p([ge ? u : fe && !he ? " " : "", s(U, Z, true)]), ge ? u : "", ">"];
            }
            function V(U, Z, se) {
              let fe = t(U, d(U, Z, se), Z);
              return B(U, fe, Z);
            }
            function j(U, Z) {
              let se = U.getValue(), fe = $(se, D.Line);
              return [s(U, Z, !fe), fe ? u : ""];
            }
            function Y(U, Z, se) {
              let fe = U.getValue();
              return ["{", U.call((ge) => {
                let he = ["...", se()], we = ge.getValue();
                return !$(we) || !C(ge) ? he : [p([i, t(ge, he, Z)]), i];
              }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
            }
            function ie(U, Z, se) {
              let fe = U.getValue();
              if (fe.type.startsWith("JSX"))
                switch (fe.type) {
                  case "JSXAttribute":
                    return k(U, Z, se);
                  case "JSXIdentifier":
                    return String(fe.name);
                  case "JSXNamespacedName":
                    return f(":", [se("namespace"), se("name")]);
                  case "JSXMemberExpression":
                    return f(".", [se("object"), se("property")]);
                  case "JSXSpreadAttribute":
                    return Y(U, Z, se);
                  case "JSXSpreadChild":
                    return Y(U, Z, se);
                  case "JSXExpressionContainer":
                    return M(U, Z, se);
                  case "JSXFragment":
                  case "JSXElement":
                    return V(U, Z, se);
                  case "JSXOpeningElement":
                    return R(U, Z, se);
                  case "JSXClosingElement":
                    return L(U, Z, se);
                  case "JSXOpeningFragment":
                  case "JSXClosingFragment":
                    return Q(U, Z);
                  case "JSXEmptyExpression":
                    return j(U, Z);
                  case "JSXText":
                    throw new Error("JSXText should be handled by JSXElement");
                  default:
                    throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
                }
            }
            var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U) => U.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
            function de(U) {
              if (U.children.length === 0)
                return true;
              if (U.children.length > 1)
                return false;
              let Z = U.children[0];
              return Z.type === "JSXText" && !ue(Z);
            }
            function ue(U) {
              return U.type === "JSXText" && (W.test(N(U)) || !/\n/.test(N(U)));
            }
            function Fe(U) {
              return U.type === "JSXExpressionContainer" && I(U.expression) && U.expression.value === " " && !$(U.expression);
            }
            function z(U) {
              let Z = U.getValue(), se = U.getParentNode();
              if (!se || !Z || !E(Z) || !E(se))
                return false;
              let fe = se.children.indexOf(Z), ge = null;
              for (let he = fe; he > 0; he--) {
                let we = se.children[he - 1];
                if (!(we.type === "JSXText" && !ue(we))) {
                  ge = we;
                  break;
                }
              }
              return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
            }
            r.exports = { hasJsxIgnoreComment: z, printJsx: ie };
          } }), ct = te({ "src/language-js/print/misc.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, join: a, line: n } } = qe(), { isFlowAnnotationComment: u } = Ke();
            function i(_) {
              let w = _.getValue();
              return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
            }
            function l(_) {
              return _.getValue().definite || _.match(void 0, (w, E) => E === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
            }
            function p(_, w, E) {
              let N = _.getValue();
              return N.typeArguments ? E("typeArguments") : N.typeParameters ? E("typeParameters") : "";
            }
            function y(_, w, E) {
              let N = _.getValue();
              if (!N.typeAnnotation)
                return "";
              let x = _.getParentNode(), I = x.type === "DeclareFunction" && x.id === N;
              return u(w.originalText, N.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I ? "" : ": ", E("typeAnnotation")];
            }
            function h(_, w, E) {
              return ["::", E("callee")];
            }
            function g(_, w, E) {
              let N = _.getValue();
              return t(N.modifiers) ? [a(" ", _.map(E, "modifiers")), " "] : "";
            }
            function c(_, w, E) {
              return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w] : s([n, w]);
            }
            function f(_, w, E) {
              return ["...", E("argument"), y(_, w, E)];
            }
            function F(_, w) {
              let E = _.slice(1, -1);
              if (E.includes('"') || E.includes("'"))
                return _;
              let N = w.singleQuote ? "'" : '"';
              return N + E + N;
            }
            r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: h, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: f, adjustClause: c, printDirective: F };
          } }), er = te({ "src/language-js/print/array.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: n, group: u, indent: i, ifBreak: l, fill: p } } = qe(), { getLast: y, hasNewline: h } = Ue(), { shouldPrintComma: g, hasComment: c, CommentCheckFlags: f, isNextLineEmpty: F, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke(), { locStart: E } = ut(), { printOptionalToken: N, printTypeAnnotation: x } = ct();
            function I(T, m, C) {
              let o = T.getValue(), d = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
              if (o.elements.length === 0)
                c(o, f.Dangling) ? d.push(u([v, t(T, m), a, S])) : d.push(v, S);
              else {
                let b = y(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
                  let j = L && L.type;
                  if (j !== "ArrayExpression" && j !== "ObjectExpression")
                    return false;
                  let Y = V[Q + 1];
                  if (Y && j !== Y.type)
                    return false;
                  let ie = j === "ArrayExpression" ? "elements" : "properties";
                  return L[ie] && L[ie].length > 1;
                }), q = P(o, m), J = B ? k ? "," : g(m) ? q ? l(",", "", { groupId: M }) : l(",") : "" : "";
                d.push(u([v, i([a, q ? D(T, m, C, J) : [$(T, m, "elements", C), J], t(T, m, true)]), a, S], { shouldBreak: R, id: M }));
              }
              return d.push(N(T), x(T, m, C)), d;
            }
            function P(T, m) {
              return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f.Trailing | f.Line, (o) => !h(m.originalText, E(o), { backwards: true })));
            }
            function $(T, m, C, o) {
              let d = [], v = [];
              return T.each((S) => {
                d.push(v, u(o())), v = [",", s], S.getValue() && F(S.getValue(), m) && v.push(a);
              }, C), d;
            }
            function D(T, m, C, o) {
              let d = [];
              return T.each((v, S, b) => {
                let B = S === b.length - 1;
                d.push([C(), B ? o : ","]), B || d.push(F(v.getValue(), m) ? [n, n] : c(b[S + 1], f.Leading | f.Line) ? n : s);
              }, "elements"), p(d);
            }
            r.exports = { printArray: I, printArrayItems: $, isConciselyPrintedArray: P };
          } }), Ao = te({ "src/language-js/print/call-arguments.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ue(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: y, shouldPrintComma: h, getCallArguments: g, iterateCallArgumentsPath: c, isNextLineEmpty: f, isCallExpression: F, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: E } = Ke(), { builders: { line: N, hardline: x, softline: I, group: P, indent: $, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Qt(), { isConciselyPrintedArray: d } = er();
            function v(q, J, L) {
              let Q = q.getValue(), V = Q.type === "ImportExpression", j = g(Q);
              if (j.length === 0)
                return ["(", t(q, J, true), ")"];
              if (k(j))
                return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
              let Y = false, ie = false, ee = j.length - 1, ce = [];
              c(q, (z, U) => {
                let Z = z.getNode(), se = [L()];
                U === ee || (f(Z, J) ? (U === 0 && (ie = true), Y = true, se.push(",", x, x)) : se.push(",", N)), ce.push(se);
              });
              let W = !(V || Q.callee && Q.callee.type === "Import") && h(J, "all") ? "," : "";
              function K() {
                return P(["(", $([N, ...ce]), W, N, ")"], { shouldBreak: true });
              }
              if (Y || q.getParentNode().type !== "Decorator" && l(j))
                return K();
              let de = B(j), ue = b(j, J);
              if (de || ue) {
                if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C))
                  return K();
                let z = [];
                try {
                  q.try(() => {
                    c(q, (U, Z) => {
                      de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x : N, ie ? x : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
                    });
                  });
                } catch (U) {
                  if (U instanceof o)
                    return K();
                  throw U;
                }
                return [ce.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K()])];
              }
              let Fe = ["(", $([I, ...ce]), T(W), I, ")"];
              return y(q) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
            }
            function S(q) {
              let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || E(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (F(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
            }
            function b(q, J) {
              let L = s(q), Q = a(q);
              return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d(L, J));
            }
            function B(q) {
              if (q.length !== 2)
                return false;
              let [J, L] = q;
              return J.type === "ModuleExpression" && R(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
            }
            function k(q) {
              return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
            }
            function M(q) {
              return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
            }
            function R(q) {
              return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
            }
            r.exports = v;
          } }), So = te({ "src/language-js/print/member.js"(e, r) {
            "use strict";
            ne();
            var { builders: { softline: t, group: s, indent: a, label: n } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: p } = ct();
            function y(g, c, f) {
              let F = g.getValue(), _ = g.getParentNode(), w, E = 0;
              do
                w = g.getParentNode(E), E++;
              while (w && (i(w) || w.type === "TSNonNullExpression"));
              let N = f("object"), x = h(g, c, f), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || F.computed || F.object.type === "Identifier" && F.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F.object) && F.object.arguments.length > 0 || F.object.type === "TSNonNullExpression" && l(F.object.expression) && F.object.expression.arguments.length > 0 || N.label === "member-chain");
              return n(N.label === "member-chain" ? "member-chain" : "member", [N, I ? x : s(a([t, x]))]);
            }
            function h(g, c, f) {
              let F = f("property"), _ = g.getValue(), w = p(g);
              return _.computed ? !_.property || u(_.property) ? [w, "[", F, "]"] : s([w, "[", a([t, F]), t, "]"]) : [w, ".", F];
            }
            r.exports = { printMemberExpression: y, printMemberLookup: h };
          } }), md = te({ "src/language-js/print/member-chain.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n } = Ue(), u = qt(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: y, isMemberish: h, isNumericLiteral: g, isSimpleCallArgument: c, hasComment: f, CommentCheckFlags: F, isNextLineEmpty: _ } = Ke(), { locEnd: w } = ut(), { builders: { join: E, hardline: N, group: x, indent: I, conditionalGroup: P, breakParent: $, label: D }, utils: { willBreak: T } } = qe(), m = Ao(), { printMemberLookup: C } = So(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: v } = ct();
            function S(b, B, k) {
              let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q = [];
              function J(Ne) {
                let { originalText: Pe } = B, oe = n(Pe, Ne, w);
                return Pe.charAt(oe) === ")" ? oe !== false && a(Pe, oe + 1) : _(Ne, B);
              }
              function L(Ne) {
                let Pe = Ne.getValue();
                i(Pe) && (h(Pe.callee) || i(Pe.callee)) ? (q.unshift({ node: Pe, printed: [t(Ne, [o(Ne), d(Ne, B, k), m(Ne, B, k)], B), J(Pe) ? N : ""] }), Ne.call((oe) => L(oe), "callee")) : h(Pe) ? (q.unshift({ node: Pe, needsParens: u(Ne, B), printed: t(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe) => L(oe), "object")) : Pe.type === "TSNonNullExpression" ? (q.unshift({ node: Pe, printed: t(Ne, "!", B) }), Ne.call((oe) => L(oe), "expression")) : q.unshift({ node: Pe, printed: k() });
              }
              let Q = b.getValue();
              q.unshift({ node: Q, printed: [o(b), d(b, B, k), m(b, B, k)] }), Q.callee && b.call((Ne) => L(Ne), "callee");
              let V = [], j = [q[0]], Y = 1;
              for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g(q[Y].node.property)); ++Y)
                j.push(q[Y]);
              if (!i(q[0].node))
                for (; Y + 1 < q.length && (h(q[Y].node) && h(q[Y + 1].node)); ++Y)
                  j.push(q[Y]);
              V.push(j), j = [];
              let ie = false;
              for (; Y < q.length; ++Y) {
                if (ie && h(q[Y].node)) {
                  if (q[Y].node.computed && g(q[Y].node.property)) {
                    j.push(q[Y]);
                    continue;
                  }
                  V.push(j), j = [], ie = false;
                }
                (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie = true), j.push(q[Y]), f(q[Y].node, F.Trailing) && (V.push(j), j = [], ie = false);
              }
              j.length > 0 && V.push(j);
              function ee(Ne) {
                return /^[A-Z]|^[$_]+$/.test(Ne);
              }
              function ce(Ne) {
                return Ne.length <= B.tabWidth;
              }
              function W(Ne) {
                let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;
                if (Ne[0].length === 1) {
                  let H = Ne[0][0].node;
                  return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R && ce(H.name) || Pe);
                }
                let oe = s(Ne[0]).node;
                return l(oe) && oe.property.type === "Identifier" && (ee(oe.property.name) || Pe);
              }
              let K = V.length >= 2 && !f(V[1][0].node) && W(V);
              function de(Ne) {
                let Pe = Ne.map((oe) => oe.printed);
                return Ne.length > 0 && s(Ne).needsParens ? ["(", ...Pe, ")"] : Pe;
              }
              function ue(Ne) {
                return Ne.length === 0 ? "" : I(x([N, E(N, Ne.map(de))]));
              }
              let Fe = V.map(de), z = Fe, U = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f(Ne.node, F.Leading)) || Z.slice(0, -1).some((Ne) => f(Ne.node, F.Trailing)) || V[U] && f(V[U][0].node, F.Leading);
              if (V.length <= U && !se)
                return y(b) ? z : x(z);
              let fe = s(V[K ? 1 : 0]).node, ge = !i(fe) && J(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N : "", ue(V.slice(K ? 2 : 1))], we = q.map((Ne) => {
                let { node: Pe } = Ne;
                return Pe;
              }).filter(i);
              function ke() {
                let Ne = s(s(V)).node, Pe = s(Fe);
                return i(Ne) && T(Pe) && we.slice(0, -1).some((oe) => oe.arguments.some(p));
              }
              let Re;
              return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe) => c(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x(he) : Re = [T(z) || ge ? $ : "", P([z, he])], D("member-chain", Re);
            }
            r.exports = S;
          } }), xo = te({ "src/language-js/print/call-expression.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, group: s } } = qe(), a = qt(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: y, isTestCall: h, iterateCallArgumentsPath: g } = Ke(), c = md(), f = Ao(), { printOptionalToken: F, printFunctionTypeParameters: _ } = ct();
            function w(N, x, I) {
              let P = N.getValue(), $ = N.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = F(N), C = n(P);
              if (C.length > 0 && (!T && !D && E(P, $) || C.length === 1 && y(C[0], x.originalText) || !D && h(P, $))) {
                let v = [];
                return g(N, () => {
                  v.push(I());
                }), [D ? "new " : "", I("callee"), m, _(N, x, I), "(", t(", ", v), ")"];
              }
              let o = (x.parser === "babel" || x.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
              if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N.call((v) => a(v, x), "callee"))
                return c(N, x, I);
              let d = [D ? "new " : "", T ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N, x, I), f(N, x, I)];
              return T || i(P.callee) ? s(d) : d;
            }
            function E(N, x) {
              if (N.callee.type !== "Identifier")
                return false;
              if (N.callee.name === "require")
                return true;
              if (N.callee.name === "define") {
                let I = n(N);
                return x.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p(I[0]) && I[1].type === "ArrayExpression");
              }
              return false;
            }
            r.exports = { printCallExpression: w };
          } }), tr = te({ "src/language-js/print/assignment.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t, getStringWidth: s } = Ue(), { builders: { line: a, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: y, canBreak: h } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: c, isStringLiteral: f, isLiteral: F, isNumericLiteral: _, isCallExpression: w, isMemberExpression: E, getCallArguments: N, rawText: x, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $ } = Ke(), { shouldInlineLogicalExpression: D } = ru(), { printCallExpression: T } = xo();
            function m(W, K, de, ue, Fe, z) {
              let U = d(W, K, de, ue, z), Z = de(z, { assignmentLayout: U });
              switch (U) {
                case "break-after-operator":
                  return n([n(ue), Fe, n(u([a, Z]))]);
                case "never-break-after-operator":
                  return n([n(ue), Fe, " ", Z]);
                case "fluid": {
                  let se = Symbol("assignment");
                  return n([n(ue), Fe, n(u(a), { id: se }), l, i(Z, { groupId: se })]);
                }
                case "break-lhs":
                  return n([ue, Fe, " ", n(Z)]);
                case "chain":
                  return [n(ue), Fe, a, Z];
                case "chain-tail":
                  return [n(ue), Fe, u([a, Z])];
                case "chain-tail-arrow-chain":
                  return [n(ue), Fe, Z];
                case "only-left":
                  return ue;
              }
            }
            function C(W, K, de) {
              let ue = W.getValue();
              return m(W, K, de, de("left"), [" ", ue.operator], "right");
            }
            function o(W, K, de) {
              return m(W, K, de, de("id"), " =", "init");
            }
            function d(W, K, de, ue, Fe) {
              let z = W.getValue(), U = z[Fe];
              if (!U)
                return "only-left";
              let Z = !b(U);
              if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration"))
                return Z ? U.type === "ArrowFunctionExpression" && U.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
              if (!Z && b(U.right) || g(K.originalText, U))
                return "break-after-operator";
              if (U.type === "CallExpression" && U.callee.name === "require" || K.parser === "json5" || K.parser === "json")
                return "never-break-after-operator";
              if (S(z) || k(z) || q(z) || J(z) && h(ue))
                return "break-lhs";
              let ge = ie(z, ue, K);
              return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U.type === "TemplateLiteral" || U.type === "TaggedTemplateExpression" || U.type === "BooleanLiteral" || _(U) || U.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
            }
            function v(W, K, de, ue) {
              let Fe = W.getValue();
              if (c(Fe) && !D(Fe))
                return true;
              switch (Fe.type) {
                case "StringLiteralTypeAnnotation":
                case "SequenceExpression":
                  return true;
                case "ConditionalExpression": {
                  let { test: Z } = Fe;
                  return c(Z) && !D(Z);
                }
                case "ClassExpression":
                  return t(Fe.decorators);
              }
              if (ue)
                return false;
              let z = Fe, U = [];
              for (; ; )
                if (z.type === "UnaryExpression")
                  z = z.argument, U.push("argument");
                else if (z.type === "TSNonNullExpression")
                  z = z.expression, U.push("expression");
                else
                  break;
              return !!(f(z) || W.call(() => V(W, K, de), ...U));
            }
            function S(W) {
              if (B(W)) {
                let K = W.left || W.id;
                return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
              }
              return false;
            }
            function b(W) {
              return W.type === "AssignmentExpression";
            }
            function B(W) {
              return b(W) || W.type === "VariableDeclarator";
            }
            function k(W) {
              let K = M(W);
              if (t(K)) {
                let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                if (K.length > 1 && K.some((ue) => ue[de] || ue.default))
                  return true;
              }
              return false;
            }
            function M(W) {
              return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function R(W) {
              return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
            }
            function q(W) {
              if (W.type !== "VariableDeclarator")
                return false;
              let { typeAnnotation: K } = W.id;
              if (!K || !K.typeAnnotation)
                return false;
              let de = L(K.typeAnnotation);
              return t(de) && de.length > 1 && de.some((ue) => t(L(ue)) || ue.type === "TSConditionalType");
            }
            function J(W) {
              return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
            }
            function L(W) {
              return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function Q(W) {
              return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
            }
            function V(W, K, de) {
              let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
              if (Fe.type === "TSNonNullExpression")
                return W.call(z, "expression");
              if (w(Fe)) {
                if (T(W, K, de).label === "member-chain")
                  return false;
                let Z = N(Fe);
                return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
              }
              return E(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
            }
            var j = 0.25;
            function Y(W, K) {
              let { printWidth: de } = K;
              if (I(W))
                return false;
              let ue = de * j;
              if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument))
                return true;
              let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
              return Fe ? Fe.length <= ue : f(W) ? x(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : F(W);
            }
            function ie(W, K, de) {
              if (!$(W))
                return false;
              K = p(K);
              let ue = 3;
              return typeof K == "string" && s(K) < de.tabWidth + ue;
            }
            function ee(W, K) {
              let de = ce(W);
              if (t(de)) {
                if (de.length > 1)
                  return true;
                if (de.length === 1) {
                  let Fe = de[0];
                  if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation")
                    return true;
                }
                let ue = W.typeParameters ? "typeParameters" : "typeArguments";
                if (y(K(ue)))
                  return true;
              }
              return false;
            }
            function ce(W) {
              return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
            }
            r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J };
          } }), Lr = te({ "src/language-js/print/function-parameters.js"(e, r) {
            "use strict";
            ne();
            var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: y, willBreak: h } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: c, isSimpleType: f, isTestCall: F, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: E, hasRestParameter: N, shouldPrintComma: x, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $ } = ut(), { ArgExpansionBailout: D } = Qt(), { printFunctionTypeParameters: T } = ct();
            function m(v, S, b, B, k) {
              let M = v.getValue(), R = g(M), q = k ? T(v, b, S) : "";
              if (R.length === 0)
                return [q, "(", s(v, b, true, (ie) => t(b.originalText, ie, $) === ")"), ")"];
              let J = v.getParentNode(), L = F(J), Q = C(M), V = [];
              if (c(v, (ie, ee) => {
                let ce = ee === R.length - 1;
                ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q ? V.push(" ") : P(R[ee], b) ? V.push(n, n) : V.push(a));
              }), B) {
                if (h(q) || h(V))
                  throw new D();
                return i([y(q), "(", y(V), ")"]);
              }
              let j = R.every((ie) => !ie.decorators);
              return Q && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (E(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N(M) && x(b, "all") ? "," : ""), u, ")"];
            }
            function C(v) {
              if (!v)
                return false;
              let S = g(v);
              if (S.length !== 1)
                return false;
              let [b] = S;
              return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
            }
            function o(v) {
              let S;
              return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
            }
            function d(v, S) {
              let b = o(v);
              if (!b)
                return false;
              let B = v.typeParameters && v.typeParameters.params;
              if (B) {
                if (B.length > 1)
                  return false;
                if (B.length === 1) {
                  let k = B[0];
                  if (k.constraint || k.default)
                    return false;
                }
              }
              return g(v).length === 1 && (w(b) || h(S));
            }
            r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: d };
          } }), Or = te({ "src/language-js/print/type-annotation.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue(), { builders: { group: n, join: u, line: i, softline: l, indent: p, align: y, ifBreak: h } } = qe(), g = qt(), { locStart: c } = ut(), { isSimpleType: f, isObjectType: F, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: E } = Ke(), { printAssignment: N } = tr(), { printFunctionParameters: x, shouldGroupFunctionParameters: I } = Lr(), { printArrayItems: P } = er();
            function $(b) {
              if (f(b) || F(b))
                return true;
              if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
                let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
                if (b.types.length - 1 === B && k)
                  return true;
              }
              return false;
            }
            function D(b, B, k) {
              let M = B.semi ? ";" : "", R = b.getValue(), q = [];
              return q.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q.push(": ", k("supertype")), R.impltype && q.push(" = ", k("impltype")), q.push(M), q;
            }
            function T(b, B, k) {
              let M = B.semi ? ";" : "", R = b.getValue(), q = [];
              R.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
              let J = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
              return [N(b, B, k, q, " =", J), M];
            }
            function m(b, B, k) {
              let M = b.getValue(), R = b.map(k, "types"), q = [], J = false;
              for (let L = 0; L < R.length; ++L)
                L === 0 ? q.push(R[L]) : F(M.types[L - 1]) && F(M.types[L]) ? q.push([" & ", J ? p(R[L]) : R[L]]) : !F(M.types[L - 1]) && !F(M.types[L]) ? q.push(p([" &", i, R[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? p(R[L]) : R[L]));
              return n(q);
            }
            function C(b, B, k) {
              let M = b.getValue(), R = b.getParentNode(), q = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J = $(M), L = b.map((j) => {
                let Y = k();
                return J || (Y = y(2, Y)), t(j, Y, B);
              }, "types");
              if (J)
                return u(" | ", L);
              let Q = q && !_(B.originalText, M), V = [h([Q ? i : "", "| "]), u([i, "| "], L)];
              return g(b, B) ? n([p(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n([p([h(["(", l]), V]), l, h(")")]) : n(q ? p(V) : V);
            }
            function o(b, B, k) {
              let M = b.getValue(), R = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c(q) === c(M) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
              w(q) && (Q = true, V = true), j && R.push("(");
              let Y = x(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
              return R.push(ee ? n(Y) : Y), ie && R.push(ie), j && R.push(")"), n(R);
            }
            function d(b, B, k) {
              let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q = M[R], J = a(q), L = J ? l : "";
              return n(["[", p([L, P(b, B, R, k)]), h(J && E(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
            }
            function v(b, B, k) {
              let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
              return [k("objectType"), R, k("indexType"), "]"];
            }
            function S(b, B, k) {
              let M = b.getValue();
              return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
            }
            r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: d, printIndexedAccessType: v, shouldHugType: $, printJSDocType: S };
          } }), jr = te({ "src/language-js/print/type-parameters.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p } } = qe(), { isTestCall: y, hasComment: h, CommentCheckFlags: g, isTSXFile: c, shouldPrintComma: f, getFunctionParameters: F, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke(), { createGroupIdMapper: E } = Ue(), { shouldHugType: N } = Or(), { isArrowFunctionVariableDeclarator: x } = tr(), I = E("typeParameters");
            function P(T, m, C, o) {
              let d = T.getValue();
              if (!d[o])
                return "";
              if (!Array.isArray(d[o]))
                return C(o);
              let v = T.getNode(2), S = v && y(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x);
              if (d[o].length === 0 || !b && (S || d[o].length === 1 && (d[o][0].type === "NullableTypeAnnotation" || N(d[o][0]))))
                return ["<", s(", ", T.map(C, o)), $(T, m), ">"];
              let k = d.type === "TSTypeParameterInstantiation" ? "" : F(d).length === 1 && c(m) && !d[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m, "all") ? p(",") : "";
              return i(["<", l([u, s([",", a], T.map(C, o))]), k, u, ">"], { id: I(d) });
            }
            function $(T, m) {
              let C = T.getValue();
              if (!h(C, g.Dangling))
                return "";
              let o = !h(C, g.Line), d = t(T, m, o);
              return o ? d : [d, n];
            }
            function D(T, m, C) {
              let o = T.getValue(), d = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v = T.getParentNode();
              return v.type === "TSMappedType" ? (v.readonly && d.push(w(v.readonly, "readonly"), " "), d.push("[", C("name")), o.constraint && d.push(" in ", C("constraint")), v.nameType && d.push(" as ", T.callParent(() => C("nameType"))), d.push("]"), d) : (o.variance && d.push(C("variance")), o.in && d.push("in "), o.out && d.push("out "), d.push(C("name")), o.bound && d.push(": ", C("bound")), o.constraint && d.push(" extends ", C("constraint")), o.default && d.push(" = ", C("default")), d);
            }
            r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
          } }), rr = te({ "src/language-js/print/property.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t } = et(), { printString: s, printNumber: a } = Ue(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke(), { printAssignment: y } = tr(), h = /* @__PURE__ */ new WeakMap();
            function g(f, F, _) {
              let w = f.getNode();
              if (w.computed)
                return ["[", _("key"), "]"];
              let E = f.getParentNode(), { key: N } = w;
              if (F.quoteProps === "consistent" && !h.has(E)) {
                let x = (E.properties || E.body || E.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, F));
                h.set(E, x);
              }
              if ((N.type === "Identifier" || n(N) && u(a(p(N))) && String(N.value) === a(p(N)) && !(F.parser === "typescript" || F.parser === "babel-ts")) && (F.parser === "json" || F.quoteProps === "consistent" && h.get(E))) {
                let x = s(JSON.stringify(N.type === "Identifier" ? N.name : N.value.toString()), F);
                return f.call((I) => t(I, x, F), "key");
              }
              return l(w, F) && (F.quoteProps === "as-needed" || F.quoteProps === "consistent" && !h.get(E)) ? f.call((x) => t(x, /^\d/.test(N.value) ? a(N.value) : N.value, F), "key") : _("key");
            }
            function c(f, F, _) {
              return f.getValue().shorthand ? _("value") : y(f, F, _, g(f, F, _), ":", "value");
            }
            r.exports = { printProperty: c, printPropertyKey: g };
          } }), qr = te({ "src/language-js/print/function.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), n = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: l, group: p, indent: y, ifBreak: h, hardline: g, join: c, indentIfBreak: f }, utils: { removeLines: F, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Qt(), { getFunctionParameters: E, hasLeadingOwnLineComment: N, isFlowAnnotationComment: x, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: d, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke(), { locEnd: M } = ut(), { printFunctionParameters: R, shouldGroupFunctionParameters: q } = Lr(), { printPropertyKey: J } = rr(), { printFunctionTypeParameters: L } = ct();
            function Q(U, Z, se, fe) {
              let ge = U.getValue(), he = false;
              if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
                let Pe = U.getParentNode();
                S(Pe) && b(Pe).length > 1 && (he = true);
              }
              let we = [];
              ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
              let ke = R(U, Z, se, he), Re = K(U, Z, se), Ne = q(ge, Re);
              return we.push(L(U, se, Z), p([Ne ? p(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
            }
            function V(U, Z, se) {
              let fe = U.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
              return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J(U, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U, Z, se)) : he.type === "FunctionExpression" ? we.push(U.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
            }
            function j(U, Z, se) {
              let fe = U.getNode(), ge = R(U, se, Z), he = K(U, se, Z), we = q(fe, he), ke = [L(U, Z, se), p([we ? p(ge) : ge, he])];
              return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
            }
            function Y(U, Z, se, fe) {
              let ge = U.getValue(), he = [];
              if (ge.async && he.push("async "), W(U, Z))
                he.push(se(["params", 0]));
              else {
                let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U, se, Z);
                if (ke) {
                  if (_(Re))
                    throw new w();
                  Re = p(F(Re));
                }
                he.push(p([R(U, se, Z, ke, true), Re]));
              }
              let we = s(U, Z, true, (ke) => {
                let Re = u(Z.originalText, ke, M);
                return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
              });
              return we && he.push(" ", we), he;
            }
            function ie(U, Z, se, fe, ge, he) {
              let we = U.getName(), ke = U.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe = Re && Pe || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
              return he.body.type === "SequenceExpression" && (ge = p(["(", y([l, ge]), l, ")"])), p([p(y([Re || Ne ? l : "", p(c([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe }), " =>", f(Pe ? y([i, ge]) : [" ", ge], { groupId: H }), Re ? h(l, "", { groupId: H }) : ""]);
            }
            function ee(U, Z, se, fe) {
              let ge = U.getValue(), he = [], we = [], ke = false;
              if (function H() {
                let pe = Y(U, Z, se, fe);
                if (he.length === 0)
                  he.push(pe);
                else {
                  let { leading: X, trailing: le } = a(U, Z);
                  he.push([X, pe]), we.unshift(le);
                }
                ke = ke || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U.call(H, "body"));
              }(), he.length > 1)
                return ie(U, fe, he, ke, we, ge);
              let Re = he;
              if (Re.push(" =>"), !N(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
                return p([...Re, " ", we]);
              if (ge.body.type === "SequenceExpression")
                return p([...Re, p([" (", y([l, we]), l, ")"])]);
              let Ne = (fe && fe.expandLastArg || U.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe = fe && fe.expandLastArg && $(Z, "all"), oe = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
              return p([...Re, p([y([i, oe ? h("", "(") : "", we, oe ? h("", ")") : ""]), Ne ? [h(Pe ? "," : ""), l] : ""])]);
            }
            function ce(U) {
              let Z = E(U);
              return Z.length === 1 && !U.typeParameters && !C(U, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;
            }
            function W(U, Z) {
              if (Z.arrowParens === "always")
                return false;
              if (Z.arrowParens === "avoid") {
                let se = U.getValue();
                return ce(se);
              }
              return false;
            }
            function K(U, Z, se) {
              let fe = U.getValue(), ge = Z("returnType");
              if (fe.returnType && x(se.originalText, fe.returnType))
                return [" /*: ", ge, " */"];
              let he = [ge];
              return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
            }
            function de(U, Z, se) {
              let fe = U.getValue(), ge = Z.semi ? ";" : "", he = [];
              fe.argument && (z(Z, fe.argument) ? he.push([" (", y([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p([h(" (", " "), y([l, se("argument")]), l, h(")")])) : he.push(" ", se("argument")));
              let we = o(fe), ke = n(we), Re = ke && m(ke);
              return Re && he.push(ge), C(fe, d.Dangling) && he.push(" ", s(U, Z, true)), Re || he.push(ge), he;
            }
            function ue(U, Z, se) {
              return ["return", de(U, Z, se)];
            }
            function Fe(U, Z, se) {
              return ["throw", de(U, Z, se)];
            }
            function z(U, Z) {
              if (N(U.originalText, Z))
                return true;
              if (B(Z)) {
                let se = Z, fe;
                for (; fe = k(se); )
                  if (se = fe, N(U.originalText, se))
                    return true;
              }
              return false;
            }
            r.exports = { printFunction: Q, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
          } }), nu = te({ "src/language-js/print/decorators.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t, hasNewline: s } = Ue(), { builders: { line: a, hardline: n, join: u, breakParent: i, group: l } } = qe(), { locStart: p, locEnd: y } = ut(), { getParentExportDeclaration: h } = Ke();
            function g(w, E, N) {
              let x = w.getValue();
              return l([u(a, w.map(N, "decorators")), F(x, E) ? n : a]);
            }
            function c(w, E, N) {
              return [u(n, w.map(N, "declaration", "decorators")), n];
            }
            function f(w, E, N) {
              let x = w.getValue(), { decorators: I } = x;
              if (!t(I) || _(w.getParentNode()))
                return;
              let P = x.type === "ClassExpression" || x.type === "ClassDeclaration" || F(x, E);
              return [h(w) ? n : P ? i : "", u(a, w.map(N, "decorators")), a];
            }
            function F(w, E) {
              return w.decorators.some((N) => s(E.originalText, y(N)));
            }
            function _(w) {
              if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration")
                return false;
              let E = w.declaration && w.declaration.decorators;
              return t(E) && p(w) === p(E[0]);
            }
            r.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
          } }), nr = te({ "src/language-js/print/class.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue(), { printComments: a, printDanglingComments: n } = et(), { builders: { join: u, line: i, hardline: l, softline: p, group: y, indent: h, ifBreak: g } } = qe(), { hasComment: c, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: F } = jr(), { printMethod: _ } = qr(), { printOptionalToken: w, printTypeAnnotation: E, printDefiniteToken: N } = ct(), { printPropertyKey: x } = rr(), { printAssignment: I } = tr(), { printClassMemberDecorators: P } = nu();
            function $(b, B, k) {
              let M = b.getValue(), R = [];
              M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
              let q = M.id && c(M.id, f.Trailing) || M.typeParameters && c(M.typeParameters, f.Trailing) || M.superClass && c(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), J = [], L = [];
              if (M.id && J.push(" ", k("id")), J.push(k("typeParameters")), M.superClass) {
                let Q = [d(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a(j, Q, B)], "superClass");
                q ? L.push(i, y(V)) : L.push(" ", V);
              } else
                L.push(o(b, B, k, "extends"));
              if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
                let Q;
                C(M) ? Q = [...J, h(L)] : Q = h([...J, L]), R.push(y(Q, { id: D(M) }));
              } else
                R.push(...J, ...L);
              return R.push(" ", k("body")), R;
            }
            var D = s("heritageGroup");
            function T(b) {
              return g(l, "", { groupId: D(b) });
            }
            function m(b) {
              return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
            }
            function C(b) {
              return b.typeParameters && !c(b.typeParameters, f.Trailing | f.Line) && !m(b);
            }
            function o(b, B, k, M) {
              let R = b.getValue();
              if (!t(R[M]))
                return "";
              let q = n(b, B, true, (J) => {
                let { marker: L } = J;
                return L === M;
              });
              return [C(R) ? g(" ", i, { groupId: F(R.typeParameters) }) : i, q, q && l, M, y(h([i, u([",", i], b.map(k, M))]))];
            }
            function d(b, B, k) {
              let M = k("superClass");
              return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h([p, M]), p, ")"], M)) : M;
            }
            function v(b, B, k) {
              let M = b.getValue(), R = [];
              return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
            }
            function S(b, B, k) {
              let M = b.getValue(), R = [], q = B.semi ? ";" : "";
              return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x(b, B, k), w(b), N(b), E(b, B, k)), [I(b, B, k, R, " =", "value"), q];
            }
            r.exports = { printClass: $, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
          } }), bo = te({ "src/language-js/print/interface.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { join: s, line: a, group: n, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: y } = Ke(), { getTypeParametersGroupId: h } = jr(), { printTypeScriptModifiers: g } = ct();
            function c(f, F, _) {
              let w = f.getValue(), E = [];
              w.declare && E.push("declare "), w.type === "TSInterfaceDeclaration" && E.push(w.abstract ? "abstract " : "", g(f, F, _)), E.push("interface");
              let N = [], x = [];
              w.type !== "InterfaceTypeAnnotation" && N.push(" ", _("id"), _("typeParameters"));
              let I = w.typeParameters && !l(w.typeParameters, y.Trailing | y.Line);
              return t(w.extends) && x.push(I ? i(" ", a, { groupId: h(w.typeParameters) }) : a, "extends ", (w.extends.length === 1 ? p : u)(s([",", a], f.map(_, "extends")))), w.id && l(w.id, y.Trailing) || t(w.extends) ? I ? E.push(n([...N, u(x)])) : E.push(n(u([...N, ...x]))) : E.push(...N, ...x), E.push(" ", _("body")), n(E);
            }
            r.exports = { printInterface: c };
          } }), To = te({ "src/language-js/print/module.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { softline: s, group: a, indent: n, join: u, line: i, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: y } = et(), { hasComment: h, CommentCheckFlags: g, shouldPrintComma: c, needsHardlineAfterDanglingComment: f, isStringLiteral: F, rawText: _ } = Ke(), { locStart: w, hasSameLoc: E } = ut(), { hasDecoratorsBeforeExport: N, printDecoratorsBeforeExport: x } = nu();
            function I(S, b, B) {
              let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q } = k;
              return R.push("import"), q && q !== "value" && R.push(" ", q), R.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R;
            }
            function P(S, b, B) {
              let k = S.getValue(), M = [];
              N(k) && M.push(x(S, b, B));
              let { type: R, exportKind: q, declaration: J } = k;
              return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), h(k, g.Dangling) && (M.push(" ", y(S, b, true)), f(k) && M.push(p)), J ? M.push(" ", B("declaration")) : M.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
            }
            function $(S, b, B) {
              let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q, exported: J } = k;
              return R.push("export"), q === "type" && R.push(" type"), R.push(" *"), J && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
            }
            function D(S, b) {
              if (!b.semi)
                return false;
              let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
              if (!k)
                return true;
              let { type: R } = k;
              return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
            }
            function T(S, b, B) {
              let k = S.getValue();
              if (!k.source)
                return "";
              let M = [];
              return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
            }
            function m(S, b, B) {
              let k = S.getValue();
              if (C(k, b))
                return "";
              let M = [" "];
              if (t(k.specifiers)) {
                let R = [], q = [];
                S.each(() => {
                  let J = S.getValue().type;
                  if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                    R.push(B());
                  else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                    q.push(B());
                  else
                    throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
                }, "specifiers"), M.push(u(", ", R)), q.length > 0 && (R.length > 0 && M.push(", "), q.length > 1 || R.length > 0 || k.specifiers.some((L) => h(L)) ? M.push(a(["{", n([b.bracketSpacing ? i : s, u([",", i], q)]), l(c(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
              } else
                M.push("{}");
              return M;
            }
            function C(S, b) {
              let { type: B, importKind: k, source: M, specifiers: R } = S;
              return B !== "ImportDeclaration" || t(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
            }
            function o(S, b, B) {
              let k = S.getNode();
              return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
            }
            function d(S, b, B) {
              let k = S.getNode(), { type: M } = k, R = [], q = M === "ImportSpecifier" ? k.importKind : k.exportKind;
              q && q !== "value" && R.push(q, " ");
              let J = M.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie = "";
              return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R.push(Y, Y && ie ? " as " : "", ie), R;
            }
            function v(S) {
              if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
                return false;
              let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
              if (b.type !== B.type || !E(b, B))
                return false;
              if (F(b))
                return b.value === B.value && _(b) === _(B);
              switch (b.type) {
                case "Identifier":
                  return b.name === B.name;
                default:
                  return false;
              }
            }
            r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $, printModuleSpecifier: d };
          } }), uu = te({ "src/language-js/print/object.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: n, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: y, hasNewline: h, isNonEmptyArray: g } = Ue(), { shouldPrintComma: c, hasComment: f, getComments: F, CommentCheckFlags: _, isNextLineEmpty: w } = Ke(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Lr(), { shouldHugType: $ } = Or(), { printHardlineAfterHeritage: D } = nr();
            function T(m, C, o) {
              let d = C.semi ? ";" : "", v = m.getValue(), S;
              v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
              let b = v.type === "ObjectTypeAnnotation", B = [S];
              b && B.push("indexers", "callProperties", "internalSlots");
              let k = B.map((W) => v[W][0]).sort((W, K) => E(W) - E(K))[0], M = m.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m.getName() === "body", q = v.type === "TSInterfaceBody" || R || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && y(C.originalText, E(v), E(k)), J = R ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(d, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q = v.exact ? "|}" : "}", V = [];
              for (let W of B)
                m.each((K) => {
                  let de = K.getValue();
                  V.push({ node: de, printed: o(), loc: E(de) });
                }, W);
              B.length > 1 && V.sort((W, K) => W.loc - K.loc);
              let j = [], Y = V.map((W) => {
                let K = [...j, n(W.printed)];
                return j = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
              });
              if (v.inexact) {
                let W;
                if (f(v, _.Dangling)) {
                  let K = f(v, _.Line);
                  W = [t(m, C, true), K || h(C.originalText, N(p(F(v)))) ? l : s, "..."];
                } else
                  W = ["..."];
                Y.push([...j, ...W]);
              }
              let ie = p(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f(ie, _.PrettierIgnore)), ce;
              if (Y.length === 0) {
                if (!f(v, _.Dangling))
                  return [L, Q, I(m, C, o)];
                ce = n([L, t(m, C), a, Q, x(m), I(m, C, o)]);
              } else
                ce = [R && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee && (J !== "," || c(C)) ? J : ""), C.bracketSpacing ? s : a, Q, x(m), I(m, C, o)];
              return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m.match($, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n(ce, { shouldBreak: q });
            }
            r.exports = { printObject: T };
          } }), dd = te({ "src/language-js/print/flow.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { printDanglingComments: s } = et(), { printString: a, printNumber: n } = Ue(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h, isGetterOrSetter: g, rawText: c, shouldPrintComma: f } = Ke(), { locStart: F, locEnd: _ } = ut(), { replaceTextEndOfLine: w } = Yt(), { printClass: E } = nr(), { printOpaqueType: N, printTypeAlias: x, printIntersectionType: I, printUnionType: P, printFunctionType: $, printTupleType: D, printIndexedAccessType: T } = Or(), { printInterface: m } = bo(), { printTypeParameter: C, printTypeParameters: o } = jr(), { printExportDeclaration: d, printExportAllDeclaration: v } = To(), { printArrayItems: S } = er(), { printObject: b } = uu(), { printPropertyKey: B } = rr(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct();
            function q(L, Q, V) {
              let j = L.getValue(), Y = Q.semi ? ";" : "", ie = [];
              switch (j.type) {
                case "DeclareClass":
                  return J(L, E(L, Q, V));
                case "DeclareFunction":
                  return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
                case "DeclareModule":
                  return J(L, ["module ", V("id"), " ", V("body")]);
                case "DeclareModuleExports":
                  return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
                case "DeclareVariable":
                  return J(L, ["var ", V("id"), Y]);
                case "DeclareOpaqueType":
                  return J(L, N(L, Q, V));
                case "DeclareInterface":
                  return J(L, m(L, Q, V));
                case "DeclareTypeAlias":
                  return J(L, x(L, Q, V));
                case "DeclareExportDeclaration":
                  return J(L, d(L, Q, V));
                case "DeclareExportAllDeclaration":
                  return J(L, v(L, Q, V));
                case "OpaqueType":
                  return N(L, Q, V);
                case "TypeAlias":
                  return x(L, Q, V);
                case "IntersectionTypeAnnotation":
                  return I(L, Q, V);
                case "UnionTypeAnnotation":
                  return P(L, Q, V);
                case "FunctionTypeAnnotation":
                  return $(L, Q, V);
                case "TupleTypeAnnotation":
                  return D(L, Q, V);
                case "GenericTypeAnnotation":
                  return [V("id"), o(L, Q, V, "typeParameters")];
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                  return T(L, Q, V);
                case "TypeAnnotation":
                  return V("typeAnnotation");
                case "TypeParameter":
                  return C(L, Q, V);
                case "TypeofTypeAnnotation":
                  return ["typeof ", V("argument")];
                case "ExistsTypeAnnotation":
                  return "*";
                case "EmptyTypeAnnotation":
                  return "empty";
                case "MixedTypeAnnotation":
                  return "mixed";
                case "ArrayTypeAnnotation":
                  return [V("elementType"), "[]"];
                case "BooleanLiteralTypeAnnotation":
                  return String(j.value);
                case "EnumDeclaration":
                  return ["enum ", V("id"), " ", V("body")];
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody": {
                  if (j.type === "EnumSymbolBody" || j.explicitType) {
                    let ee = null;
                    switch (j.type) {
                      case "EnumBooleanBody":
                        ee = "boolean";
                        break;
                      case "EnumNumberBody":
                        ee = "number";
                        break;
                      case "EnumStringBody":
                        ee = "string";
                        break;
                      case "EnumSymbolBody":
                        ee = "symbol";
                        break;
                    }
                    ie.push("of ", ee, " ");
                  }
                  if (j.members.length === 0 && !j.hasUnknownMembers)
                    ie.push(l(["{", s(L, Q), i, "}"]));
                  else {
                    let ee = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
                    ie.push(l(["{", p([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q, true), u, "}"]));
                  }
                  return ie;
                }
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                  return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
                case "EnumDefaultedMember":
                  return V("id");
                case "FunctionTypeParam": {
                  let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
                  return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
                }
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                  return m(L, Q, V);
                case "ClassImplements":
                case "InterfaceExtends":
                  return [V("id"), V("typeParameters")];
                case "NullableTypeAnnotation":
                  return ["?", V("typeAnnotation")];
                case "Variance": {
                  let { kind: ee } = j;
                  return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
                }
                case "ObjectTypeCallProperty":
                  return j.static && ie.push("static "), ie.push(V("value")), ie;
                case "ObjectTypeIndexer":
                  return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
                case "ObjectTypeProperty": {
                  let ee = "";
                  return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), h(j) ? "" : ": ", V("value")];
                }
                case "ObjectTypeAnnotation":
                  return b(L, Q, V);
                case "ObjectTypeInternalSlot":
                  return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
                case "ObjectTypeSpreadProperty":
                  return R(L, Q, V);
                case "QualifiedTypeofIdentifier":
                case "QualifiedTypeIdentifier":
                  return [V("qualification"), ".", V("id")];
                case "StringLiteralTypeAnnotation":
                  return w(a(c(j), Q));
                case "NumberLiteralTypeAnnotation":
                  t.strictEqual(typeof j.value, "number");
                case "BigIntLiteralTypeAnnotation":
                  return j.extra ? n(j.extra.raw) : n(j.raw);
                case "TypeCastExpression":
                  return ["(", V("expression"), M(L, Q, V), ")"];
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation": {
                  let ee = o(L, Q, V, "params");
                  if (Q.parser === "flow") {
                    let ce = F(j), W = _(j), K = Q.originalText.lastIndexOf("/*", ce), de = Q.originalText.indexOf("*/", W);
                    if (K !== -1 && de !== -1) {
                      let ue = Q.originalText.slice(K + 2, de).trim();
                      if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/"))
                        return ["/*:: ", ee, " */"];
                    }
                  }
                  return ee;
                }
                case "InferredPredicate":
                  return "%checks";
                case "DeclaredPredicate":
                  return ["%checks(", V("value"), ")"];
                case "AnyTypeAnnotation":
                  return "any";
                case "BooleanTypeAnnotation":
                  return "boolean";
                case "BigIntTypeAnnotation":
                  return "bigint";
                case "NullLiteralTypeAnnotation":
                  return "null";
                case "NumberTypeAnnotation":
                  return "number";
                case "SymbolTypeAnnotation":
                  return "symbol";
                case "StringTypeAnnotation":
                  return "string";
                case "VoidTypeAnnotation":
                  return "void";
                case "ThisTypeAnnotation":
                  return "this";
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                  throw new Error("unprintable type: " + JSON.stringify(j.type));
              }
            }
            function J(L, Q) {
              let V = y(L);
              return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
            }
            r.exports = { printFlow: q };
          } }), gd = te({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              let { type: a } = s;
              return a.startsWith("TS") && a.endsWith("Keyword");
            }
            r.exports = t;
          } }), Bo = te({ "src/language-js/print/ternary.js"(e, r) {
            "use strict";
            ne();
            var { hasNewlineInRange: t } = Ue(), { isJsxNode: s, getComments: a, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: p } = ut(), y = Pt(), { builders: { line: h, softline: g, group: c, indent: f, align: F, ifBreak: _, dedent: w, breakParent: E } } = qe();
            function N(D) {
              let T = [D];
              for (let m = 0; m < T.length; m++) {
                let C = T[m];
                for (let o of ["test", "consequent", "alternate"]) {
                  let d = C[o];
                  if (s(d))
                    return true;
                  d.type === "ConditionalExpression" && T.push(d);
                }
              }
              return false;
            }
            function x(D, T, m) {
              let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
              return v.type === C.type && v[d] === C ? F(2, S) : S;
            }
            var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
            function P(D) {
              let T = D.getValue();
              if (T.type !== "ConditionalExpression")
                return false;
              let m, C = T;
              for (let o = 0; !m; o++) {
                let d = D.getParentNode(o);
                if (n(d) && d.callee === C || u(d) && d.object === C || d.type === "TSNonNullExpression" && d.expression === C) {
                  C = d;
                  continue;
                }
                d.type === "NewExpression" && d.callee === C || i(d) && d.expression === C ? (m = D.getParentNode(o + 1), C = d) : m = d;
              }
              return C === T ? false : m[I.get(m.type)] === C;
            }
            function $(D, T, m) {
              let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[d], B = C[v], k = [], M = false, R = D.getParentNode(), q = R.type === C.type && S.some((ue) => R[ue] === C), J = R.type === C.type && !q, L, Q, V = 0;
              do
                Q = L || C, L = D.getParentNode(V), V++;
              while (L && L.type === C.type && S.every((ue) => L[ue] !== Q));
              let j = L || R, Y = Q;
              if (o && (s(C[S[0]]) || s(b) || s(B) || N(Y))) {
                M = true, J = true;
                let ue = (z) => [_("("), f([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
                k.push(" ? ", Fe(b) ? m(d) : ue(m(d)), " : ", B.type === C.type || Fe(B) ? m(v) : ue(m(v)));
              } else {
                let ue = [h, "? ", b.type === C.type ? _("", "(") : "", F(2, m(d)), b.type === C.type ? _("", ")") : "", h, ": ", B.type === C.type ? m(v) : F(2, m(v))];
                k.push(R.type !== C.type || R[v] === C || q ? ue : T.useTabs ? w(f(ue)) : F(Math.max(0, T.tabWidth - 2), ue));
              }
              let ee = [...S.map((ue) => a(C[ue])), a(b), a(B)].flat().some((ue) => y(ue) && t(T.originalText, l(ue), p(ue))), ce = (ue) => R === j ? c(ue, { shouldBreak: ee }) : ee ? [ue, E] : ue, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C) && !R.computed, K = P(D), de = ce([x(D, T, m), J ? k : f(k), o && W && !K ? g : ""]);
              return q || K ? c([f([g, de]), g]) : de;
            }
            r.exports = { printTernary: $ };
          } }), No = te({ "src/language-js/print/statement.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t } } = qe(), s = qt(), { getLeftSidePathName: a, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: y } = Ke(), { shouldPrintParamsWithoutParens: h } = qr();
            function g(x, I, P, $) {
              let D = x.getValue(), T = [], m = D.type === "ClassBody", C = c(D[$]);
              return x.each((o, d, v) => {
                let S = o.getValue();
                if (S.type === "EmptyStatement")
                  return;
                let b = P();
                !I.semi && !m && !i(I, o) && f(o, I) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m && E(S) && N(S, v[d + 1]) && T.push(";"), S !== C && (T.push(t), y(S, I) && T.push(t));
              }, $), T;
            }
            function c(x) {
              for (let I = x.length - 1; I >= 0; I--) {
                let P = x[I];
                if (P.type !== "EmptyStatement")
                  return P;
              }
            }
            function f(x, I) {
              return x.getNode().type !== "ExpressionStatement" ? false : x.call(($) => F($, I), "expression");
            }
            function F(x, I) {
              let P = x.getValue();
              switch (P.type) {
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                case "ArrayExpression":
                case "ArrayPattern":
                case "TemplateLiteral":
                case "TemplateElement":
                case "RegExpLiteral":
                  return true;
                case "ArrowFunctionExpression": {
                  if (!h(x, I))
                    return true;
                  break;
                }
                case "UnaryExpression": {
                  let { prefix: $, operator: D } = P;
                  if ($ && (D === "+" || D === "-"))
                    return true;
                  break;
                }
                case "BindExpression": {
                  if (!P.object)
                    return true;
                  break;
                }
                case "Literal": {
                  if (P.regex)
                    return true;
                  break;
                }
                default:
                  if (u(P))
                    return true;
              }
              return s(x, I) ? true : n(P) ? x.call(($) => F($, I), ...a(x, P)) : false;
            }
            function _(x, I, P) {
              return g(x, I, P, "body");
            }
            function w(x, I, P) {
              return g(x, I, P, "consequent");
            }
            var E = (x) => {
              let { type: I } = x;
              return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
            };
            function N(x, I) {
              let { type: P, name: $ } = x.key;
              if (!x.computed && P === "Identifier" && ($ === "static" || $ === "get" || $ === "set" || $ === "accessor") && !x.value && !x.typeAnnotation)
                return true;
              if (!I || I.static || I.accessibility)
                return false;
              if (!I.computed) {
                let D = I.key && I.key.name;
                if (D === "in" || D === "instanceof")
                  return true;
              }
              if (E(I) && I.variance && !I.static && !I.declare)
                return true;
              switch (I.type) {
                case "ClassProperty":
                case "PropertyDefinition":
                case "TSAbstractPropertyDefinition":
                  return I.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod": {
                  if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                    return false;
                  let T = I.value ? I.value.generator : I.generator;
                  return !!(I.computed || T);
                }
                case "TSIndexSignature":
                  return true;
              }
              return false;
            }
            r.exports = { printBody: _, printSwitchCaseConsequent: w };
          } }), wo = te({ "src/language-js/print/block.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a, indent: n } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: p } = nr(), { printBody: y } = No();
            function h(c, f, F) {
              let _ = c.getValue(), w = [];
              if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
                let N = c.getParentNode();
                w.push(p(N));
              }
              w.push("{");
              let E = g(c, f, F);
              if (E)
                w.push(n([a, E]), a);
              else {
                let N = c.getParentNode(), x = c.getParentNode(1);
                N.type === "ArrowFunctionExpression" || N.type === "FunctionExpression" || N.type === "FunctionDeclaration" || N.type === "ObjectMethod" || N.type === "ClassMethod" || N.type === "ClassPrivateMethod" || N.type === "ForStatement" || N.type === "WhileStatement" || N.type === "DoWhileStatement" || N.type === "DoExpression" || N.type === "CatchClause" && !x.finalizer || N.type === "TSModuleDeclaration" || N.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a);
              }
              return w.push("}"), w;
            }
            function g(c, f, F) {
              let _ = c.getValue(), w = s(_.directives), E = _.body.some((I) => I.type !== "EmptyStatement"), N = u(_, i.Dangling);
              if (!w && !E && !N)
                return "";
              let x = [];
              if (w && c.each((I, P, $) => {
                x.push(F()), (P < $.length - 1 || E || N) && (x.push(a), l(I.getValue(), f) && x.push(a));
              }, "directives"), E && x.push(y(c, f, F)), N && x.push(t(c, f, true)), _.type === "Program") {
                let I = c.getParentNode();
                (!I || I.type !== "ModuleExpression") && x.push(a);
              }
              return x;
            }
            r.exports = { printBlock: h, printBlockBody: g };
          } }), yd = te({ "src/language-js/print/typescript.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, ifBreak: h } } = qe(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f, isCallExpression: F, isMemberExpression: _ } = Ke(), w = gd(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Bo(), { printFunctionParameters: $, shouldGroupFunctionParameters: D } = Lr(), { printTemplateLiteral: T } = jt(), { printArrayItems: m } = er(), { printObject: C } = uu(), { printClassProperty: o, printClassMethod: d } = nr(), { printTypeParameter: v, printTypeParameters: S } = jr(), { printPropertyKey: b } = rr(), { printFunction: B, printMethodInternal: k } = qr(), { printInterface: M } = bo(), { printBlock: R } = wo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = Or();
            function ie(ee, ce, W) {
              let K = ee.getValue();
              if (!K.type.startsWith("TS"))
                return;
              if (w(K))
                return K.type.slice(2, -7).toLowerCase();
              let de = ce.semi ? ";" : "", ue = [];
              switch (K.type) {
                case "TSThisType":
                  return "this";
                case "TSTypeAssertion": {
                  let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U = [h("("), p([i, W("expression")]), i, h(")")];
                  return Fe ? y([[z, W("expression")], [z, l(U, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
                }
                case "TSDeclareFunction":
                  return B(ee, W, ce);
                case "TSExportAssignment":
                  return ["export = ", W("expression"), de];
                case "TSModuleBlock":
                  return R(ee, ce, W);
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                  return C(ee, ce, W);
                case "TSTypeAliasDeclaration":
                  return q(ee, ce, W);
                case "TSQualifiedName":
                  return a(".", [W("left"), W("right")]);
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                  return d(ee, ce, W);
                case "TSAbstractAccessorProperty":
                case "TSAbstractPropertyDefinition":
                  return o(ee, ce, W);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                  return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
                case "TSTemplateLiteralType":
                  return T(ee, W, ce);
                case "TSNamedTupleMember":
                  return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
                case "TSRestType":
                  return ["...", W("typeAnnotation")];
                case "TSOptionalType":
                  return [W("typeAnnotation"), "?"];
                case "TSInterfaceDeclaration":
                  return M(ee, ce, W);
                case "TSClassImplements":
                  return [W("expression"), W("typeParameters")];
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                  return S(ee, ce, W, "params");
                case "TSTypeParameter":
                  return v(ee, ce, W);
                case "TSSatisfiesExpression":
                case "TSAsExpression": {
                  let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
                  ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
                  let z = ee.getParentNode();
                  return F(z) && z.callee === K || _(z) && z.object === K ? l([p([i, ...ue]), i]) : ue;
                }
                case "TSArrayType":
                  return [W("elementType"), "[]"];
                case "TSPropertySignature":
                  return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
                case "TSParameterProperty":
                  return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
                case "TSTypeQuery":
                  return ["typeof ", W("exprName"), W("typeParameters")];
                case "TSIndexSignature": {
                  let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? h(f(ce) ? "," : "") : "", U = l([p([i, a([", ", i], ee.map(W, "parameters"))]), z, i]);
                  return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
                }
                case "TSTypePredicate":
                  return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
                case "TSNonNullExpression":
                  return [W("expression"), "!"];
                case "TSImportType":
                  return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
                case "TSLiteralType":
                  return W("literal");
                case "TSIndexedAccessType":
                  return j(ee, ce, W);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType": {
                  if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
                    let Fe = K.type === "TSConstructorType";
                    ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                  }
                  return ue;
                }
                case "TSTypeOperator":
                  return [K.operator, " ", W("typeAnnotation")];
                case "TSMappedType": {
                  let Fe = s(ce.originalText, E(K), N(K));
                  return l(["{", p([ce.bracketSpacing ? n : i, W("typeParameter"), K.optional ? c(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), h(de)]), t(ee, ce, true), ce.bracketSpacing ? n : i, "}"], { shouldBreak: Fe });
                }
                case "TSMethodSignature": {
                  let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
                  ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x(ee));
                  let z = $(ee, W, ce, false, true), U = K.returnType ? "returnType" : "typeAnnotation", Z = K[U], se = Z ? W(U) : "", fe = D(K, se);
                  return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
                }
                case "TSNamespaceExportDeclaration":
                  return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
                case "TSEnumDeclaration":
                  return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t(ee, ce), i, "}"])) : ue.push(l(["{", p([u, m(ee, ce, "members", W), f(ce, "es5") ? "," : ""]), t(ee, ce, true), u, "}"])), ue;
                case "TSEnumMember":
                  return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
                case "TSImportEqualsDeclaration":
                  return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
                case "TSExternalModuleReference":
                  return ["require(", W("expression"), ")"];
                case "TSModuleDeclaration": {
                  let Fe = ee.getParentNode(), z = g(K.id), U = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
                  if (U)
                    ue.push(".");
                  else {
                    K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
                    let se = ce.originalText.slice(E(K), E(K.id));
                    K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
                  }
                  return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
                }
                case "TSConditionalType":
                  return P(ee, ce, W);
                case "TSInferType":
                  return ["infer", " ", W("typeParameter")];
                case "TSIntersectionType":
                  return J(ee, ce, W);
                case "TSUnionType":
                  return L(ee, ce, W);
                case "TSFunctionType":
                  return Q(ee, ce, W);
                case "TSTupleType":
                  return V(ee, ce, W);
                case "TSTypeReference":
                  return [W("typeName"), S(ee, ce, W, "typeParameters")];
                case "TSTypeAnnotation":
                  return W("typeAnnotation");
                case "TSEmptyBodyFunctionExpression":
                  return k(ee, ce, W);
                case "TSJSDocAllType":
                  return "*";
                case "TSJSDocUnknownType":
                  return "?";
                case "TSJSDocNullableType":
                  return Y(ee, W, "?");
                case "TSJSDocNonNullableType":
                  return Y(ee, W, "!");
                case "TSInstantiationExpression":
                  return [W("expression"), W("typeParameters")];
                default:
                  throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
              }
            }
            r.exports = { printTypescript: ie };
          } }), hd = te({ "src/language-js/print/comment.js"(e, r) {
            "use strict";
            ne();
            var { hasNewline: t } = Ue(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = ut(), p = Pt();
            function y(c, f) {
              let F = c.getValue();
              if (u(F))
                return f.originalText.slice(i(F), l(F)).trimEnd();
              if (p(F)) {
                if (h(F)) {
                  let E = g(F);
                  return F.trailing && !t(f.originalText, i(F), { backwards: true }) ? [a, E] : E;
                }
                let _ = l(F), w = f.originalText.slice(_ - 3, _) === "*-/";
                return ["/*", n(F.value), w ? "*-/" : "*/"];
              }
              throw new Error("Not a comment: " + JSON.stringify(F));
            }
            function h(c) {
              let f = `*${c.value}*`.split(`
`);
              return f.length > 1 && f.every((F) => F.trim()[0] === "*");
            }
            function g(c) {
              let f = c.value.split(`
`);
              return ["/*", s(a, f.map((F, _) => _ === 0 ? F.trimEnd() : " " + (_ < f.length - 1 ? F.trim() : F.trimStart()))), "*/"];
            }
            r.exports = { printComment: y };
          } }), vd = te({ "src/language-js/print/literal.js"(e, r) {
            "use strict";
            ne();
            var { printString: t, printNumber: s } = Ue(), { replaceTextEndOfLine: a } = Yt(), { printDirective: n } = ct();
            function u(y, h) {
              let g = y.getNode();
              switch (g.type) {
                case "RegExpLiteral":
                  return p(g);
                case "BigIntLiteral":
                  return l(g.bigint || g.extra.raw);
                case "NumericLiteral":
                  return s(g.extra.raw);
                case "StringLiteral":
                  return a(t(g.extra.raw, h));
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return String(g.value);
                case "DecimalLiteral":
                  return s(g.value) + "m";
                case "Literal": {
                  if (g.regex)
                    return p(g.regex);
                  if (g.bigint)
                    return l(g.raw);
                  if (g.decimal)
                    return s(g.decimal) + "m";
                  let { value: c } = g;
                  return typeof c == "number" ? s(g.raw) : typeof c == "string" ? i(y) ? n(g.raw, h) : a(t(g.raw, h)) : String(c);
                }
              }
            }
            function i(y) {
              if (y.getName() !== "expression")
                return;
              let h = y.getParentNode();
              return h.type === "ExpressionStatement" && h.directive;
            }
            function l(y) {
              return y.toLowerCase();
            }
            function p(y) {
              let { pattern: h, flags: g } = y;
              return g = [...g].sort().join(""), `/${h}/${g}`;
            }
            r.exports = { printLiteral: u };
          } }), Cd = te({ "src/language-js/printer-estree.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { hasNewline: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = td(), g = rd(), { insertPragma: c } = Co(), f = Eo(), F = qt(), _ = Fo(), { hasFlowShorthandAnnotationComment: w, hasComment: E, CommentCheckFlags: N, isTheOnlyJsxElementInMarkdown: x, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke(), { locStart: o, locEnd: d } = ut(), v = Pt(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd(), { printAngular: B } = fd(), { printJsx: k, hasJsxIgnoreComment: M } = Dd(), { printFlow: R } = dd(), { printTypescript: q } = yd(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = To(), { printTernary: de } = Bo(), { printTemplateLiteral: ue } = jt(), { printArray: Fe } = er(), { printObject: z } = uu(), { printClass: U, printClassMethod: Z, printClassProperty: se } = nr(), { printProperty: fe } = rr(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = qr(), { printCallExpression: Ne } = xo(), { printVariableDeclarator: Pe, printAssignmentExpression: oe } = tr(), { printBinaryishExpression: H } = ru(), { printSwitchCaseConsequent: pe } = No(), { printMemberExpression: X } = So(), { printBlock: le, printBlockBody: Ae } = wo(), { printComment: Ee } = hd(), { printLiteral: De } = vd(), { printDecorators: A } = nu();
            function G(Ce, Be, ve, ze) {
              let be = re(Ce, Be, ve, ze);
              if (!be)
                return "";
              let Ye = Ce.getValue(), { type: Se } = Ye;
              if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod")
                return be;
              let Ie = [be], Oe = A(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
              if (Oe && (Ie = [...Oe, be], !Je))
                return l(Ie);
              if (!F(Ce, Be))
                return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === be ? be : Ie;
              if (Je && (Ie = [p([n, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
                let [je] = Ye.trailingComments;
                Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
              }
              return Je && Ie.push(n), Ie.push(")"), Ie;
            }
            function re(Ce, Be, ve, ze) {
              let be = Ce.getValue(), Ye = Be.semi ? ";" : "";
              if (!be)
                return "";
              if (typeof be == "string")
                return be;
              for (let Ie of [De, S, B, k, R, q]) {
                let Oe = Ie(Ce, Be, ve);
                if (typeof Oe < "u")
                  return Oe;
              }
              let Se = [];
              switch (be.type) {
                case "JsExpressionRoot":
                  return ve("node");
                case "JsonRoot":
                  return [ve("node"), u];
                case "File":
                  return be.program && be.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
                case "Program":
                  return Ae(Ce, Be, ve);
                case "EmptyStatement":
                  return "";
                case "ExpressionStatement": {
                  if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
                    let Oe = Ce.getParentNode();
                    if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === be)
                      return [ve("expression"), b(be.expression) ? ";" : ""];
                  }
                  let Ie = t(Ce, Be, true, (Oe) => {
                    let { marker: Je } = Oe;
                    return Je === C;
                  });
                  return [ve("expression"), x(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
                }
                case "ParenthesizedExpression":
                  return !E(be.expression) && (be.expression.type === "ObjectExpression" || be.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p([i, ve("expression")]), i, ")"]);
                case "AssignmentExpression":
                  return oe(Ce, Be, ve);
                case "VariableDeclarator":
                  return Pe(Ce, Be, ve);
                case "BinaryExpression":
                case "LogicalExpression":
                  return H(Ce, Be, ve);
                case "AssignmentPattern":
                  return [ve("left"), " = ", ve("right")];
                case "OptionalMemberExpression":
                case "MemberExpression":
                  return X(Ce, Be, ve);
                case "MetaProperty":
                  return [ve("meta"), ".", ve("property")];
                case "BindExpression":
                  return be.object && Se.push(ve("object")), Se.push(l(p([i, L(Ce, Be, ve)]))), Se;
                case "Identifier":
                  return [be.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];
                case "V8IntrinsicIdentifier":
                  return ["%", be.name];
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                  return j(Ce, Be, ve);
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return ge(Ce, ve, Be, ze);
                case "ArrowFunctionExpression":
                  return he(Ce, Be, ve, ze);
                case "YieldExpression":
                  return Se.push("yield"), be.delegate && Se.push("*"), be.argument && Se.push(" ", ve("argument")), Se;
                case "AwaitExpression": {
                  if (Se.push("await"), be.argument) {
                    Se.push(" ", ve("argument"));
                    let Ie = Ce.getParentNode();
                    if (T(Ie) && Ie.callee === be || m(Ie) && Ie.object === be) {
                      Se = [p([i, ...Se]), i];
                      let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
                      if (!Oe || Oe.type !== "AwaitExpression")
                        return l(Se);
                    }
                  }
                  return Se;
                }
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                  return ce(Ce, Be, ve);
                case "ExportAllDeclaration":
                  return W(Ce, Be, ve);
                case "ImportDeclaration":
                  return ee(Ce, Be, ve);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                  return K(Ce, Be, ve);
                case "ImportAttribute":
                  return [ve("key"), ": ", ve("value")];
                case "Import":
                  return "import";
                case "BlockStatement":
                case "StaticBlock":
                case "ClassBody":
                  return le(Ce, Be, ve);
                case "ThrowStatement":
                  return Re(Ce, Be, ve);
                case "ReturnStatement":
                  return ke(Ce, Be, ve);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                  return Ne(Ce, Be, ve);
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  return z(Ce, Be, ve);
                case "ObjectProperty":
                case "Property":
                  return be.method || be.kind === "get" || be.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
                case "ObjectMethod":
                  return we(Ce, Be, ve);
                case "Decorator":
                  return ["@", ve("expression")];
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  return Fe(Ce, Be, ve);
                case "SequenceExpression": {
                  let Ie = Ce.getParentNode(0);
                  if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                    let Oe = [];
                    return Ce.each((Je, Te) => {
                      Te === 0 ? Oe.push(ve()) : Oe.push(",", p([n, ve()]));
                    }, "expressions"), l(Oe);
                  }
                  return l(a([",", n], Ce.map(ve, "expressions")));
                }
                case "ThisExpression":
                  return "this";
                case "Super":
                  return "super";
                case "Directive":
                  return [ve("value"), Ye];
                case "DirectiveLiteral":
                  return ie(be.extra.raw, Be);
                case "UnaryExpression":
                  return Se.push(be.operator), /[a-z]$/.test(be.operator) && Se.push(" "), E(be.argument) ? Se.push(l(["(", p([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
                case "UpdateExpression":
                  return Se.push(ve("argument"), be.operator), be.prefix && Se.reverse(), Se;
                case "ConditionalExpression":
                  return de(Ce, Be, ve);
                case "VariableDeclaration": {
                  let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", Te = be.declarations.some((Me) => Me.init), je;
                  return Ie.length === 1 && !E(be.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p(Ie[0])), Se = [be.declare ? "declare " : "", be.kind, je ? [" ", je] : "", p(Ie.slice(1).map((Me) => [",", Te && !Je ? u : n, Me]))], Je && Oe.body !== be || Se.push(Ye), l(Se);
                }
                case "WithStatement":
                  return l(["with (", ve("object"), ")", V(be.body, ve("body"))]);
                case "IfStatement": {
                  let Ie = V(be.consequent, ve("consequent")), Oe = l(["if (", l([p([i, ve("test")]), i]), ")", Ie]);
                  if (Se.push(Oe), be.alternate) {
                    let Je = E(be.consequent, N.Trailing | N.Line) || $(be), Te = be.consequent.type === "BlockStatement" && !Je;
                    Se.push(Te ? " " : u), E(be, N.Dangling) && Se.push(t(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(be.alternate, ve("alternate"), be.alternate.type === "IfStatement")));
                  }
                  return Se;
                }
                case "ForStatement": {
                  let Ie = V(be.body, ve("body")), Oe = t(Ce, Be, true), Je = Oe ? [Oe, i] : "";
                  return !be.init && !be.test && !be.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p([i, ve("init"), ";", n, ve("test"), ";", n, ve("update")]), i]), ")", Ie])];
                }
                case "WhileStatement":
                  return l(["while (", l([p([i, ve("test")]), i]), ")", V(be.body, ve("body"))]);
                case "ForInStatement":
                  return l(["for (", ve("left"), " in ", ve("right"), ")", V(be.body, ve("body"))]);
                case "ForOfStatement":
                  return l(["for", be.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(be.body, ve("body"))]);
                case "DoWhileStatement": {
                  let Ie = V(be.body, ve("body"));
                  return Se = [l(["do", Ie])], be.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p([i, ve("test")]), i]), ")", Ye), Se;
                }
                case "DoExpression":
                  return [be.async ? "async " : "", "do ", ve("body")];
                case "BreakStatement":
                  return Se.push("break"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
                case "ContinueStatement":
                  return Se.push("continue"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
                case "LabeledStatement":
                  return be.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
                case "TryStatement":
                  return ["try ", ve("block"), be.handler ? [" ", ve("handler")] : "", be.finalizer ? [" finally ", ve("finalizer")] : ""];
                case "CatchClause":
                  if (be.param) {
                    let Ie = E(be.param, (Je) => !v(Je) || Je.leading && s(Be.originalText, d(Je)) || Je.trailing && s(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
                    return ["catch ", Ie ? ["(", p([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
                  }
                  return ["catch ", ve("body")];
                case "SwitchStatement":
                  return [l(["switch (", p([i, ve("discriminant")]), i, ")"]), " {", be.cases.length > 0 ? p([u, a(u, Ce.map((Ie, Oe, Je) => {
                    let Te = Ie.getValue();
                    return [ve(), Oe !== Je.length - 1 && P(Te, Be) ? u : ""];
                  }, "cases"))]) : "", u, "}"];
                case "SwitchCase": {
                  be.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), E(be, N.Dangling) && Se.push(" ", t(Ce, Be, true));
                  let Ie = be.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
                  if (Ie.length > 0) {
                    let Oe = pe(Ce, Be, ve);
                    Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p([u, Oe]));
                  }
                  return Se;
                }
                case "DebuggerStatement":
                  return ["debugger", Ye];
                case "ClassDeclaration":
                case "ClassExpression":
                  return U(Ce, Be, ve);
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                  return Z(Ce, Be, ve);
                case "ClassProperty":
                case "PropertyDefinition":
                case "ClassPrivateProperty":
                case "ClassAccessorProperty":
                case "AccessorProperty":
                  return se(Ce, Be, ve);
                case "TemplateElement":
                  return y(be.value.raw);
                case "TemplateLiteral":
                  return ue(Ce, ve, Be);
                case "TaggedTemplateExpression":
                  return [ve("tag"), ve("typeParameters"), ve("quasi")];
                case "PrivateIdentifier":
                  return ["#", ve("name")];
                case "PrivateName":
                  return ["#", ve("id")];
                case "InterpreterDirective":
                  return Se.push("#!", be.value, u), P(be, Be) && Se.push(u), Se;
                case "TopicReference":
                  return "%";
                case "ArgumentPlaceholder":
                  return "?";
                case "ModuleExpression": {
                  Se.push("module {");
                  let Ie = ve("body");
                  return Ie && Se.push(p([u, Ie]), u), Se.push("}"), Se;
                }
                default:
                  throw new Error("unknown type: " + JSON.stringify(be.type));
              }
            }
            function ye(Ce) {
              return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
            }
            r.exports = { preprocess: _, print: G, embed: h, insertPragma: c, massageAstNode: g, hasPrettierIgnore(Ce) {
              return D(Ce) || M(Ce);
            }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
          } }), Ed = te({ "src/language-js/printer-estree-json.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t, indent: s, join: a } } = qe(), n = Fo();
            function u(y, h, g) {
              let c = y.getValue();
              switch (c.type) {
                case "JsonRoot":
                  return [g("node"), t];
                case "ArrayExpression": {
                  if (c.elements.length === 0)
                    return "[]";
                  let f = y.map(() => y.getValue() === null ? "null" : g(), "elements");
                  return ["[", s([t, a([",", t], f)]), t, "]"];
                }
                case "ObjectExpression":
                  return c.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], y.map(g, "properties"))]), t, "}"];
                case "ObjectProperty":
                  return [g("key"), ": ", g("value")];
                case "UnaryExpression":
                  return [c.operator === "+" ? "" : c.operator, g("argument")];
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return c.value ? "true" : "false";
                case "StringLiteral":
                  return JSON.stringify(c.value);
                case "NumericLiteral":
                  return i(y) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
                case "Identifier":
                  return i(y) ? JSON.stringify(c.name) : c.name;
                case "TemplateLiteral":
                  return g(["quasis", 0]);
                case "TemplateElement":
                  return JSON.stringify(c.value.cooked);
                default:
                  throw new Error("unknown type: " + JSON.stringify(c.type));
              }
            }
            function i(y) {
              return y.getName() === "key" && y.getParentNode().type === "ObjectProperty";
            }
            var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
            function p(y, h) {
              let { type: g } = y;
              if (g === "ObjectProperty") {
                let { key: c } = y;
                c.type === "Identifier" ? h.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (h.key = { type: "StringLiteral", value: String(c.value) });
                return;
              }
              if (g === "UnaryExpression" && y.operator === "+")
                return h.argument;
              if (g === "ArrayExpression") {
                for (let [c, f] of y.elements.entries())
                  f === null && h.elements.splice(c, 0, { type: "NullLiteral" });
                return;
              }
              if (g === "TemplateLiteral")
                return { type: "StringLiteral", value: y.quasis[0].value.cooked };
            }
            p.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p };
          } }), Mt = te({ "src/common/common-options.js"(e, r) {
            "use strict";
            ne();
            var t = "Common";
            r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
          } }), Fd = te({ "src/language-js/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt(), s = "JavaScript";
            r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
          } }), Ad = te({ "src/language-js/parse/parsers.js"() {
            ne();
          } }), Ln = te({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
            r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
          } }), Sd = te({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
            r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
          } }), xd = te({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
            r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
          } }), wa = te({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
            r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
          } }), bd = te({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
            r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
          } }), Td = te({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
            r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
          } }), Bd = te({ "src/language-js/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Cd(), a = Ed(), n = Fd(), u = Ad(), i = [t(Ln(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(Ln(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Ln(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Sd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(xd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(wa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(wa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((y) => y !== ".jsonl") })), t(bd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t(Td(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
            r.exports = { languages: i, options: n, printers: l, parsers: u };
          } }), Nd = te({ "src/language-css/clean.js"(e, r) {
            "use strict";
            ne();
            var { isFrontMatterNode: t } = Ue(), s = lt(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
            function n(i, l, p) {
              if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i))
                return null;
              if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h, g) => {
                let c = Number(h);
                return Number.isNaN(c) ? y : c + g.toLowerCase();
              })), i.type === "selector-tag") {
                let y = i.value.toLowerCase();
                ["from", "to"].includes(y) && (l.value = y);
              }
              if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
                let y = i.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
                y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
              }
              if (i.type === "value-comma_group" && i.groups.some((y) => y.type === "value-atword" && y.value.endsWith("[") || y.type === "value-word" && y.value.startsWith("]")))
                return { type: "value-atword", value: i.groups.map((y) => y.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
            }
            n.ignoredProperties = a;
            function u(i) {
              return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
            }
            r.exports = n;
          } }), su = te({ "src/utils/front-matter/print.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t, markAsRoot: s } } = qe();
            function a(n, u) {
              if (n.lang === "yaml") {
                let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
                return s([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
              }
            }
            r.exports = a;
          } }), wd = te({ "src/language-css/embed.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t } } = qe(), s = su();
            function a(n, u, i) {
              let l = n.getValue();
              if (l.type === "front-matter") {
                let p = s(l, i);
                return p ? [p, t] : "";
              }
            }
            r.exports = a;
          } }), _o = te({ "src/utils/front-matter/parse.js"(e, r) {
            "use strict";
            ne();
            var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
            function s(a) {
              let n = a.match(t);
              if (!n)
                return { content: a };
              let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n.groups, y = i.trim() || "yaml";
              if (u === "+++" && (y = "toml"), y !== "yaml" && u !== p)
                return { content: a };
              let [h] = n;
              return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: p, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + a.slice(h.length) };
            }
            r.exports = s;
          } }), _d = te({ "src/language-css/pragma.js"(e, r) {
            "use strict";
            ne();
            var t = Co(), s = _o();
            function a(u) {
              return t.hasPragma(s(u).content);
            }
            function n(u) {
              let { frontMatter: i, content: l } = s(u);
              return (i ? i.raw + `

` : "") + t.insertPragma(l);
            }
            r.exports = { hasPragma: a, insertPragma: n };
          } }), Pd = te({ "src/language-css/utils/index.js"(e, r) {
            "use strict";
            ne();
            var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
            function s(z, U) {
              let Z = Array.isArray(U) ? U : [U], se = -1, fe;
              for (; fe = z.getParentNode(++se); )
                if (Z.includes(fe.type))
                  return se;
              return -1;
            }
            function a(z, U) {
              let Z = s(z, U);
              return Z === -1 ? null : z.getParentNode(Z);
            }
            function n(z) {
              var U;
              let Z = a(z, "css-decl");
              return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();
            }
            var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
            function i(z) {
              return u.has(z.toLowerCase());
            }
            function l(z, U) {
              let Z = a(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U.toLowerCase());
            }
            function p(z) {
              return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
            }
            function y(z, U) {
              var Z;
              let se = a(z, "value-func");
              return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;
            }
            function h(z) {
              var U;
              let Z = a(z, "css-rule"), se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;
              return se && (se.startsWith(":import") || se.startsWith(":export"));
            }
            function g(z, U) {
              let Z = Array.isArray(U) ? U : [U], se = a(z, "css-atrule");
              return se && Z.includes(se.name.toLowerCase());
            }
            function c(z) {
              let U = z.getValue(), Z = a(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) === "import" && U.groups[0].value === "url" && U.groups.length === 2;
            }
            function f(z) {
              return z.type === "value-func" && z.value.toLowerCase() === "url";
            }
            function F(z, U) {
              var Z;
              let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
              return se && se.indexOf(U) === se.length - 1;
            }
            function _(z) {
              let { selector: U } = z;
              return U ? typeof U == "string" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : false;
            }
            function w(z) {
              return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
            }
            function E(z) {
              return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
            }
            function N(z) {
              return z.type === "value-word" && z.value === "in";
            }
            function x(z) {
              return z.type === "value-operator" && z.value === "*";
            }
            function I(z) {
              return z.type === "value-operator" && z.value === "/";
            }
            function P(z) {
              return z.type === "value-operator" && z.value === "+";
            }
            function $(z) {
              return z.type === "value-operator" && z.value === "-";
            }
            function D(z) {
              return z.type === "value-operator" && z.value === "%";
            }
            function T(z) {
              return x(z) || I(z) || P(z) || $(z) || D(z);
            }
            function m(z) {
              return z.type === "value-word" && ["==", "!="].includes(z.value);
            }
            function C(z) {
              return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
            }
            function o(z) {
              return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
            }
            function d(z) {
              var U;
              return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\(\s*\)$/.test(z.raws.params);
            }
            function v(z) {
              return z.name.startsWith("prettier-placeholder");
            }
            function S(z) {
              return z.prop.startsWith("@prettier-placeholder");
            }
            function b(z, U) {
              return z.value === "$$" && z.type === "value-func" && (U == null ? void 0 : U.type) === "value-word" && !U.raws.before;
            }
            function B(z) {
              var U, Z;
              return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
            }
            function k(z) {
              var U, Z, se;
              return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
            }
            function M(z) {
              var U;
              return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === "";
            }
            function R(z) {
              var U, Z;
              return z.type === "value-comma_group" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
            }
            function q(z) {
              var U;
              return z.type === "value-paren_group" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);
            }
            function J(z) {
              var U;
              let Z = z.getValue();
              if (Z.groups.length === 0)
                return false;
              let se = z.getParentNode(1);
              if (!q(Z) && !(se && q(se)))
                return false;
              let fe = a(z, "css-decl");
              return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith("$") || q(se) || se.type === "value-func");
            }
            function L(z) {
              return z.type === "value-comment" && z.inline;
            }
            function Q(z) {
              return z.type === "value-word" && z.value === "#";
            }
            function V(z) {
              return z.type === "value-word" && z.value === "{";
            }
            function j(z) {
              return z.type === "value-word" && z.value === "}";
            }
            function Y(z) {
              return ["value-word", "value-atword"].includes(z.type);
            }
            function ie(z) {
              return (z == null ? void 0 : z.type) === "value-colon";
            }
            function ee(z, U) {
              if (!R(U))
                return false;
              let { groups: Z } = U, se = Z.indexOf(z);
              return se === -1 ? false : ie(Z[se + 1]);
            }
            function ce(z) {
              return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
            }
            function W(z) {
              return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
            }
            function K(z) {
              return /\/\//.test(z.split(/[\n\r]/).pop());
            }
            function de(z) {
              return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
            }
            function ue(z, U) {
              var Z, se;
              if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
                return false;
              if (U.type === "value-comma_group") {
                let fe = U.groups.indexOf(z) - 1, ge = U.groups[fe];
                if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                  return true;
              }
              return false;
            }
            function Fe(z) {
              var U, Z;
              return z.type === "value-paren_group" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
            }
            r.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n, maybeToLowerCase: p, insideValueFunctionNode: y, insideICSSRuleNode: h, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: F, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
          } }), Id = te({ "src/utils/line-column-to-index.js"(e, r) {
            "use strict";
            ne(), r.exports = function(t, s) {
              let a = 0;
              for (let n = 0; n < t.line - 1; ++n)
                a = s.indexOf(`
`, a) + 1;
              return a + t.column;
            };
          } }), kd = te({ "src/language-css/loc.js"(e, r) {
            "use strict";
            ne();
            var { skipEverythingButNewLine: t } = Pr(), s = lt(), a = Id();
            function n(c, f) {
              return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a(c.source.start, f) - 1 : null;
            }
            function u(c, f) {
              if (c.type === "css-comment" && c.inline)
                return t(f, c.source.startOffset);
              let F = c.nodes && s(c.nodes);
              return F && c.source && !c.source.end && (c = F), c.source && c.source.end ? a(c.source.end, f) : null;
            }
            function i(c, f) {
              c.source && (c.source.startOffset = n(c, f), c.source.endOffset = u(c, f));
              for (let F in c) {
                let _ = c[F];
                F === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i(_, f));
              }
            }
            function l(c, f, F) {
              c.source && (c.source.startOffset = n(c, F) + f, c.source.endOffset = u(c, F) + f);
              for (let _ in c) {
                let w = c[_];
                _ === "source" || !w || typeof w != "object" || l(w, f, F);
              }
            }
            function p(c) {
              let f = c.source.startOffset;
              return typeof c.prop == "string" && (f += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f += c.raws.between.length), f;
            }
            function y(c) {
              let f = "initial", F = "initial", _, w = false, E = [];
              for (let N = 0; N < c.length; N++) {
                let x = c[N];
                switch (f) {
                  case "initial":
                    if (x === "'") {
                      f = "single-quotes";
                      continue;
                    }
                    if (x === '"') {
                      f = "double-quotes";
                      continue;
                    }
                    if ((x === "u" || x === "U") && c.slice(N, N + 4).toLowerCase() === "url(") {
                      f = "url", N += 3;
                      continue;
                    }
                    if (x === "*" && c[N - 1] === "/") {
                      f = "comment-block";
                      continue;
                    }
                    if (x === "/" && c[N - 1] === "/") {
                      f = "comment-inline", _ = N - 1;
                      continue;
                    }
                    continue;
                  case "single-quotes":
                    if (x === "'" && c[N - 1] !== "\\" && (f = F, F = "initial"), x === `
` || x === "\r")
                      return c;
                    continue;
                  case "double-quotes":
                    if (x === '"' && c[N - 1] !== "\\" && (f = F, F = "initial"), x === `
` || x === "\r")
                      return c;
                    continue;
                  case "url":
                    if (x === ")" && (f = "initial"), x === `
` || x === "\r")
                      return c;
                    if (x === "'") {
                      f = "single-quotes", F = "url";
                      continue;
                    }
                    if (x === '"') {
                      f = "double-quotes", F = "url";
                      continue;
                    }
                    continue;
                  case "comment-block":
                    x === "/" && c[N - 1] === "*" && (f = "initial");
                    continue;
                  case "comment-inline":
                    (x === '"' || x === "'" || x === "*") && (w = true), (x === `
` || x === "\r") && (w && E.push([_, N]), f = "initial", w = false);
                    continue;
                }
              }
              for (let [N, x] of E)
                c = c.slice(0, N) + c.slice(N, x).replace(/["'*]/g, " ") + c.slice(x);
              return c;
            }
            function h(c) {
              return c.source.startOffset;
            }
            function g(c) {
              return c.source.endOffset;
            }
            r.exports = { locStart: h, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
          } }), Ld = te({ "src/language-css/utils/is-less-parser.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              return s.parser === "css" || s.parser === "less";
            }
            r.exports = t;
          } }), Od = te({ "src/language-css/utils/is-scss.js"(e, r) {
            "use strict";
            ne();
            function t(s, a) {
              return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
            }
            r.exports = t;
          } }), jd = te({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
            r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
          } }), qd = te({ "src/language-css/utils/print-unit.js"(e, r) {
            "use strict";
            ne();
            var t = jd();
            function s(a) {
              let n = a.toLowerCase();
              return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a;
            }
            r.exports = s;
          } }), Md = te({ "src/language-css/printer-postcss.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { printNumber: s, printString: a, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue(), { builders: { join: p, line: y, hardline: h, softline: g, group: c, fill: f, indent: F, dedent: _, ifBreak: w, breakParent: E }, utils: { removeLines: N, getDocParts: x } } = qe(), I = Nd(), P = wd(), { insertPragma: $ } = _d(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le } = Pd(), { locStart: Ae, locEnd: Ee } = kd(), De = Ld(), A = Od(), G = qd();
            function re(Te) {
              return Te.trailingComma === "es5" || Te.trailingComma === "all";
            }
            function ye(Te, je, Me) {
              let ae = Te.getValue();
              if (!ae)
                return "";
              if (typeof ae == "string")
                return ae;
              switch (ae.type) {
                case "front-matter":
                  return [ae.raw, h];
                case "css-root": {
                  let Ve = Ce(Te, je, Me), We = ae.raws.after.trim();
                  return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x(Ve).length > 0 ? h : ""];
                }
                case "css-comment": {
                  let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
                  return Ve ? We.trimEnd() : We;
                }
                case "css-rule":
                  return [Me("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? y : " ", "{", ae.nodes.length > 0 ? F([h, Ce(Te, je, Me)]) : "", h, "}", M(ae) ? ";" : ""] : ";"];
                case "css-decl": {
                  let Ve = Te.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st = Xe === ":", O = W(ae) ? N(Me("value")) : Me("value");
                  return !st && H(Xe) && (O = F([h, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(Te) ? ae.prop : m(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", F([g, Ce(Te, je, Me)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(Te, ae) ? w(";") : ";"];
                }
                case "css-atrule": {
                  let Ve = Te.getParentNode(), We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
                  if (De(je)) {
                    if (ae.mixin)
                      return [Me("selector"), ae.important ? " !important" : "", We ? "" : ";"];
                    if (ae.function)
                      return [ae.name, Me("params"), We ? "" : ";"];
                    if (ae.variable)
                      return ["@", ae.name, ": ", ae.value ? Me("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : "", We ? "" : ";"];
                  }
                  return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m(ae.name), ae.params ? [z(ae) ? "" : U(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [h, h] : /^\s*\n/.test(ae.raws.afterName) ? h : " " : " ", Me("params")] : "", ae.selector ? F([" ", Me("selector")]) : "", ae.value ? c([" ", Me("value"), k(ae) ? K(ae) ? " " : y : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? y : " ", "{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : We ? "" : ";"];
                }
                case "media-query-list": {
                  let Ve = [];
                  return Te.each((We) => {
                    let Xe = We.getValue();
                    Xe.type === "media-query" && Xe.value === "" || Ve.push(Me());
                  }, "nodes"), c(F(p(y, Ve)));
                }
                case "media-query":
                  return [p(" ", Te.map(Me, "nodes")), B(Te, ae) ? "" : ","];
                case "media-type":
                  return Oe(Se(ae.value, je));
                case "media-feature-expression":
                  return ae.nodes ? ["(", ...Te.map(Me, "nodes"), ")"] : ae.value;
                case "media-feature":
                  return m(Se(ae.value.replace(/ +/g, " "), je));
                case "media-colon":
                  return [ae.value, " "];
                case "media-value":
                  return Oe(Se(ae.value, je));
                case "media-keyword":
                  return Se(ae.value, je);
                case "media-url":
                  return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
                case "media-unknown":
                  return ae.value;
                case "selector-root":
                  return c([d(Te, "custom-selector") ? [D(Te, "css-atrule").customSelector, y] : "", p([",", d(Te, ["extend", "custom-selector", "nest"]) ? y : h], Te.map(Me, "nodes"))]);
                case "selector-selector":
                  return c(F(Te.map(Me, "nodes")));
                case "selector-comment":
                  return ae.value;
                case "selector-string":
                  return Se(ae.value, je);
                case "selector-tag": {
                  let Ve = Te.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
                  return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(Te, ae.value) ? ae.value.toLowerCase() : ae.value)];
                }
                case "selector-id":
                  return ["#", ae.value];
                case "selector-class":
                  return [".", Oe(Se(ae.value, je))];
                case "selector-attribute": {
                  var nt;
                  return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
                }
                case "selector-combinator": {
                  if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
                    let Xe = Te.getParentNode();
                    return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : y, ae.value, B(Te, ae) ? "" : " "];
                  }
                  let Ve = ae.value.trim().startsWith("(") ? y : "", We = Oe(Se(ae.value.trim(), je)) || y;
                  return [Ve, We];
                }
                case "selector-universal":
                  return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
                case "selector-pseudo":
                  return [m(ae.value), l(ae.nodes) ? c(["(", F([g, p([",", y], Te.map(Me, "nodes"))]), g, ")"]) : ""];
                case "selector-nesting":
                  return ae.value;
                case "selector-unknown": {
                  let Ve = D(Te, "css-rule");
                  if (Ve && Ve.isSCSSNesterProperty)
                    return Oe(Se(m(ae.value), je));
                  let We = Te.getParentNode();
                  if (We.raws && We.raws.selector) {
                    let st = Ae(We), O = st + We.raws.selector.length;
                    return je.originalText.slice(st, O).trim();
                  }
                  let Xe = Te.getParentNode(1);
                  if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                    let st = Ee(We.open) + 1, O = Ae(We.close), me = je.originalText.slice(st, O).trim();
                    return H(me) ? [E, me] : me;
                  }
                  return ae.value;
                }
                case "value-value":
                case "value-root":
                  return Me("group");
                case "value-comment":
                  return je.originalText.slice(Ae(ae), Ee(ae));
                case "value-comma_group": {
                  let Ve = Te.getParentNode(), We = Te.getParentNode(1), Xe = T(Te), st = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(Te, "css-atrule"), me = O && k(O), _e = ae.groups.some((at) => ge(at)), He = Te.map(Me, "groups"), Ge = [], it = C(Te, "url"), Qe = false, rt = false;
                  for (let at = 0; at < ae.groups.length; ++at) {
                    var tt;
                    Ge.push(He[at]);
                    let Ze = ae.groups[at - 1], Le = ae.groups[at], $e = ae.groups[at + 1], sr = ae.groups[at + 2];
                    if (it) {
                      ($e && Q($e) || Q(Le)) && Ge.push(" ");
                      continue;
                    }
                    if (d(Te, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e))
                      continue;
                    if (Le.type === "value-string" && Le.quoted) {
                      let $r = Le.value.lastIndexOf("#{"), Vr = Le.value.lastIndexOf("}");
                      $r !== -1 && Vr !== -1 ? Qe = $r > Vr : $r !== -1 ? Qe = true : Vr !== -1 && (Qe = false);
                    }
                    if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e))
                      continue;
                    let Rr = j(Le), ou = j($e);
                    if ((Rr && he($e) || ou && ke(Le)) && de($e) || !Ze && L(Le) || C(Te, "calc") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e))
                      continue;
                    let qo = (Q(Le) || V(Le)) && at === 0 && ($e.type === "value-number" || $e.isHex) && We && oe(We) && !de($e), lu = sr && sr.type === "value-func" || sr && Re(sr) || Le.type === "value-func" || Re(Le), cu = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
                    if (!(!(J($e) || J(Le)) && !C(Te, "calc") && !qo && (L($e) && !lu || L(Le) && !cu || Q($e) && !lu || Q(Le) && !cu || V($e) || V(Le)) && (de($e) || Rr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && Rr && Le.value === "-" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
                      if (ge(Le)) {
                        if (Ve.type === "value-paren_group") {
                          Ge.push(_(h));
                          continue;
                        }
                        Ge.push(h);
                        continue;
                      }
                      if (me && (q($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {
                        Ge.push(" ");
                        continue;
                      }
                      if (O && O.name.toLowerCase() === "namespace") {
                        Ge.push(" ");
                        continue;
                      }
                      if (st) {
                        Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(h), rt = true) : Ge.push(" ");
                        continue;
                      }
                      if (ou) {
                        Ge.push(" ");
                        continue;
                      }
                      if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
                        if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {
                          Ge.push(g);
                          continue;
                        }
                        if (Le.value === "with" && le($e)) {
                          Ge.push(" ");
                          continue;
                        }
                        (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e.value === "{" && le($e.group) || Ge.push(y);
                      }
                    }
                  }
                  return _e && Ge.push(E), rt && Ge.unshift(h), me ? c(F(Ge)) : v(Te) ? c(f(Ge)) : c(F(f(Ge)));
                }
                case "value-paren_group": {
                  let Ve = Te.getParentNode();
                  if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:")))
                    return [ae.open ? Me("open") : "", p(",", Te.map(Me, "groups")), ae.close ? Me("close") : ""];
                  if (!ae.open) {
                    let it = Te.map(Me, "groups"), Qe = [];
                    for (let rt = 0; rt < it.length; rt++)
                      rt !== 0 && Qe.push([",", y]), Qe.push(it[rt]);
                    return c(F(f(Qe)));
                  }
                  let We = fe(Te), Xe = t(ae.groups), st = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me = X(ae, Ve), _e = me || We && !O, He = me || O, Ge = c([ae.open ? Me("open") : "", F([g, p([y], Te.map((it, Qe) => {
                    let rt = it.getValue(), at = Qe === ae.groups.length - 1, Ze = [Me(), at ? "" : ","];
                    if (ue(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
                      let Le = x(Ze[0].contents.contents);
                      Le[1] = c(Le[1]), Ze = [c(_(Ze))];
                    }
                    if (!at && rt.type === "value-comma_group" && l(rt.groups)) {
                      let Le = t(rt.groups);
                      !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(h);
                    }
                    return Ze;
                  }, "groups"))]), w(!st && A(je.parser, je.originalText) && We && re(je) ? "," : ""), g, ae.close ? Me("close") : ""], { shouldBreak: _e });
                  return He ? _(Ge) : Ge;
                }
                case "value-func":
                  return [ae.value, d(Te, "supports") && Pe(ae) ? " " : "", Me("group")];
                case "value-paren":
                  return ae.value;
                case "value-number":
                  return [Je(ae.value), G(ae.unit)];
                case "value-operator":
                  return ae.value;
                case "value-word":
                  return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
                case "value-colon": {
                  let Ve = Te.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
                  return [ae.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(Te, "url") ? "" : y];
                }
                case "value-comma":
                  return [ae.value, " "];
                case "value-string":
                  return a(ae.raws.quote + ae.value + ae.raws.quote, je);
                case "value-atword":
                  return ["@", ae.value];
                case "value-unicode-range":
                  return ae.value;
                case "value-unknown":
                  return ae.value;
                default:
                  throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
              }
            }
            function Ce(Te, je, Me) {
              let ae = [];
              return Te.each((nt, tt, Ve) => {
                let We = Ve[tt - 1];
                if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
                  let Xe = nt.getValue();
                  ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
                } else
                  ae.push(Me());
                tt !== Ve.length - 1 && (Ve[tt + 1].type === "css-comment" && !n(je.originalText, Ae(Ve[tt + 1]), { backwards: true }) && !u(Ve[tt]) || Ve[tt + 1].type === "css-atrule" && Ve[tt + 1].name === "else" && Ve[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? y : h), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(h)));
              }, "nodes"), ae;
            }
            var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${be.source})?(${ve.source})(${ze.source})?`, "g");
            function Se(Te, je) {
              return Te.replace(Be, (Me) => a(Me, je));
            }
            function Ie(Te, je) {
              let Me = je.singleQuote ? "'" : '"';
              return Te.includes('"') || Te.includes("'") ? Te : Me + Te + Me;
            }
            function Oe(Te) {
              return Te.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m(tt || "") : je);
            }
            function Je(Te) {
              return s(Te).replace(/\.0(?=$|e)/, "");
            }
            r.exports = { print: ye, embed: P, insertPragma: $, massageAstNode: I };
          } }), Rd = te({ "src/language-css/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { singleQuote: t.singleQuote };
          } }), $d = te({ "src/language-css/parsers.js"() {
            ne();
          } }), Vd = te({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
            r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
          } }), Wd = te({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
            r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
          } }), Hd = te({ "node_modules/linguist-languages/data/Less.json"(e, r) {
            r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
          } }), Gd = te({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
            r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
          } }), Ud = te({ "src/language-css/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Md(), a = Rd(), n = $d(), u = [t(Vd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(Wd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Hd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Gd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
            r.exports = { languages: u, options: a, printers: i, parsers: n };
          } }), Jd = te({ "src/language-handlebars/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a) {
              return a.loc.start.offset;
            }
            function s(a) {
              return a.loc.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), zd = te({ "src/language-handlebars/clean.js"(e, r) {
            "use strict";
            ne();
            function t(s, a) {
              if (s.type === "TextNode") {
                let n = s.chars.trim();
                if (!n)
                  return null;
                a.chars = n.replace(/[\t\n\f\r ]+/g, " ");
              }
              s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
            }
            t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
          } }), Xd = te({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
            r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
          } }), Kd = te({ "src/language-handlebars/utils.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), s = Xd();
            function a(x) {
              let I = x.getValue(), P = x.getParentNode(0);
              return !!(g(x, ["ElementNode"]) && t(P.children) === I || g(x, ["Block"]) && t(P.body) === I);
            }
            function n(x) {
              return x.toUpperCase() === x;
            }
            function u(x) {
              return h(x, ["ElementNode"]) && typeof x.tag == "string" && !x.tag.startsWith(":") && (n(x.tag[0]) || x.tag.includes("."));
            }
            var i = new Set(s);
            function l(x) {
              return i.has(x.toLowerCase()) && !n(x[0]);
            }
            function p(x) {
              return x.selfClosing === true || l(x.tag) || u(x) && x.children.every((I) => y(I));
            }
            function y(x) {
              return h(x, ["TextNode"]) && !/\S/.test(x.chars);
            }
            function h(x, I) {
              return x && I.includes(x.type);
            }
            function g(x, I) {
              let P = x.getParentNode(0);
              return h(P, I);
            }
            function c(x, I) {
              let P = _(x);
              return h(P, I);
            }
            function f(x, I) {
              let P = w(x);
              return h(P, I);
            }
            function F(x, I) {
              var P, $, D, T;
              let m = x.getValue(), C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($ = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $ !== void 0 ? $ : [], d = o.indexOf(m);
              return d !== -1 && o[d + I];
            }
            function _(x) {
              let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              return F(x, -I);
            }
            function w(x) {
              return F(x, 1);
            }
            function E(x) {
              return h(x, ["MustacheCommentStatement"]) && typeof x.value == "string" && x.value.trim() === "prettier-ignore";
            }
            function N(x) {
              let I = x.getValue(), P = _(x, 2);
              return E(I) || E(P);
            }
            r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f, isNodeOfSomeType: h, isParentOfSomeType: g, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: y };
          } }), Yd = te({ "src/language-handlebars/printer-glimmer.js"(e, r) {
            "use strict";
            ne();
            var { builders: { dedent: t, fill: s, group: a, hardline: n, ifBreak: u, indent: i, join: l, line: p, softline: y }, utils: { getDocParts: h, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: c, isNonEmptyArray: f } = Ue(), { locStart: F, locEnd: _ } = Jd(), w = zd(), { getNextNode: E, getPreviousNode: N, hasPrettierIgnore: x, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = Kd(), o = 2;
            function d(H, pe, X) {
              let le = H.getValue();
              if (!le)
                return "";
              if (x(H))
                return pe.originalText.slice(F(le), _(le));
              let Ae = pe.singleQuote ? "'" : '"';
              switch (le.type) {
                case "Block":
                case "Program":
                case "Template":
                  return a(H.map(X, "body"));
                case "ElementNode": {
                  let Ee = a(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y : "";
                  if (m(le))
                    return [Ee, De];
                  let A = ["</", le.tag, ">"];
                  return le.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n, i(A), De] : [Ee, i(a(b(H, pe, X))), i(A), De];
                }
                case "BlockStatement": {
                  let Ee = H.getParentNode(1);
                  return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
                }
                case "ElementModifierStatement":
                  return a(["{{", Re(H, X), "}}"]);
                case "MustacheStatement":
                  return a([k(le), Re(H, X), M(le)]);
                case "SubExpression":
                  return a(["(", ke(H, X), y, ")"]);
                case "AttrNode": {
                  let Ee = le.value.type === "TextNode";
                  if (Ee && le.value.chars === "" && F(le.value) === _(le.value))
                    return le.name;
                  let A = Ee ? c(le.value.chars, Ae).quote : le.value.type === "ConcatStatement" ? c(le.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae).quote : "", G = X("value");
                  return [le.name, "=", A, le.name === "class" && A ? a(i(G)) : G, A];
                }
                case "ConcatStatement":
                  return H.map(X, "parts");
                case "Hash":
                  return l(p, H.map(X, "pairs"));
                case "HashPair":
                  return [le.key, "=", X("value")];
                case "TextNode": {
                  let Ee = le.chars.replace(/{{/g, "\\{{"), De = U(H);
                  if (De) {
                    if (De === "class") {
                      let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
                      return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p : "", Ye, Ie ? p : ""];
                    }
                    return g(Ee);
                  }
                  let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N(H), ye = !E(H);
                  if (pe.htmlWhitespaceSensitivity !== "ignore") {
                    let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye && D(H, ["Template"]), Oe = re && D(H, ["Template"]);
                    if (G) {
                      if (Oe || Ie)
                        return "";
                      let ae = [p], nt = Z(Ee);
                      return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t(tt))), ae;
                    }
                    let [Je] = Ee.match(Ye), [Te] = Ee.match(Se), je = [];
                    if (Je) {
                      je = [p];
                      let ae = Z(Je);
                      ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
                    }
                    let Me = [];
                    if (Te) {
                      if (!Ie) {
                        Me = [p];
                        let ae = Z(Te);
                        ae && (Me = ge(ae)), I(H) && (Me = Me.map((nt) => t(nt)));
                      }
                      Ee = Ee.replace(Se, "");
                    }
                    return [...je, s(Fe(Ee)), ...Me];
                  }
                  let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
                  if ((re || ye) && G && D(H, ["Block", "ElementNode", "Template"]))
                    return "";
                  G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                  let ze = "", be = "";
                  return ve === 0 && P(H, ["MustacheStatement"]) && (be = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye && (ve = 0, be = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be), [...ge(Be), s(Fe(Ee)), ...ge(ve)];
                }
                case "MustacheCommentStatement": {
                  let Ee = F(le), De = _(le), A = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re = le.value.includes("}}") ? "--" : "";
                  return ["{{", A ? "~" : "", "!", re, le.value, re, G ? "~" : "", "}}"];
                }
                case "PathExpression":
                  return le.original;
                case "BooleanLiteral":
                  return String(le.value);
                case "CommentStatement":
                  return ["<!--", le.value, "-->"];
                case "StringLiteral": {
                  if (we(H)) {
                    let Ee = pe.singleQuote ? '"' : "'";
                    return he(le.value, Ee);
                  }
                  return he(le.value, Ae);
                }
                case "NumberLiteral":
                  return String(le.value);
                case "UndefinedLiteral":
                  return "undefined";
                case "NullLiteral":
                  return "null";
                default:
                  throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
              }
            }
            function v(H, pe) {
              return F(H) - F(pe);
            }
            function S(H, pe) {
              let X = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae = le.flatMap((Ee) => X[Ee]).sort(v);
              for (let Ee of le)
                H.each((De) => {
                  let A = Ae.indexOf(De.getValue());
                  Ae.splice(A, 1, [p, pe()]);
                }, Ee);
              return f(X.blockParams) && Ae.push(p, oe(X)), ["<", X.tag, i(Ae), B(X)];
            }
            function b(H, pe, X) {
              let Ae = H.getValue().children.every((Ee) => C(Ee));
              return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
                let A = X();
                return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [y, A] : A;
              }, "children");
            }
            function B(H) {
              return m(H) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
            }
            function k(H) {
              let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
              return [pe, X];
            }
            function M(H) {
              let pe = H.escaped === false ? "}}}" : "}}";
              return [H.strip && H.strip.close ? "~" : "", pe];
            }
            function R(H) {
              let pe = k(H), X = H.openStrip.open ? "~" : "";
              return [pe, X, "#"];
            }
            function q(H) {
              let pe = M(H);
              return [H.openStrip.close ? "~" : "", pe];
            }
            function J(H) {
              let pe = k(H), X = H.closeStrip.open ? "~" : "";
              return [pe, X, "/"];
            }
            function L(H) {
              let pe = M(H);
              return [H.closeStrip.close ? "~" : "", pe];
            }
            function Q(H) {
              let pe = k(H), X = H.inverseStrip.open ? "~" : "";
              return [pe, X];
            }
            function V(H) {
              let pe = M(H);
              return [H.inverseStrip.close ? "~" : "", pe];
            }
            function j(H, pe) {
              let X = H.getValue(), le = [], Ae = Pe(H, pe);
              return Ae && le.push(a(Ae)), f(X.program.blockParams) && le.push(oe(X.program)), a([R(X), Ne(H, pe), le.length > 0 ? i([p, l(p, le)]) : "", y, q(X)]);
            }
            function Y(H, pe) {
              return [pe.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
            }
            function ie(H, pe, X) {
              let le = H.getValue(), Ae = H.getParentNode(1);
              return a([Q(Ae), ["else", " ", X], i([p, a(Pe(H, pe)), ...f(le.program.blockParams) ? [p, oe(le.program)] : []]), y, V(Ae)]);
            }
            function ee(H, pe, X) {
              let le = H.getValue();
              return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le) ? y : n, J(le), pe("path"), L(le)] : [J(le), pe("path"), L(le)];
            }
            function ce(H) {
              return $(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
            }
            function W(H) {
              return K(H) && H.inverse.body.length === 1 && $(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
            }
            function K(H) {
              return $(H, ["BlockStatement"]) && H.inverse;
            }
            function de(H, pe, X) {
              let le = H.getValue();
              if (ce(le))
                return "";
              let Ae = pe("program");
              return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae]) : i(Ae);
            }
            function ue(H, pe, X) {
              let le = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae] : Ae;
              return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : "";
            }
            function Fe(H) {
              return h(l(p, z(H)));
            }
            function z(H) {
              return H.split(/[\t\n\f\r ]+/);
            }
            function U(H) {
              for (let pe = 0; pe < 2; pe++) {
                let X = H.getParentNode(pe);
                if (X && X.type === "AttrNode")
                  return X.name.toLowerCase();
              }
            }
            function Z(H) {
              return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
            }
            function se(H) {
              H = typeof H == "string" ? H : "";
              let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
              return Z(pe);
            }
            function fe(H) {
              H = typeof H == "string" ? H : "";
              let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
              return Z(pe);
            }
            function ge() {
              let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return Array.from({ length: Math.min(H, o) }).fill(n);
            }
            function he(H, pe) {
              let { quote: X, regex: le } = c(H, pe);
              return [X, H.replace(le, `\\${X}`), X];
            }
            function we(H) {
              let pe = 0, X = H.getParentNode(pe);
              for (; X && $(X, ["SubExpression"]); )
                pe++, X = H.getParentNode(pe);
              return !!(X && $(H.getParentNode(pe + 1), ["ConcatStatement"]) && $(H.getParentNode(pe + 2), ["AttrNode"]));
            }
            function ke(H, pe) {
              let X = Ne(H, pe), le = Pe(H, pe);
              return le ? i([X, p, a(le)]) : X;
            }
            function Re(H, pe) {
              let X = Ne(H, pe), le = Pe(H, pe);
              return le ? [i([X, p, le]), y] : X;
            }
            function Ne(H, pe) {
              return pe("path");
            }
            function Pe(H, pe) {
              let X = H.getValue(), le = [];
              if (X.params.length > 0) {
                let Ae = H.map(pe, "params");
                le.push(...Ae);
              }
              if (X.hash && X.hash.pairs.length > 0) {
                let Ae = pe("hash");
                le.push(Ae);
              }
              return le.length === 0 ? "" : l(p, le);
            }
            function oe(H) {
              return ["as |", H.blockParams.join(" "), "|"];
            }
            r.exports = { print: d, massageAstNode: w };
          } }), Qd = te({ "src/language-handlebars/parsers.js"() {
            ne();
          } }), Zd = te({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
            r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
          } }), eg = te({ "src/language-handlebars/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Yd(), a = Qd(), n = [t(Zd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
            r.exports = { languages: n, printers: u, parsers: a };
          } }), tg = te({ "src/language-graphql/pragma.js"(e, r) {
            "use strict";
            ne();
            function t(a) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
            }
            function s(a) {
              return `# @format

` + a;
            }
            r.exports = { hasPragma: t, insertPragma: s };
          } }), rg = te({ "src/language-graphql/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a) {
              return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
            }
            function s(a) {
              return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), ng = te({ "src/language-graphql/printer-graphql.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, hardline: s, line: a, softline: n, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: y } = Ue(), { insertPragma: h } = tg(), { locStart: g, locEnd: c } = rg();
            function f(P, $, D) {
              let T = P.getValue();
              if (!T)
                return "";
              if (typeof T == "string")
                return T;
              switch (T.kind) {
                case "Document": {
                  let m = [];
                  return P.each((C, o, d) => {
                    m.push(D()), o !== d.length - 1 && (m.push(s), p($.originalText, C.getValue(), c) && m.push(s));
                  }, "definitions"), [...m, s];
                }
                case "OperationDefinition": {
                  let m = $.originalText[g(T)] !== "{", C = Boolean(T.name);
                  return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && y(T.variableDefinitions) ? " " : "", y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
                }
                case "FragmentDefinition":
                  return ["fragment ", D("name"), y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), F(P, D, T), " ", D("selectionSet")];
                case "SelectionSet":
                  return ["{", i([s, t(s, _(P, $, D, "selections"))]), s, "}"];
                case "Field":
                  return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
                case "Name":
                  return T.value;
                case "StringValue": {
                  if (T.block) {
                    let m = T.value.replace(/"""/g, "\\$&").split(`
`);
                    return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
                  }
                  return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
                }
                case "IntValue":
                case "FloatValue":
                case "EnumValue":
                  return T.value;
                case "BooleanValue":
                  return T.value ? "true" : "false";
                case "NullValue":
                  return "null";
                case "Variable":
                  return ["$", D("name")];
                case "ListValue":
                  return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
                case "ObjectValue":
                  return u(["{", $.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
                case "ObjectField":
                case "Argument":
                  return [D("name"), ": ", D("value")];
                case "Directive":
                  return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : ""];
                case "NamedType":
                  return D("name");
                case "VariableDefinition":
                  return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
                case "ObjectTypeExtension":
                case "ObjectTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "FieldDefinition":
                  return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), F(P, D, T)];
                case "DirectiveDefinition":
                  return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
                case "EnumTypeExtension":
                case "EnumTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F(P, D, T), T.values.length > 0 ? [" {", i([s, t(s, _(P, $, D, "values"))]), s, "}"] : ""];
                case "EnumValueDefinition":
                  return [D("description"), T.description ? s : "", D("name"), F(P, D, T)];
                case "InputValueDefinition":
                  return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
                case "InputObjectTypeExtension":
                case "InputObjectTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "SchemaExtension":
                  return ["extend schema", F(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t(s, _(P, $, D, "operationTypes"))]), s, "}"] : []];
                case "SchemaDefinition":
                  return [D("description"), T.description ? s : "", "schema", F(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t(s, _(P, $, D, "operationTypes"))]) : "", s, "}"];
                case "OperationTypeDefinition":
                  return [D("operation"), ": ", D("type")];
                case "InterfaceTypeExtension":
                case "InterfaceTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "FragmentSpread":
                  return ["...", D("name"), F(P, D, T)];
                case "InlineFragment":
                  return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F(P, D, T), " ", D("selectionSet")];
                case "UnionTypeExtension":
                case "UnionTypeDefinition":
                  return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P.map(D, "types"))])] : ""])]);
                case "ScalarTypeExtension":
                case "ScalarTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F(P, D, T)];
                case "NonNullType":
                  return [D("type"), "!"];
                case "ListType":
                  return ["[", D("type"), "]"];
                default:
                  throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
              }
            }
            function F(P, $, D) {
              if (D.directives.length === 0)
                return "";
              let T = t(a, P.map($, "directives"));
              return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i([n, T]))];
            }
            function _(P, $, D, T) {
              return P.map((m, C, o) => {
                let d = D();
                return C < o.length - 1 && p($.originalText, m.getValue(), c) ? [d, s] : d;
              }, T);
            }
            function w(P) {
              return P.kind && P.kind !== "Comment";
            }
            function E(P) {
              let $ = P.getValue();
              if ($.kind === "Comment")
                return "#" + $.value.trimEnd();
              throw new Error("Not a comment: " + JSON.stringify($));
            }
            function N(P, $, D) {
              let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((d) => D(d), "interfaces");
              for (let d = 0; d < C.length; d++) {
                let v = C[d];
                m.push(o[d]);
                let S = C[d + 1];
                if (S) {
                  let b = $.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                  m.push(k === "," ? "," : " &", B ? a : " ");
                }
              }
              return m;
            }
            function x(P, $) {
              P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($.value = $.value.trim());
            }
            x.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
            function I(P) {
              var $;
              let D = P.getValue();
              return D == null || ($ = D.comments) === null || $ === void 0 ? void 0 : $.some((T) => T.value.trim() === "prettier-ignore");
            }
            r.exports = { print: f, massageAstNode: x, hasPrettierIgnore: I, insertPragma: h, printComment: E, canAttachComment: w };
          } }), ug = te({ "src/language-graphql/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { bracketSpacing: t.bracketSpacing };
          } }), sg = te({ "src/language-graphql/parsers.js"() {
            ne();
          } }), ig = te({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
            r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
          } }), ag = te({ "src/language-graphql/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = ng(), a = ug(), n = sg(), u = [t(ig(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
            r.exports = { languages: u, options: a, printers: i, parsers: n };
          } }), Po = te({ "node_modules/collapse-white-space/index.js"(e, r) {
            "use strict";
            ne(), r.exports = t;
            function t(s) {
              return String(s).replace(/\s+/g, " ");
            }
          } }), Io = te({ "src/language-markdown/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), og = te({ "src/language-markdown/constants.evaluate.js"(e, r) {
            r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
          } }), iu = te({ "src/language-markdown/utils.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t } = Ue(), { locStart: s, locEnd: a } = Io(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = og(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h = new RegExp(i);
            function g(E, N) {
              let x = "non-cjk", I = "cj-letter", P = "k-letter", $ = "cjk-punctuation", D = [], T = (N.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
              for (let [C, o] of T.entries()) {
                if (C % 2 === 1) {
                  D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                  continue;
                }
                if ((C === 0 || C === T.length - 1) && o === "")
                  continue;
                let d = o.split(new RegExp(`(${n})`));
                for (let [v, S] of d.entries())
                  if (!((v === 0 || v === d.length - 1) && S === "")) {
                    if (v % 2 === 0) {
                      S !== "" && m({ type: "word", value: S, kind: x, hasLeadingPunctuation: h.test(S[0]), hasTrailingPunctuation: h.test(t(S)) });
                      continue;
                    }
                    m(h.test(S) ? { type: "word", value: S, kind: $, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                  }
              }
              return D;
              function m(C) {
                let o = t(D);
                o && o.type === "word" && (o.kind === x && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d(x, $) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
                function d(v, S) {
                  return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
                }
              }
            }
            function c(E, N) {
              let [, x, I, P] = N.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
              return { numberText: x, marker: I, leadingSpaces: P };
            }
            function f(E, N) {
              if (!E.ordered || E.children.length < 2)
                return false;
              let x = Number(c(E.children[0], N.originalText).numberText), I = Number(c(E.children[1], N.originalText).numberText);
              if (x === 0 && E.children.length > 2) {
                let P = Number(c(E.children[2], N.originalText).numberText);
                return I === 1 && P === 1;
              }
              return I === 1;
            }
            function F(E, N) {
              let { value: x } = E;
              return E.position.end.offset === N.length && x.endsWith(`
`) && N.endsWith(`
`) ? x.slice(0, -1) : x;
            }
            function _(E, N) {
              return function x(I, P, $) {
                let D = Object.assign({}, N(I, P, $));
                return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$]))), D;
              }(E, null, []);
            }
            function w(E) {
              if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1)
                return false;
              let [N] = E.children;
              return s(E) === s(N) && a(E) === a(N);
            }
            r.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: F, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
          } }), lg = te({ "src/language-markdown/embed.js"(e, r) {
            "use strict";
            ne();
            var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe(), i = su(), { getFencedCodeBlockValue: l } = iu();
            function p(y, h, g, c) {
              let f = y.getValue();
              if (f.type === "code" && f.lang !== null) {
                let F = t(f.lang, c);
                if (F) {
                  let _ = c.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f.value, _) + 1)), E = { parser: F };
                  f.lang === "tsx" && (E.filepath = "dummy.tsx");
                  let N = g(l(f, c.originalText), E, { stripTrailingHardline: true });
                  return n([w, f.lang, f.meta ? " " + f.meta : "", a, u(N), a, w]);
                }
              }
              switch (f.type) {
                case "front-matter":
                  return i(f, g);
                case "importExport":
                  return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
                case "jsx":
                  return g(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
              }
              return null;
            }
            r.exports = p;
          } }), ko = te({ "src/language-markdown/pragma.js"(e, r) {
            "use strict";
            ne();
            var t = _o(), s = ["format", "prettier"];
            function a(n) {
              let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
              return (l == null ? void 0 : l.index) === 0;
            }
            r.exports = { startWithPragma: a, hasPragma: (n) => a(t(n).content.trimStart()), insertPragma: (n) => {
              let u = t(n), i = `<!-- @${s[0]} -->`;
              return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
            } };
          } }), cg = te({ "src/language-markdown/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { getOrderedListItemInfo: s, mapAst: a, splitText: n } = iu(), u = /^.$/su;
            function i(w, E) {
              return w = y(w, E), w = c(w), w = p(w, E), w = F(w, E), w = _(w, E), w = f(w, E), w = l(w), w = h(w), w;
            }
            function l(w) {
              return a(w, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
            }
            function p(w, E) {
              return a(w, (N) => N.type !== "inlineCode" || E.proseWrap === "preserve" ? N : Object.assign(Object.assign({}, N), {}, { value: N.value.replace(/\s+/g, " ") }));
            }
            function y(w, E) {
              return a(w, (N) => N.type !== "text" || N.value === "*" || N.value === "_" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, { value: E.originalText.slice(N.position.start.offset, N.position.end.offset) }));
            }
            function h(w) {
              return g(w, (E, N) => E.type === "importExport" && N.type === "importExport", (E, N) => ({ type: "importExport", value: E.value + `

` + N.value, position: { start: E.position.start, end: N.position.end } }));
            }
            function g(w, E, N) {
              return a(w, (x) => {
                if (!x.children)
                  return x;
                let I = x.children.reduce((P, $) => {
                  let D = t(P);
                  return D && E(D, $) ? P.splice(-1, 1, N(D, $)) : P.push($), P;
                }, []);
                return Object.assign(Object.assign({}, x), {}, { children: I });
              });
            }
            function c(w) {
              return g(w, (E, N) => E.type === "text" && N.type === "text", (E, N) => ({ type: "text", value: E.value + N.value, position: { start: E.position.start, end: N.position.end } }));
            }
            function f(w, E) {
              return a(w, (N, x, I) => {
                let [P] = I;
                if (N.type !== "text")
                  return N;
                let { value: $ } = N;
                return P.type === "paragraph" && (x === 0 && ($ = $.trimStart()), x === P.children.length - 1 && ($ = $.trimEnd())), { type: "sentence", position: N.position, children: n($, E) };
              });
            }
            function F(w, E) {
              return a(w, (N, x, I) => {
                if (N.type === "code") {
                  let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N.position.start.offset, N.position.end.offset));
                  if (N.isIndented = P, P)
                    for (let $ = 0; $ < I.length; $++) {
                      let D = I[$];
                      if (D.hasIndentedCodeblock)
                        break;
                      D.type === "list" && (D.hasIndentedCodeblock = true);
                    }
                }
                return N;
              });
            }
            function _(w, E) {
              return a(w, (I, P, $) => {
                if (I.type === "list" && I.children.length > 0) {
                  for (let D = 0; D < $.length; D++) {
                    let T = $[D];
                    if (T.type === "list" && !T.isAligned)
                      return I.isAligned = false, I;
                  }
                  I.isAligned = x(I);
                }
                return I;
              });
              function N(I) {
                return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
              }
              function x(I) {
                if (!I.ordered)
                  return true;
                let [P, $] = I.children;
                if (s(P, E.originalText).leadingSpaces.length > 1)
                  return true;
                let T = N(P);
                if (T === -1)
                  return false;
                if (I.children.length === 1)
                  return T % E.tabWidth === 0;
                let m = N($);
                return T !== m ? false : T % E.tabWidth === 0 ? true : s($, E.originalText).leadingSpaces.length > 1;
              }
            }
            r.exports = i;
          } }), pg = te({ "src/language-markdown/clean.js"(e, r) {
            "use strict";
            ne();
            var t = Po(), { isFrontMatterNode: s } = Ue(), { startWithPragma: a } = ko(), n = /* @__PURE__ */ new Set(["position", "raw"]);
            function u(i, l, p) {
              if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a(i.value)))
                return null;
            }
            u.ignoredProperties = n, r.exports = u;
          } }), fg = te({ "src/language-markdown/printer-markdown.js"(e, r) {
            "use strict";
            ne();
            var t = Po(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue(), { builders: { breakParent: l, join: p, line: y, literalline: h, markAsRoot: g, hardline: c, softline: f, ifBreak: F, fill: _, align: w, indent: E, group: N, hardlineWithoutBreakParent: x }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $ } } = qe(), D = lg(), { insertPragma: T } = ko(), { locStart: m, locEnd: C } = Io(), o = cg(), d = pg(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = iu(), q = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
            function Q(oe, H, pe) {
              let X = oe.getValue();
              if (ge(oe))
                return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe, le.value, H));
              switch (X.type) {
                case "front-matter":
                  return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                case "root":
                  return X.children.length === 0 ? "" : [I(de(oe, H, pe)), q.has(z(X).type) ? "" : c];
                case "paragraph":
                  return ue(oe, H, pe, { postprocessor: _ });
                case "sentence":
                  return ue(oe, H, pe);
                case "word": {
                  let le = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A, G, re, ye) => (G ? `${A}${G}` : `${re}${ye}`).replace(/_/g, "\\_")), Ae = (De, A, G) => De.type === "sentence" && G === 0, Ee = (De, A, G) => R(De.children[G - 1]);
                  return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A, G) => De.type === "emphasis" && G === 0, Ee)) && (le = le.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le;
                }
                case "whitespace": {
                  let le = oe.getParentNode(), Ae = le.children.indexOf(X), Ee = le.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
                  return W(oe, X.value, { proseWrap: De });
                }
                case "emphasis": {
                  let le;
                  if (R(X.children[0]))
                    le = H.originalText[X.position.start.offset];
                  else {
                    let Ae = oe.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A = Ae.children[Ee + 1];
                    le = De && De.type === "sentence" && De.children.length > 0 && s(De.children).type === "word" && !s(De.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce(oe, "emphasis") ? "*" : "_";
                  }
                  return [le, ue(oe, H, pe), le];
                }
                case "strong":
                  return ["**", ue(oe, H, pe), "**"];
                case "delete":
                  return ["~~", ue(oe, H, pe), "~~"];
                case "inlineCode": {
                  let le = a(X.value, "`"), Ae = "`".repeat(le || 1), Ee = le && !/^\s/.test(X.value) ? " " : "";
                  return [Ae, Ee, X.value, Ee, Ae];
                }
                case "wikiLink": {
                  let le = "";
                  return H.proseWrap === "preserve" ? le = X.value : le = X.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
                }
                case "link":
                  switch (H.originalText[X.position.start.offset]) {
                    case "<": {
                      let le = "mailto:";
                      return ["<", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, ">"];
                    }
                    case "[":
                      return ["[", ue(oe, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
                    default:
                      return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                  }
                case "image":
                  return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
                case "blockquote":
                  return ["> ", w("> ", ue(oe, H, pe))];
                case "heading":
                  return ["#".repeat(X.depth) + " ", ue(oe, H, pe)];
                case "code": {
                  if (X.isIndented) {
                    let Ee = " ".repeat(4);
                    return w(Ee, [Ee, ...P(X.value, c)]);
                  }
                  let le = H.__inJsTemplate ? "~" : "`", Ae = le.repeat(Math.max(3, n(X.value, le) + 1));
                  return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c, ...P(v(X, H.originalText), c), c, Ae];
                }
                case "html": {
                  let le = oe.getParentNode(), Ae = le.type === "root" && s(le.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
                  return P(Ae, Ee ? c : g(h));
                }
                case "list": {
                  let le = Y(X, oe.getParentNode()), Ae = S(X, H);
                  return ue(oe, H, pe, { processor: (Ee, De) => {
                    let A = re(), G = Ee.getValue();
                    if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column)
                      return [A, V(Ee, H, pe, A)];
                    return [A, w(" ".repeat(A.length), V(Ee, H, pe, A))];
                    function re() {
                      let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
                      return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;
                    }
                  } });
                }
                case "thematicBreak": {
                  let le = ee(oe, "list");
                  return le === -1 ? "---" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
                }
                case "linkReference":
                  return ["[", ue(oe, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
                case "imageReference":
                  switch (X.referenceType) {
                    case "full":
                      return ["![", X.alt || "", "]", Ne(X)];
                    default:
                      return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
                  }
                case "definition": {
                  let le = H.proseWrap === "always" ? y : " ";
                  return N([Ne(X), ":", E([le, he(X.url), X.title === null ? "" : [le, we(X.title, H, false)]])]);
                }
                case "footnote":
                  return ["[^", ue(oe, H, pe), "]"];
                case "footnoteReference":
                  return Pe(X);
                case "footnoteDefinition": {
                  let le = oe.getParentNode().children[oe.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
                  return [Pe(X), ": ", Ae ? ue(oe, H, pe) : N([w(" ".repeat(4), ue(oe, H, pe, { processor: (Ee, De) => De === 0 ? N([f, pe()]) : pe() })), le && le.type === "footnoteDefinition" ? f : ""])];
                }
                case "table":
                  return K(oe, H, pe);
                case "tableCell":
                  return ue(oe, H, pe);
                case "break":
                  return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(h)] : ["\\", c];
                case "liquidNode":
                  return P(X.value, c);
                case "importExport":
                  return [X.value, c];
                case "esComment":
                  return ["{/* ", X.value, " */}"];
                case "jsx":
                  return X.value;
                case "math":
                  return ["$$", c, X.value ? [...P(X.value, c), c] : "", "$$"];
                case "inlineMath":
                  return H.originalText.slice(m(X), C(X));
                case "tableRow":
                case "listItem":
                default:
                  throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
              }
            }
            function V(oe, H, pe, X) {
              let le = oe.getValue(), Ae = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
              return [Ae, ue(oe, H, pe, { processor: (Ee, De) => {
                if (De === 0 && Ee.getValue().type !== "list")
                  return w(" ".repeat(Ae.length), pe());
                let A = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
                return [A, w(A, pe())];
              } })];
            }
            function j(oe, H) {
              let pe = X();
              return oe + " ".repeat(pe >= 4 ? 0 : pe);
              function X() {
                let le = oe.length % H.tabWidth;
                return le === 0 ? 0 : H.tabWidth - le;
              }
            }
            function Y(oe, H) {
              return ie(oe, H, (pe) => pe.ordered === oe.ordered);
            }
            function ie(oe, H, pe) {
              let X = -1;
              for (let le of H.children)
                if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe)
                  return X;
            }
            function ee(oe, H) {
              let pe = Array.isArray(H) ? H : [H], X = -1, le;
              for (; le = oe.getParentNode(++X); )
                if (pe.includes(le.type))
                  return X;
              return -1;
            }
            function ce(oe, H) {
              let pe = ee(oe, H);
              return pe === -1 ? null : oe.getParentNode(pe);
            }
            function W(oe, H, pe) {
              if (pe.proseWrap === "preserve" && H === `
`)
                return c;
              let X = pe.proseWrap === "always" && !ce(oe, J);
              return H !== "" ? X ? y : " " : X ? f : "";
            }
            function K(oe, H, pe) {
              let X = oe.getValue(), le = [], Ae = oe.map((ye) => ye.map((Ce, Be) => {
                let ve = $(pe(), H).formatted, ze = u(ve);
                return le[Be] = Math.max(le[Be] || 3, ze), { text: ve, width: ze };
              }, "children"), "children"), Ee = A(false);
              if (H.proseWrap !== "never")
                return [l, Ee];
              let De = A(true);
              return [l, N(F(De, Ee))];
              function A(ye) {
                let Ce = [re(Ae[0], ye), G(ye)];
                return Ae.length > 1 && Ce.push(p(x, Ae.slice(1).map((Be) => re(Be, ye)))), p(x, Ce);
              }
              function G(ye) {
                return `| ${le.map((Be, ve) => {
                  let ze = X.align[ve], be = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye ? "-" : "-".repeat(Be - 2);
                  return `${be}${Se}${Ye}`;
                }).join(" | ")} |`;
              }
              function re(ye, Ce) {
                return `| ${ye.map((ve, ze) => {
                  let { text: be, width: Ye } = ve;
                  if (Ce)
                    return be;
                  let Se = le[ze] - Ye, Ie = X.align[ze], Oe = 0;
                  Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
                  let Je = Se - Oe;
                  return `${" ".repeat(Oe)}${be}${" ".repeat(Je)}`;
                }).join(" | ")} |`;
              }
            }
            function de(oe, H, pe) {
              let X = [], le = null, { children: Ae } = oe.getValue();
              for (let [Ee, De] of Ae.entries())
                switch (U(De)) {
                  case "start":
                    le === null && (le = { index: Ee, offset: De.position.end.offset });
                    break;
                  case "end":
                    le !== null && (X.push({ start: le, end: { index: Ee, offset: De.position.start.offset } }), le = null);
                    break;
                  default:
                    break;
                }
              return ue(oe, H, pe, { processor: (Ee, De) => {
                if (X.length > 0) {
                  let A = X[0];
                  if (De === A.start.index)
                    return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];
                  if (A.start.index < De && De < A.end.index)
                    return false;
                  if (De === A.end.index)
                    return X.shift(), false;
                }
                return pe();
              } });
            }
            function ue(oe, H, pe) {
              let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X, Ae = X.processor || (() => pe()), Ee = oe.getValue(), De = [], A;
              return oe.each((G, re) => {
                let ye = G.getValue(), Ce = Ae(G, re);
                if (Ce !== false) {
                  let Be = { parts: De, prevNode: A, parentNode: Ee, options: H };
                  Z(ye, Be) && (De.push(c), A && q.has(A.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c), fe(ye, Be) && De.push(c)), De.push(Ce), A = ye;
                }
              }, "children"), le ? le(De) : De;
            }
            function Fe(oe) {
              if (oe.type === "html")
                return oe.value;
              if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment")
                return ["{/* ", oe.children[0].value, " */}"];
            }
            function z(oe) {
              let H = oe;
              for (; i(H.children); )
                H = s(H.children);
              return H;
            }
            function U(oe) {
              let H;
              if (oe.type === "html")
                H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
              else {
                let pe;
                oe.type === "esComment" ? pe = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
              }
              return H ? H[1] || "next" : false;
            }
            function Z(oe, H) {
              let pe = H.parts.length === 0, X = k.includes(oe.type), le = oe.type === "html" && M.includes(H.parentNode.type);
              return !pe && !X && !le;
            }
            function se(oe, H) {
              var pe, X, le;
              let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U(H.prevNode) === "next", re = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye = oe.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
              return A || !(Ee || De || G || re || ye);
            }
            function fe(oe, H) {
              let pe = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
              return pe && X;
            }
            function ge(oe) {
              let H = ce(oe, ["linkReference", "imageReference"]);
              return H && (H.type !== "linkReference" || H.referenceType !== "full");
            }
            function he(oe) {
              let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
              return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
            }
            function we(oe, H) {
              let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              if (!oe)
                return "";
              if (pe)
                return " " + we(oe, H, false);
              if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")"))
                return `(${oe})`;
              let X = oe.split("'").length - 1, le = oe.split('"').length - 1, Ae = X > le ? '"' : le > X || H.singleQuote ? "'" : '"';
              return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe}${Ae}`;
            }
            function ke(oe, H, pe) {
              return oe < H ? H : oe > pe ? pe : oe;
            }
            function Re(oe) {
              let H = Number(oe.getName());
              if (H === 0)
                return false;
              let pe = oe.getParentNode().children[H - 1];
              return U(pe) === "next";
            }
            function Ne(oe) {
              return `[${t(oe.label)}]`;
            }
            function Pe(oe) {
              return `[^${oe.label}]`;
            }
            r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: d, hasPrettierIgnore: Re, insertPragma: T };
          } }), Dg = te({ "src/language-markdown/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
          } }), mg = te({ "src/language-markdown/parsers.js"() {
            ne();
          } }), _a3 = te({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
            r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
          } }), dg = te({ "src/language-markdown/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = fg(), a = Dg(), n = mg(), u = [t(_a3(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t(_a3(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
            r.exports = { languages: u, options: a, printers: i, parsers: n };
          } }), gg = te({ "src/language-html/clean.js"(e, r) {
            "use strict";
            ne();
            var { isFrontMatterNode: t } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
            function a(n, u) {
              if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml")
                return null;
              n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
            }
            a.ignoredProperties = s, r.exports = a;
          } }), yg = te({ "src/language-html/constants.evaluate.js"(e, r) {
            r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
          } }), hg = te({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
            }
            r.exports = t;
          } }), Rt = te({ "src/language-html/utils/index.js"(e, r) {
            "use strict";
            ne();
            var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue(), { builders: { line: a, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: g } = yg(), c = hg(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => F(_(A)), E = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N = (A) => E(_(A)), x = (A) => A.split(/[\t\n\f\r ]+/), I = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
              let [, G, re, ye] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
              return { leadingWhitespace: G, trailingWhitespace: ye, text: re };
            }, $ = (A) => /[\t\n\f\r ]/.test(A);
            function D(A, G) {
              return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se(A) && A.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
            }
            function T(A) {
              return A.type === "attribute" || !A.parent || !A.prev ? false : m(A.prev);
            }
            function m(A) {
              return A.type === "comment" && A.value.trim() === "prettier-ignore";
            }
            function C(A) {
              return A.type === "text" || A.type === "comment";
            }
            function o(A) {
              return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c(A) && (A.name === "script" || A.name === "style"));
            }
            function d(A) {
              return A.children && !o(A);
            }
            function v(A) {
              return o(A) || A.type === "interpolation" || S(A);
            }
            function S(A) {
              return we(A).startsWith("pre");
            }
            function b(A, G) {
              let re = ye();
              if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf)
                return A.type === "interpolation";
              return re;
              function ye() {
                return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U(A.prev.cssDisplay));
              }
            }
            function B(A, G) {
              return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
            }
            function k(A) {
              return Z(A.cssDisplay) && !o(A);
            }
            function M(A) {
              return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
            }
            function R(A) {
              return q(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
            }
            function q(A) {
              return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
            }
            function J(A) {
              return Y(A) || A.prev && L(A.prev) || Q(A);
            }
            function L(A) {
              return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
            }
            function Q(A) {
              return V(A) && j(A);
            }
            function V(A) {
              return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
            }
            function j(A) {
              return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
            }
            function Y(A) {
              switch (A.type) {
                case "ieConditionalComment":
                case "comment":
                case "directive":
                  return true;
                case "element":
                  return ["script", "select"].includes(A.name);
              }
              return false;
            }
            function ie(A) {
              return A.lastChild ? ie(A.lastChild) : A;
            }
            function ee(A) {
              return A.children && A.children.some((G) => G.type !== "text");
            }
            function ce(A) {
              let { type: G, lang: re } = A.attrMap;
              if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx")
                return "babel";
              if (G === "application/x-typescript" || re === "ts" || re === "tsx")
                return "typescript";
              if (G === "text/markdown")
                return "markdown";
              if (G === "text/html")
                return "html";
              if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
                return "json";
              if (G === "text/x-handlebars-template")
                return "glimmer";
            }
            function W(A, G) {
              let { lang: re } = A.attrMap;
              if (!re || re === "postcss" || re === "css")
                return "css";
              if (re === "scss")
                return "scss";
              if (re === "less")
                return "less";
              if (re === "stylus")
                return t("stylus", G);
            }
            function K(A, G) {
              if (A.name === "script" && !A.attrMap.src)
                return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce(A);
              if (A.name === "style")
                return W(A, G);
              if (G && X(A, G))
                return ce(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
            }
            function de(A) {
              return A === "block" || A === "list-item" || A.startsWith("table");
            }
            function ue(A) {
              return !de(A) && A !== "inline-block";
            }
            function Fe(A) {
              return !de(A) && A !== "inline-block";
            }
            function z(A) {
              return !de(A);
            }
            function U(A) {
              return !de(A);
            }
            function Z(A) {
              return !de(A) && A !== "inline-block";
            }
            function se(A) {
              return we(A).startsWith("pre");
            }
            function fe(A, G) {
              let re = 0;
              for (let ye = A.stack.length - 1; ye >= 0; ye--) {
                let Ce = A.stack[ye];
                Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re++;
              }
              return re;
            }
            function ge(A, G) {
              let re = A;
              for (; re; ) {
                if (G(re))
                  return true;
                re = re.parent;
              }
              return false;
            }
            function he(A, G) {
              if (A.prev && A.prev.type === "comment") {
                let ye = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                if (ye)
                  return ye[1];
              }
              let re = false;
              if (A.type === "element" && A.namespace === "svg")
                if (ge(A, (ye) => ye.fullName === "svg:foreignObject"))
                  re = true;
                else
                  return A.name === "svg" ? "inline-block" : "block";
              switch (G.htmlWhitespaceSensitivity) {
                case "strict":
                  return "inline";
                case "ignore":
                  return "block";
                default:
                  return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re || c(A)) && p[A.name] || y;
              }
            }
            function we(A) {
              return A.type === "element" && (!A.namespace || c(A)) && h[A.name] || g;
            }
            function ke(A) {
              let G = Number.POSITIVE_INFINITY;
              for (let re of A.split(`
`)) {
                if (re.length === 0)
                  continue;
                if (!f.has(re[0]))
                  return 0;
                let ye = I(re).length;
                re.length !== ye && ye < G && (G = ye);
              }
              return G === Number.POSITIVE_INFINITY ? 0 : G;
            }
            function Re(A) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);
              return G === 0 ? A : A.split(`
`).map((re) => re.slice(G)).join(`
`);
            }
            function Ne(A, G) {
              let re = 0;
              for (let ye = 0; ye < A.length; ye++)
                A[ye] === G && re++;
              return re;
            }
            function Pe(A) {
              return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            }
            var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
            function H(A, G) {
              return pe(A, G) && !oe.has(A.fullName);
            }
            function pe(A, G) {
              return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
            }
            function X(A, G) {
              return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
            }
            function le(A) {
              let G = A.fullName;
              return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
            }
            function Ae(A, G) {
              let re = A.parent;
              if (!pe(re, G))
                return false;
              let ye = re.fullName, Ce = A.fullName;
              return ye === "script" && Ce === "setup" || ye === "style" && Ce === "vars";
            }
            function Ee(A) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
              return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n) : i(u(a, x(G)));
            }
            function De(A, G) {
              return pe(A, G) && A.name === "script";
            }
            r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N, hasHtmlWhitespace: $, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe, getTextValueParts: Ee };
          } }), vg = te({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
            function r(i) {
              return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
            }
            e.isWhitespace = r;
            function t(i) {
              return e.$0 <= i && i <= e.$9;
            }
            e.isDigit = t;
            function s(i) {
              return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
            }
            e.isAsciiLetter = s;
            function a(i) {
              return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
            }
            e.isAsciiHexDigit = a;
            function n(i) {
              return i === e.$LF || i === e.$CR;
            }
            e.isNewLine = n;
            function u(i) {
              return e.$0 <= i && i <= e.$7;
            }
            e.isOctalDigit = u;
          } }), Cg = te({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = class {
              constructor(s, a, n) {
                this.filePath = s, this.name = a, this.members = n;
              }
              assertNoMembers() {
                if (this.members.length)
                  throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
              }
            };
            e.StaticSymbol = r;
            var t = class {
              constructor() {
                this.cache = /* @__PURE__ */ new Map();
              }
              get(s, a, n) {
                n = n || [];
                let u = n.length ? `.${n.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
                return l || (l = new r(s, a, n), this.cache.set(i, l)), l;
              }
            };
            e.StaticSymbolCache = t;
          } }), Eg = te({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = /-+([a-z0-9])/g;
            function t(o) {
              return o.replace(r, function() {
                for (var d = arguments.length, v = new Array(d), S = 0; S < d; S++)
                  v[S] = arguments[S];
                return v[1].toUpperCase();
              });
            }
            e.dashCaseToCamelCase = t;
            function s(o, d) {
              return n(o, ":", d);
            }
            e.splitAtColon = s;
            function a(o, d) {
              return n(o, ".", d);
            }
            e.splitAtPeriod = a;
            function n(o, d, v) {
              let S = o.indexOf(d);
              return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
            }
            function u(o, d, v) {
              return Array.isArray(o) ? d.visitArray(o, v) : E(o) ? d.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, v) : d.visitOther(o, v);
            }
            e.visitValue = u;
            function i(o) {
              return o != null;
            }
            e.isDefined = i;
            function l(o) {
              return o === void 0 ? null : o;
            }
            e.noUndefined = l;
            var p = class {
              visitArray(o, d) {
                return o.map((v) => u(v, this, d));
              }
              visitStringMap(o, d) {
                let v = {};
                return Object.keys(o).forEach((S) => {
                  v[S] = u(o[S], this, d);
                }), v;
              }
              visitPrimitive(o, d) {
                return o;
              }
              visitOther(o, d) {
                return o;
              }
            };
            e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
              if (P(o))
                throw new Error("Illegal state: value cannot be a promise");
              return o;
            }, then: (o, d) => P(o) ? o.then(d) : d(o), all: (o) => o.some(P) ? Promise.all(o) : o };
            function y(o) {
              throw new Error(`Internal Error: ${o}`);
            }
            e.error = y;
            function h(o, d) {
              let v = Error(o);
              return v[g] = true, d && (v[c] = d), v;
            }
            e.syntaxError = h;
            var g = "ngSyntaxError", c = "ngParseErrors";
            function f(o) {
              return o[g];
            }
            e.isSyntaxError = f;
            function F(o) {
              return o[c] || [];
            }
            e.getParseErrors = F;
            function _(o) {
              return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
            }
            e.escapeRegExp = _;
            var w = Object.getPrototypeOf({});
            function E(o) {
              return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
            }
            function N(o) {
              let d = "";
              for (let v = 0; v < o.length; v++) {
                let S = o.charCodeAt(v);
                if (S >= 55296 && S <= 56319 && o.length > v + 1) {
                  let b = o.charCodeAt(v + 1);
                  b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
                }
                S <= 127 ? d += String.fromCharCode(S) : S <= 2047 ? d += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
              }
              return d;
            }
            e.utf8Encode = N;
            function x(o) {
              if (typeof o == "string")
                return o;
              if (o instanceof Array)
                return "[" + o.map(x).join(", ") + "]";
              if (o == null)
                return "" + o;
              if (o.overriddenName)
                return `${o.overriddenName}`;
              if (o.name)
                return `${o.name}`;
              if (!o.toString)
                return "object";
              let d = o.toString();
              if (d == null)
                return "" + d;
              let v = d.indexOf(`
`);
              return v === -1 ? d : d.substring(0, v);
            }
            e.stringify = x;
            function I(o) {
              return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
            }
            e.resolveForwardRef = I;
            function P(o) {
              return !!o && typeof o.then == "function";
            }
            e.isPromise = P;
            var $ = class {
              constructor(o) {
                this.full = o;
                let d = o.split(".");
                this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
              }
            };
            e.Version = $;
            var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
            e.global = C;
          } }), Fg = te({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Cg(), t = Eg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
            function a(v) {
              return v.replace(/\W/g, "_");
            }
            e.sanitizeIdentifier = a;
            var n = 0;
            function u(v) {
              if (!v || !v.reference)
                return null;
              let S = v.reference;
              if (S instanceof r.StaticSymbol)
                return S.name;
              if (S.__anonymousType)
                return S.__anonymousType;
              let b = t.stringify(S);
              return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a(b), b;
            }
            e.identifierName = u;
            function i(v) {
              let S = v.reference;
              return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
            }
            e.identifierModuleUrl = i;
            function l(v, S) {
              return `View_${u({ reference: v })}_${S}`;
            }
            e.viewClassName = l;
            function p(v) {
              return `RenderType_${u({ reference: v })}`;
            }
            e.rendererTypeName = p;
            function y(v) {
              return `HostView_${u({ reference: v })}`;
            }
            e.hostViewClassName = y;
            function h(v) {
              return `${u({ reference: v })}NgFactory`;
            }
            e.componentFactoryName = h;
            var g;
            (function(v) {
              v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
            })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
            function c(v) {
              return v.value != null ? a(v.value) : u(v.identifier);
            }
            e.tokenName = c;
            function f(v) {
              return v.identifier != null ? v.identifier.reference : v.value;
            }
            e.tokenReference = f;
            var F = class {
              constructor() {
                let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
              }
            };
            e.CompileStylesheetMetadata = F;
            var _ = class {
              constructor(v) {
                let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v;
                if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2)
                  throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
              }
              toSummary() {
                return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
              }
            };
            e.CompileTemplateMetadata = _;
            var w = class {
              static create(v) {
                let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
                L != null && Object.keys(L).forEach((se) => {
                  let fe = L[se], ge = se.match(s);
                  ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
                });
                let U = {};
                q != null && q.forEach((se) => {
                  let fe = t.splitAtColon(se, [se, se]);
                  U[fe[0]] = fe[1];
                });
                let Z = {};
                return J != null && J.forEach((se) => {
                  let fe = t.splitAtColon(se, [se, se]);
                  Z[fe[0]] = fe[1];
                }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
              }
              constructor(v) {
                let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
                this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
              }
              toSummary() {
                return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
              }
            };
            e.CompileDirectiveMetadata = w;
            var E = class {
              constructor(v) {
                let { type: S, name: b, pure: B } = v;
                this.type = S, this.name = b, this.pure = !!B;
              }
              toSummary() {
                return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
              }
            };
            e.CompilePipeMetadata = E;
            var N = class {
            };
            e.CompileShallowModuleMetadata = N;
            var x = class {
              constructor(v) {
                let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v;
                this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
              }
              toSummary() {
                let v = this.transitiveModule;
                return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
              }
            };
            e.CompileNgModuleMetadata = x;
            var I = class {
              constructor() {
                this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
              }
              addProvider(v, S) {
                this.providers.push({ provider: v, module: S });
              }
              addDirective(v) {
                this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
              }
              addExportedDirective(v) {
                this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
              }
              addPipe(v) {
                this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
              }
              addExportedPipe(v) {
                this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
              }
              addModule(v) {
                this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
              }
              addEntryComponent(v) {
                this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
              }
            };
            e.TransitiveCompileNgModuleMetadata = I;
            function P(v) {
              return v || [];
            }
            var $ = class {
              constructor(v, S) {
                let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q } = S;
                this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q;
              }
            };
            e.ProviderMeta = $;
            function D(v) {
              return v.reduce((S, b) => {
                let B = Array.isArray(b) ? D(b) : b;
                return S.concat(B);
              }, []);
            }
            e.flatten = D;
            function T(v) {
              return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
            }
            function m(v, S, b) {
              let B;
              return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
            }
            e.templateSourceUrl = m;
            function C(v, S) {
              let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
              return T(`css/${S}${B}.ngstyle.js`);
            }
            e.sharedStylesheetJitUrl = C;
            function o(v) {
              return T(`${u(v.type)}/module.ngfactory.js`);
            }
            e.ngModuleJitUrl = o;
            function d(v, S) {
              return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
            }
            e.templateJitUrl = d;
          } }), Ag = te({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = vg(), t = Fg(), s = class {
              constructor(y, h, g, c) {
                this.file = y, this.offset = h, this.line = g, this.col = c;
              }
              toString() {
                return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
              }
              moveBy(y) {
                let h = this.file.content, g = h.length, c = this.offset, f = this.line, F = this.col;
                for (; c > 0 && y < 0; )
                  if (c--, y++, h.charCodeAt(c) == r.$LF) {
                    f--;
                    let w = h.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
                    F = w > 0 ? c - w : c;
                  } else
                    F--;
                for (; c < g && y > 0; ) {
                  let _ = h.charCodeAt(c);
                  c++, y--, _ == r.$LF ? (f++, F = 0) : F++;
                }
                return new s(this.file, c, f, F);
              }
              getContext(y, h) {
                let g = this.file.content, c = this.offset;
                if (c != null) {
                  c > g.length - 1 && (c = g.length - 1);
                  let f = c, F = 0, _ = 0;
                  for (; F < y && c > 0 && (c--, F++, !(g[c] == `
` && ++_ == h)); )
                    ;
                  for (F = 0, _ = 0; F < y && f < g.length - 1 && (f++, F++, !(g[f] == `
` && ++_ == h)); )
                    ;
                  return { before: g.substring(c, this.offset), after: g.substring(this.offset, f + 1) };
                }
                return null;
              }
            };
            e.ParseLocation = s;
            var a = class {
              constructor(y, h) {
                this.content = y, this.url = h;
              }
            };
            e.ParseSourceFile = a;
            var n = class {
              constructor(y, h) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                this.start = y, this.end = h, this.details = g;
              }
              toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            };
            e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
            var u;
            (function(y) {
              y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
            })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
            var i = class {
              constructor(y, h) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
                this.span = y, this.msg = h, this.level = g;
              }
              contextualMessage() {
                let y = this.span.start.getContext(100, 3);
                return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
              }
              toString() {
                let y = this.span.details ? `, ${this.span.details}` : "";
                return `${this.contextualMessage()}: ${this.span.start}${y}`;
              }
            };
            e.ParseError = i;
            function l(y, h) {
              let g = t.identifierModuleUrl(h), c = g != null ? `in ${y} ${t.identifierName(h)} in ${g}` : `in ${y} ${t.identifierName(h)}`, f = new a("", c);
              return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.typeSourceSpan = l;
            function p(y, h, g) {
              let c = `in ${y} ${h} in ${g}`, f = new a("", c);
              return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
            }
            e.r3JitTypeSourceSpan = p;
          } }), Sg = te({ "src/language-html/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var { ParseSourceSpan: t } = Ag(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: g, isVueScriptTag: c } = Rt(), f = [_, w, N, I, P, T, $, D, m, x, C];
            function F(o, d) {
              for (let v of f)
                v(o, d);
              return o;
            }
            function _(o) {
              o.walk((d) => {
                if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                  let v = d.children[0];
                  v.value.length === 1 ? d.removeChild(v) : v.value = v.value.slice(1);
                }
              });
            }
            function w(o) {
              let d = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
              o.walk((v) => {
                if (v.children)
                  for (let S = 0; S < v.children.length; S++) {
                    let b = v.children[S];
                    if (!d(b))
                      continue;
                    let B = b.prev, k = b.firstChild;
                    v.removeChild(B), S--;
                    let M = new t(B.sourceSpan.start, k.sourceSpan.end), R = new t(M.start, b.sourceSpan.end);
                    b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
                  }
              });
            }
            function E(o, d, v) {
              o.walk((S) => {
                if (S.children)
                  for (let b = 0; b < S.children.length; b++) {
                    let B = S.children[b];
                    if (B.type !== "text" && !d(B))
                      continue;
                    B.type !== "text" && (B.type = "text", B.value = v(B));
                    let k = B.prev;
                    !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
                  }
              });
            }
            function N(o) {
              return E(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
            }
            function x(o) {
              let d = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
              o.walk((v) => {
                if (v.children)
                  for (let S = 0; S < v.children.length; S++) {
                    let b = v.children[S];
                    if (!d(b))
                      continue;
                    let B = b.prev, k = b.next;
                    B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
                  }
              });
            }
            function I(o, d) {
              if (d.parser === "html")
                return;
              let v = /{{(.+?)}}/s;
              o.walk((S) => {
                if (u(S))
                  for (let b of S.children) {
                    if (b.type !== "text")
                      continue;
                    let B = b.sourceSpan.start, k = null, M = b.value.split(v);
                    for (let R = 0; R < M.length; R++, B = k) {
                      let q = M[R];
                      if (R % 2 === 0) {
                        k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(B, k) });
                        continue;
                      }
                      k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
                    }
                    S.removeChild(b);
                  }
              });
            }
            function P(o) {
              o.walk((d) => {
                if (!d.children)
                  return;
                if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s(d.children[0].value).length === 0) {
                  d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                  return;
                }
                let v = g(d), S = p(d);
                if (!v)
                  for (let b = 0; b < d.children.length; b++) {
                    let B = d.children[b];
                    if (B.type !== "text")
                      continue;
                    let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a(B.value), q = B.prev, J = B.next;
                    M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(B), b--, (k || R) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                  }
                d.isWhitespaceSensitive = v, d.isIndentationSensitive = S;
              });
            }
            function $(o) {
              o.walk((d) => {
                d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
              });
            }
            function D(o, d) {
              o.walk((v) => {
                v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
              });
            }
            function T(o, d) {
              o.walk((v) => {
                v.cssDisplay = i(v, d);
              });
            }
            function m(o, d) {
              o.walk((v) => {
                let { children: S } = v;
                if (S) {
                  if (S.length === 0) {
                    v.isDanglingSpaceSensitive = l(v);
                    return;
                  }
                  for (let b of S)
                    b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h(b, d);
                  for (let b = 0; b < S.length; b++) {
                    let B = S[b];
                    B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                  }
                }
              });
            }
            function C(o, d) {
              if (d.parser === "vue") {
                let v = o.children.find((b) => c(b, d));
                if (!v)
                  return;
                let { lang: S } = v.attrMap;
                (S === "ts" || S === "typescript") && (d.__should_parse_vue_template_with_ts = true);
              }
            }
            r.exports = F;
          } }), xg = te({ "src/language-html/pragma.js"(e, r) {
            "use strict";
            ne();
            function t(a) {
              return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
            }
            function s(a) {
              return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
            }
            r.exports = { hasPragma: t, insertPragma: s };
          } }), au = te({ "src/language-html/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a) {
              return a.sourceSpan.start.offset;
            }
            function s(a) {
              return a.sourceSpan.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), ur = te({ "src/language-html/print/tag.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: y, locEnd: h } = au(), { isTextLikeNode: g, getLastDescendant: c, isPreLikeNode: f, hasPrettierIgnore: F, shouldPreserveContent: _, isVueSfcBlock: w } = Rt();
            function E(L, Q) {
              return [L.isSelfClosing ? "" : N(L, Q), x(L, Q)];
            }
            function N(L, Q) {
              return L.lastChild && o(L.lastChild) ? "" : [I(L, Q), $(L, Q)];
            }
            function x(L, Q) {
              return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
            }
            function I(L, Q) {
              return C(L) ? D(L.lastChild, Q) : "";
            }
            function P(L, Q) {
              return o(L) ? $(L.parent, Q) : d(L) ? q(L.next) : "";
            }
            function $(L, Q) {
              if (t(!L.isSelfClosing), T(L, Q))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                  return "<!";
                case "element":
                  if (L.hasHtmComponentClosingTag)
                    return "<//";
                default:
                  return `</${L.rawName}`;
              }
            }
            function D(L, Q) {
              if (T(L, Q))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalEndComment":
                  return "[endif]-->";
                case "ieConditionalStartComment":
                  return "]><!-->";
                case "interpolation":
                  return "}}";
                case "element":
                  if (L.isSelfClosing)
                    return "/>";
                default:
                  return ">";
              }
            }
            function T(L, Q) {
              return !L.isSelfClosing && !L.endSourceSpan && (F(L) || _(L.parent, Q));
            }
            function m(L) {
              return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function C(L) {
              return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c(L.lastChild)) && !f(L);
            }
            function o(L) {
              return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c(L));
            }
            function d(L) {
              return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
            }
            function v(L) {
              let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
              return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
            }
            function S(L) {
              return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function b(L, Q, V) {
              let j = L.getValue();
              if (!s(j.attrs))
                return j.isSelfClosing ? " " : "";
              let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
                let Fe = ue.getValue();
                return ie(Fe) ? p(Q.originalText.slice(y(Fe), h(Fe))) : V();
              }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a([ce ? " " : u, n(K, ee)])];
              return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
            }
            function B(L) {
              return L.firstChild && S(L.firstChild) ? "" : J(L);
            }
            function k(L, Q, V) {
              let j = L.getValue();
              return [M(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
            }
            function M(L, Q) {
              return L.prev && d(L.prev) ? "" : [R(L, Q), q(L)];
            }
            function R(L, Q) {
              return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : "";
            }
            function q(L) {
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalStartComment":
                  return `<!--[if ${L.condition}`;
                case "ieConditionalEndComment":
                  return "<!--<!";
                case "interpolation":
                  return "{{";
                case "docType":
                  return "<!DOCTYPE";
                case "element":
                  if (L.condition)
                    return `<!--[if ${L.condition}]><!--><${L.rawName}`;
                default:
                  return `<${L.rawName}`;
              }
            }
            function J(L) {
              switch (t(!L.isSelfClosing), L.type) {
                case "ieConditionalComment":
                  return "]>";
                case "element":
                  if (L.condition)
                    return "><!--<![endif]-->";
                default:
                  return ">";
              }
            }
            r.exports = { printClosingTag: E, printClosingTagStart: N, printClosingTagStartMarker: $, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: S };
          } }), bg = te({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
            ne(), function(t, s) {
              typeof define == "function" && define.amd ? define([], s) : typeof r == "object" && r.exports ? r.exports = s() : t.parseSrcset = s();
            }(e, function() {
              return function(t, s) {
                var a = s && s.logger || console;
                function n($) {
                  return $ === " " || $ === "	" || $ === `
` || $ === "\f" || $ === "\r";
                }
                function u($) {
                  var D, T = $.exec(t.substring(N));
                  if (T)
                    return D = T[0], N += D.length, D;
                }
                for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, g = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, F, _, w, E, N = 0, x = []; ; ) {
                  if (u(p), N >= i)
                    return x;
                  f = u(y), F = [], f.slice(-1) === "," ? (f = f.replace(h, ""), P()) : I();
                }
                function I() {
                  for (u(l), _ = "", w = "in descriptor"; ; ) {
                    if (E = t.charAt(N), w === "in descriptor")
                      if (n(E))
                        _ && (F.push(_), _ = "", w = "after descriptor");
                      else if (E === ",") {
                        N += 1, _ && F.push(_), P();
                        return;
                      } else if (E === "(")
                        _ = _ + E, w = "in parens";
                      else if (E === "") {
                        _ && F.push(_), P();
                        return;
                      } else
                        _ = _ + E;
                    else if (w === "in parens")
                      if (E === ")")
                        _ = _ + E, w = "in descriptor";
                      else if (E === "") {
                        F.push(_), P();
                        return;
                      } else
                        _ = _ + E;
                    else if (w === "after descriptor" && !n(E))
                      if (E === "") {
                        P();
                        return;
                      } else
                        w = "in descriptor", N -= 1;
                    N += 1;
                  }
                }
                function P() {
                  var $ = false, D, T, m, C, o = {}, d, v, S, b, B;
                  for (C = 0; C < F.length; C++)
                    d = F[C], v = d[d.length - 1], S = d.substring(0, d.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($ = true), b === 0 ? $ = true : D = b) : c.test(S) && v === "x" ? ((D || T || m) && ($ = true), B < 0 ? $ = true : T = B) : g.test(S) && v === "h" ? ((m || T) && ($ = true), b === 0 ? $ = true : m = b) : $ = true;
                  $ ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + d + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));
                }
              };
            });
          } }), Tg = te({ "src/language-html/syntax-attribute.js"(e, r) {
            "use strict";
            ne();
            var t = bg(), { builders: { ifBreak: s, join: a, line: n } } = qe();
            function u(l) {
              let p = t(l, { logger: { error(I) {
                throw new Error(I);
              } } }), y = p.some((I) => {
                let { w: P } = I;
                return P;
              }), h = p.some((I) => {
                let { h: P } = I;
                return P;
              }), g = p.some((I) => {
                let { d: P } = I;
                return P;
              });
              if (y + h + g > 1)
                throw new Error("Mixed descriptor in srcset is not supported");
              let c = y ? "w" : h ? "h" : "d", f = y ? "w" : h ? "h" : "x", F = (I) => Math.max(...I), _ = p.map((I) => I.url), w = F(_.map((I) => I.length)), E = p.map((I) => I[c]).map((I) => I ? I.toString() : ""), N = E.map((I) => {
                let P = I.indexOf(".");
                return P === -1 ? I.length : P;
              }), x = F(N);
              return a([",", n], _.map((I, P) => {
                let $ = [I], D = E[P];
                if (D) {
                  let T = w - I.length + 1, m = x - N[P], C = " ".repeat(T + m);
                  $.push(s(C, " "), D + f);
                }
                return $;
              }));
            }
            function i(l) {
              return l.trim().split(/\s+/).join(" ");
            }
            r.exports = { printImgSrcset: u, printClassNames: i };
          } }), Bg = te({ "src/language-html/syntax-vue.js"(e, r) {
            "use strict";
            ne();
            var { builders: { group: t } } = qe();
            function s(i, l) {
              let { left: p, operator: y, right: h } = a(i);
              return [t(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
            }
            function a(i) {
              let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h = i.match(l);
              if (!h)
                return;
              let g = {};
              if (g.for = h[3].trim(), !g.for)
                return;
              let c = h[1].trim().replace(y, ""), f = c.match(p);
              f ? (g.alias = c.replace(p, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c;
              let F = [g.alias, g.iterator1, g.iterator2];
              if (!F.some((_, w) => !_ && (w === 0 || F.slice(w + 1).some(Boolean))))
                return { left: F.filter(Boolean).join(","), operator: h[2], right: g.for };
            }
            function n(i, l) {
              return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
            }
            function u(i) {
              let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
              return l.test(y) || p.test(y);
            }
            r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n };
          } }), Lo = te({ "src/language-html/get-node-content.js"(e, r) {
            "use strict";
            ne();
            var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = ur();
            function l(p, y) {
              let h = p.startSourceSpan.end.offset;
              p.firstChild && u(p.firstChild) && (h -= i(p).length);
              let g = p.endSourceSpan.start.offset;
              return p.lastChild && t(p.lastChild) ? g += s(p, y).length : a(p) && (g -= n(p.lastChild, y).length), y.originalText.slice(h, g);
            }
            r.exports = l;
          } }), Ng = te({ "src/language-html/embed.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, group: s, hardline: a, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: y } } = qe(), h = su(), { printClosingTag: g, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: F, printOpeningTag: _ } = ur(), { printImgSrcset: w, printClassNames: E } = Tg(), { printVueFor: N, printVueBindings: x, isVueEventBindingExpression: I } = Bg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: v } = Rt(), S = Lo();
            function b(k, M, R) {
              let q = (ee) => new RegExp(ee.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee, ce) => {
                let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
                W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
              }, V = (ee) => s(ee), j = function(ee) {
                let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                return s([n([l, ee]), ce ? l : ""]);
              }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce));
              if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
                return j(w(J()));
              if (k.fullName === "class" && !R.parentParser) {
                let ee = J();
                if (!ee.includes("{{"))
                  return E(ee);
              }
              if (k.fullName === "style" && !R.parentParser) {
                let ee = J();
                if (!ee.includes("{{"))
                  return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
              }
              if (R.parser === "vue") {
                if (k.fullName === "v-for")
                  return N(J(), ie);
                if (o(k) || d(k, R))
                  return x(J(), ie);
                let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
                if (q(ee)) {
                  let K = J(), de = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                  return Y(ie(K, { parser: de }));
                }
                if (q(ce))
                  return Y(ie(J(), { parser: "__vue_expression" }));
                if (q(W))
                  return Y(ie(J(), { parser: "__js_expression" }));
              }
              if (R.parser === "angular") {
                let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
                if (q(W))
                  return Y(ee(J(), { parser: "__ng_action" }));
                if (q(K))
                  return Y(ee(J(), { parser: "__ng_binding" }));
                if (q(de)) {
                  let z = J().trim();
                  return j(i(v(k, z)), !z.includes("@@"));
                }
                if (q(ce))
                  return Y(ee(J(), { parser: "__ng_directive" }));
                let ue = /{{(.+?)}}/s, Fe = J();
                if (ue.test(Fe)) {
                  let z = [];
                  for (let [U, Z] of Fe.split(ue).entries())
                    if (U % 2 === 0)
                      z.push(y(Z));
                    else
                      try {
                        z.push(s(["{{", n([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                      } catch {
                        z.push("{{", y(Z), "}}");
                      }
                  return s(z);
                }
              }
              return null;
            }
            function B(k, M, R, q) {
              let J = k.getValue();
              switch (J.type) {
                case "element": {
                  if (P(J) || J.type === "interpolation")
                    return;
                  if (!J.isSelfClosing && $(J, q)) {
                    let L = D(J, q);
                    if (!L)
                      return;
                    let Q = S(J, q), V = /^\s*$/.test(Q), j = "";
                    return V || (j = R(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [F(J, q), s(_(k, q, M)), V ? "" : a, j, V ? "" : a, g(J, q), c(J, q)];
                  }
                  break;
                }
                case "text": {
                  if (P(J.parent)) {
                    let L = D(J.parent, q);
                    if (L) {
                      let Q = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                      if (q.parser === "html" && L === "babel") {
                        let j = "script", { attrMap: Y } = J.parent;
                        Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
                      }
                      return [t, F(J, q), R(Q, V, { stripTrailingHardline: true }), c(J, q)];
                    }
                  } else if (J.parent.type === "interpolation") {
                    let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                    return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
                  }
                  break;
                }
                case "attribute": {
                  if (!J.value)
                    break;
                  if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  let L = b(J, (Q, V) => R(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                  if (L)
                    return [J.rawName, '="', s(p(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
                  break;
                }
                case "front-matter":
                  return h(J, R);
              }
            }
            r.exports = B;
          } }), Oo = te({ "src/language-html/print/children.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, group: s, ifBreak: a, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: y } = au(), { forceBreakChildren: h, forceNextEmptyLine: g, isTextLikeNode: c, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: F } = Rt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N, printClosingTagEndMarker: x, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = ur();
            function $(m, C, o) {
              let d = m.getValue();
              return f(d) ? [_(d, C), ...l(C.originalText.slice(p(d) + (d.prev && w(d.prev) ? E(d).length : 0), y(d) - (d.next && N(d.next) ? x(d, C).length : 0))), I(d, C)] : o();
            }
            function D(m, C) {
              return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F(C) ? i : n : "" : F(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N(C) ? "" : !C.isLeadingSpaceSensitive || F(C) || N(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
            }
            function T(m, C, o) {
              let d = m.getValue();
              if (h(d))
                return [t, ...m.map((S) => {
                  let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
                  return [B ? [B, g(b.prev) ? i : ""] : "", $(S, C, o)];
                }, "children")];
              let v = d.children.map(() => Symbol(""));
              return m.map((S, b) => {
                let B = S.getValue();
                if (c(B)) {
                  if (B.prev && c(B.prev)) {
                    let Q = D(B.prev, B);
                    if (Q)
                      return g(B.prev) ? [i, i, $(S, C, o)] : [Q, $(S, C, o)];
                  }
                  return $(S, C, o);
                }
                let k = [], M = [], R = [], q = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
                return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c(B.prev) ? M.push(J) : M.push(a("", u, { groupId: v[b - 1] }))), L && (g(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R.push(L)), [...k, s([...M, s([$(S, C, o), ...R], { id: v[b] })]), ...q];
              }, "children");
            }
            r.exports = { printChildren: T };
          } }), wg = te({ "src/language-html/print/element.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = Lo(), { shouldPreserveContent: g, isScriptLikeTag: c, isVueCustomBlock: f, countParents: F, forceBreakContent: _ } = Rt(), { printOpeningTagPrefix: w, printOpeningTag: E, printClosingTagSuffix: N, printClosingTag: x, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = ur(), { printChildren: $ } = Oo();
            function D(T, m, C) {
              let o = T.getValue();
              if (g(o, m))
                return [w(o, m), a(E(T, m, C)), ...y(h(o, m)), ...x(o, m), N(o, m)];
              let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a([a(E(T, m, C), { id: v }), M, x(o, m)]), b = (M) => d ? u(M, { groupId: v }) : (c(o) || f(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M : i(M), B = () => d ? n(p, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? n(p, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * F(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
              return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $(T, m, C)]), k()]);
            }
            r.exports = { printElement: D };
          } }), _g = te({ "src/language-html/printer-html.js"(e, r) {
            "use strict";
            ne();
            var { builders: { fill: t, group: s, hardline: a, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe(), y = gg(), { countChars: h, unescapeQuoteEntities: g, getTextValueParts: c } = Rt(), f = Sg(), { insertPragma: F } = xg(), { locStart: _, locEnd: w } = au(), E = Ng(), { printClosingTagSuffix: N, printClosingTagEnd: x, printOpeningTagPrefix: I, printOpeningTagStart: P } = ur(), { printElement: $ } = wg(), { printChildren: D } = Oo();
            function T(m, C, o) {
              let d = m.getValue();
              switch (d.type) {
                case "front-matter":
                  return p(d.raw);
                case "root":
                  return C.__onHtmlRoot && C.__onHtmlRoot(d), [s(D(m, C, o)), a];
                case "element":
                case "ieConditionalComment":
                  return $(m, C, o);
                case "ieConditionalStartComment":
                case "ieConditionalEndComment":
                  return [P(d), x(d)];
                case "interpolation":
                  return [P(d, C), ...m.map(o, "children"), x(d, C)];
                case "text": {
                  if (d.parent.type === "interpolation") {
                    let S = /\n[^\S\n]*$/, b = S.test(d.value), B = b ? d.value.replace(S, "") : d.value;
                    return [...p(B), b ? a : ""];
                  }
                  let v = u([I(d, C), ...c(d), N(d, C)]);
                  return l(v) || v.type === "fill" ? t(i(v)) : v;
                }
                case "docType":
                  return [s([P(d, C), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x(d, C)];
                case "comment":
                  return [I(d, C), ...p(C.originalText.slice(_(d), w(d)), n), N(d, C)];
                case "attribute": {
                  if (d.value === null)
                    return d.rawName;
                  let v = g(d.value), S = h(v, "'"), b = h(v, '"'), B = S < b ? "'" : '"';
                  return [d.rawName, "=", B, ...p(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
                }
                default:
                  throw new Error(`Unexpected node type ${d.type}`);
              }
            }
            r.exports = { preprocess: f, print: T, insertPragma: F, massageAstNode: y, embed: E };
          } }), Pg = te({ "src/language-html/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt(), s = "HTML";
            r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
          } }), Ig = te({ "src/language-html/parsers.js"() {
            ne();
          } }), On = te({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
            r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
          } }), kg = te({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
            r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
          } }), Lg = te({ "src/language-html/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = _g(), a = Pg(), n = Ig(), u = [t(On(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(On(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(On(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(kg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
            r.exports = { languages: u, printers: i, options: a, parsers: n };
          } }), Og = te({ "src/language-yaml/pragma.js"(e, r) {
            "use strict";
            ne();
            function t(n) {
              return /^\s*@(?:prettier|format)\s*$/.test(n);
            }
            function s(n) {
              return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
            }
            function a(n) {
              return `# @format

${n}`;
            }
            r.exports = { isPragma: t, hasPragma: s, insertPragma: a };
          } }), jg = te({ "src/language-yaml/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a) {
              return a.position.start.offset;
            }
            function s(a) {
              return a.position.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), qg = te({ "src/language-yaml/embed.js"(e, r) {
            "use strict";
            ne();
            function t(s, a, n, u) {
              if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
                return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
            }
            r.exports = t;
          } }), $t = te({ "src/language-yaml/utils.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t, isNonEmptyArray: s } = Ue();
            function a(D, T) {
              let m = 0, C = D.stack.length - 1;
              for (let o = 0; o < C; o++) {
                let d = D.stack[o];
                n(d) && T(d) && m++;
              }
              return m;
            }
            function n(D, T) {
              return D && typeof D.type == "string" && (!T || T.includes(D.type));
            }
            function u(D, T, m) {
              return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
            }
            function i(D, T, m) {
              Object.defineProperty(D, T, { get: m, enumerable: false });
            }
            function l(D, T) {
              let m = 0, C = T.length;
              for (let o = D.position.end.offset - 1; o < C; o++) {
                let d = T[o];
                if (d === `
` && m++, m === 1 && /\S/.test(d))
                  return false;
                if (m === 2)
                  return true;
              }
              return false;
            }
            function p(D) {
              switch (D.getValue().type) {
                case "tag":
                case "anchor":
                case "comment":
                  return false;
              }
              let m = D.stack.length;
              for (let C = 1; C < m; C++) {
                let o = D.stack[C], d = D.stack[C - 1];
                if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1)
                  return false;
              }
              return true;
            }
            function y(D) {
              return s(D.children) ? y(t(D.children)) : D;
            }
            function h(D) {
              return D.value.trim() === "prettier-ignore";
            }
            function g(D) {
              let T = D.getValue();
              if (T.type === "documentBody") {
                let m = D.getParentNode();
                return N(m.head) && h(t(m.head.endComments));
              }
              return F(T) && h(t(T.leadingComments));
            }
            function c(D) {
              return !s(D.children) && !f(D);
            }
            function f(D) {
              return F(D) || _(D) || w(D) || E(D) || N(D);
            }
            function F(D) {
              return s(D == null ? void 0 : D.leadingComments);
            }
            function _(D) {
              return s(D == null ? void 0 : D.middleComments);
            }
            function w(D) {
              return D == null ? void 0 : D.indicatorComment;
            }
            function E(D) {
              return D == null ? void 0 : D.trailingComment;
            }
            function N(D) {
              return s(D == null ? void 0 : D.endComments);
            }
            function x(D) {
              let T = [], m;
              for (let C of D.split(/( +)/))
                C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
              return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
            }
            function I(D, T, m) {
              let C = T.split(`
`).map((o, d, v) => d === 0 && d === v.length - 1 ? o : d !== 0 && d !== v.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
              return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x(o)).reduce((o, d, v) => v !== 0 && C[v - 1].length > 0 && d.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
            }
            function P(D, T) {
              let { parentIndent: m, isLastDescendant: C, options: o } = T, d = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
              if (D.indent === null) {
                let B = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
              } else
                v = D.indent - 1 + m;
              let S = d.split(`
`).map((B) => B.slice(v));
              if (o.proseWrap === "preserve" || D.type === "blockLiteral")
                return b(S.map((B) => B.length === 0 ? [] : [B]));
              return b(S.map((B) => B.length === 0 ? [] : x(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
              function b(B) {
                if (D.chomping === "keep")
                  return t(B).length === 0 ? B.slice(0, -1) : B;
                let k = 0;
                for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--)
                  k++;
                return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
              }
            }
            function $(D) {
              if (!D)
                return true;
              switch (D.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = { getLast: t, getAncestorCount: a, isNode: n, isEmptyNode: c, isInlineNode: $, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: F, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: E, hasEndComments: N };
          } }), Mg = te({ "src/language-yaml/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var { defineShortcut: t, mapNode: s } = $t();
            function a(u) {
              return s(u, n);
            }
            function n(u) {
              switch (u.type) {
                case "document":
                  t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                  break;
                case "documentBody":
                case "sequenceItem":
                case "flowSequenceItem":
                case "mappingKey":
                case "mappingValue":
                  t(u, "content", () => u.children[0]);
                  break;
                case "mappingItem":
                case "flowMappingItem":
                  t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                  break;
              }
              return u;
            }
            r.exports = a;
          } }), Mr = te({ "src/language-yaml/print/misc.js"(e, r) {
            "use strict";
            ne();
            var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: n, isNode: u } = $t(), i = /* @__PURE__ */ new WeakMap();
            function l(h, g) {
              let c = h.getValue(), f = h.stack[0], F;
              return i.has(f) ? F = i.get(f) : (F = /* @__PURE__ */ new Set(), i.set(f, F)), !F.has(c.position.end.line) && (F.add(c.position.end.line), n(c, g) && !p(h.getParentNode())) ? t : "";
            }
            function p(h) {
              return a(h) && !u(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
            }
            function y(h, g) {
              return s(" ".repeat(h), g);
            }
            r.exports = { alignWithSpaces: y, shouldPrintEndComments: p, printNextEmptyLine: l };
          } }), Rg = te({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
            "use strict";
            ne();
            var { builders: { ifBreak: t, line: s, softline: a, hardline: n, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p } = $t(), { printNextEmptyLine: y, alignWithSpaces: h } = Mr();
            function g(f, F, _) {
              let w = f.getValue(), E = w.type === "flowMapping", N = E ? "{" : "[", x = E ? "}" : "]", I = a;
              E && w.children.length > 0 && _.bracketSpacing && (I = s);
              let P = l(w.children), $ = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
              return [N, h(_.tabWidth, [I, c(f, F, _), _.trailingComma === "none" ? "" : t(","), p(w) ? [n, u(n, f.map(F, "endComments"))] : ""]), $ ? "" : I, x];
            }
            function c(f, F, _) {
              let w = f.getValue();
              return f.map((N, x) => [F(), x === w.children.length - 1 ? "" : [",", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? y(N, _.originalText) : ""]], "children");
            }
            r.exports = { printFlowMapping: g, printFlowSequence: g };
          } }), $g = te({ "src/language-yaml/print/mapping-item.js"(e, r) {
            "use strict";
            ne();
            var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: n, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: y, hasEndComments: h, isNode: g, isEmptyNode: c, isInlineNode: f } = $t(), { alignWithSpaces: F } = Mr();
            function _(x, I, P, $, D) {
              let { key: T, value: m } = x, C = c(T), o = c(m);
              if (C && o)
                return ": ";
              let d = $("key"), v = E(x) ? " " : "";
              if (o)
                return x.type === "flowMappingItem" && I.type === "flowMapping" ? d : x.type === "mappingItem" && w(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, v, ":"] : ["? ", F(2, d)];
              let S = $("value");
              if (C)
                return [": ", F(2, S)];
              if (l(m) || !f(T.content))
                return ["? ", F(2, d), a, u("", P.map($, "value", "leadingComments").map((q) => [q, a])), ": ", F(2, S)];
              if (N(T.content) && !l(T.content) && !p(T.content) && !y(T.content) && !h(T) && !l(m.content) && !p(m.content) && !h(m) && w(m.content, D))
                return [d, v, ": ", S];
              let b = Symbol("mappingKey"), B = s([n("? "), s(F(2, d), { id: b })]), k = [a, ": ", F(2, S)], M = [v, ":"];
              l(m.content) || h(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(T.content) && f(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M.push(a) : m.content && M.push(i), M.push(S);
              let R = F(D.tabWidth, M);
              return w(T.content, D) && !l(T.content) && !p(T.content) && !h(T) ? t([[d, R]]) : t([[B, n(k, R, { groupId: b })]]);
            }
            function w(x, I) {
              if (!x)
                return true;
              switch (x.type) {
                case "plain":
                case "quoteSingle":
                case "quoteDouble":
                  break;
                case "alias":
                  return true;
                default:
                  return false;
              }
              if (I.proseWrap === "preserve")
                return x.position.start.line === x.position.end.line;
              if (/\\$/m.test(I.originalText.slice(x.position.start.offset, x.position.end.offset)))
                return false;
              switch (I.proseWrap) {
                case "never":
                  return !x.value.includes(`
`);
                case "always":
                  return !/[\n ]/.test(x.value);
                default:
                  return false;
              }
            }
            function E(x) {
              return x.key.content && x.key.content.type === "alias";
            }
            function N(x) {
              if (!x)
                return true;
              switch (x.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                  return x.position.start.line === x.position.end.line;
                case "alias":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = _;
          } }), Vg = te({ "src/language-yaml/print/block.js"(e, r) {
            "use strict";
            ne();
            var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: n, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h, getBlockValueLineContents: g, hasIndicatorComment: c, isLastDescendantNode: f, isNode: F } = $t(), { alignWithSpaces: _ } = Mr();
            function w(E, N, x) {
              let I = E.getValue(), P = h(E, (C) => F(C, ["sequence", "mapping"])), $ = f(E), D = [I.type === "blockFolded" ? ">" : "|"];
              I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c(I) && D.push(" ", N("indicatorComment"));
              let T = g(I, { parentIndent: P, isLastDescendant: $, options: x }), m = [];
              for (let [C, o] of T.entries())
                C === 0 && m.push(n), m.push(a(y(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I.chomping === "keep" && $ && m.push(s(o.length === 0 ? n : l));
              return I.indent === null ? D.push(t(_(x.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;
            }
            r.exports = w;
          } }), Wg = te({ "src/language-yaml/printer-yaml.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, fill: s, group: a, hardline: n, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: y, replaceTextEndOfLine: h } } = qe(), { isPreviousLineEmpty: g } = Ue(), { insertPragma: c, isPragma: f } = Og(), { locStart: F } = jg(), _ = qg(), { getFlowScalarLineContents: w, getLastDescendantNode: E, hasLeadingComments: N, hasMiddleComments: x, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $, isLastDescendantNode: D, isNode: T, isInlineNode: m } = $t(), C = Mg(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: v } = Mr(), { printFlowMapping: S, printFlowSequence: b } = Rg(), B = $g(), k = Vg();
            function M(j, Y, ie) {
              let ee = j.getValue(), ce = [];
              ee.type !== "mappingValue" && N(ee) && ce.push([u(n, j.map(ie, "leadingComments")), n]);
              let { tag: W, anchor: K } = ee;
              W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
              let de = "";
              T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = d(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x(ee) ? ce.push(n) : ce.push(" ")), x(ee) && ce.push([ee.middleComments.length === 1 ? "" : n, u(n, j.map(ie, "middleComments")), n]);
              let ue = j.getParentNode();
              return $(j) ? ce.push(h(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p)) : ce.push(a(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee) ? "" : t, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe) => [g(Y.originalText, Fe.getValue(), F) ? n : "", ie()], "endComments"))])), ce.push(de), ce;
            }
            function R(j, Y, ie, ee, ce) {
              switch (j.type) {
                case "root": {
                  let { children: W } = j, K = [];
                  ie.each((ue, Fe) => {
                    let z = W[Fe], U = W[Fe + 1];
                    Fe !== 0 && K.push(n), K.push(ce()), J(z, U) ? (K.push(n, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U && !I(U.head) && K.push(n, "---");
                  }, "children");
                  let de = E(j);
                  return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n), K;
                }
                case "document": {
                  let W = Y.children[ie.getName() + 1], K = [];
                  return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q(j) && K.push(ce("body")), u(n, K);
                }
                case "documentHead":
                  return u(n, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
                case "documentBody": {
                  let { children: W, endComments: K } = j, de = "";
                  if (W.length > 0 && K.length > 0) {
                    let ue = E(j);
                    T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n, n]) : de = n;
                  }
                  return [u(n, ie.map(ce, "children")), de, u(n, ie.map(ce, "endComments"))];
                }
                case "directive":
                  return ["%", u(" ", [j.name, ...j.parameters])];
                case "comment":
                  return ["#", j.value];
                case "alias":
                  return ["*", j.value];
                case "tag":
                  return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
                case "anchor":
                  return ["&", j.value];
                case "plain":
                  return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
                case "quoteDouble":
                case "quoteSingle": {
                  let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
                  if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
                    let Fe = j.type === "quoteDouble" ? K : W;
                    return [Fe, Q(j.type, de, ee), Fe];
                  }
                  if (de.includes(K))
                    return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
                  if (de.includes(W))
                    return [K, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
                  let ue = ee.singleQuote ? W : K;
                  return [ue, Q(j.type, de, ee), ue];
                }
                case "blockFolded":
                case "blockLiteral":
                  return k(ie, ce, ee);
                case "mapping":
                case "sequence":
                  return u(n, ie.map(ce, "children"));
                case "sequenceItem":
                  return ["- ", o(2, j.content ? ce("content") : "")];
                case "mappingKey":
                case "mappingValue":
                  return j.content ? ce("content") : "";
                case "mappingItem":
                case "flowMappingItem":
                  return B(j, Y, ie, ce, ee);
                case "flowMapping":
                  return S(ie, ce, ee);
                case "flowSequence":
                  return b(ie, ce, ee);
                case "flowSequenceItem":
                  return ce("content");
                default:
                  throw new Error(`Unexpected node type ${j.type}`);
              }
            }
            function q(j) {
              return j.body.children.length > 0 || P(j.body);
            }
            function J(j, Y) {
              return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
            }
            function L(j, Y, ie, ee) {
              return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(F(j), F(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
            }
            function Q(j, Y, ie) {
              let ee = w(j, Y, ie);
              return u(n, ee.map((ce) => s(y(u(i, ce)))));
            }
            function V(j, Y) {
              if (T(Y))
                switch (delete Y.position, Y.type) {
                  case "comment":
                    if (f(Y.value))
                      return null;
                    break;
                  case "quoteDouble":
                  case "quoteSingle":
                    Y.type = "quote";
                    break;
                }
            }
            r.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c };
          } }), Hg = te({ "src/language-yaml/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
          } }), Gg = te({ "src/language-yaml/parsers.js"() {
            ne();
          } }), Ug = te({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
            r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
          } }), Jg = te({ "src/language-yaml/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Wg(), a = Hg(), n = Gg(), u = [t(Ug(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
            r.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n };
          } }), zg = te({ "src/languages.js"(e, r) {
            "use strict";
            ne(), r.exports = [Bd(), Ud(), eg(), ag(), dg(), Lg(), Jg()];
          } });
          ne();
          var { version: Xg } = Ia(), Ot = Gm(), { getSupportInfo: Kg } = Xn(), Yg = Um(), Qg = zg(), Zg = qe();
          function Nt(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return function() {
              for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++)
                s[a] = arguments[a];
              let n = s[r] || {}, u = n.plugins || [];
              return s[r] = Object.assign(Object.assign({}, n), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
            };
          }
          var jn = Nt(Ot.formatWithCursor);
          jo.exports = { formatWithCursor: jn, format(e, r) {
            return jn(e, r).formatted;
          }, check(e, r) {
            let { formatted: t } = jn(e, r);
            return t === e;
          }, doc: Zg, getSupportInfo: Nt(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt(Ot.parse), formatAST: Nt(Ot.formatAST), formatDoc: Nt(Ot.formatDoc), printToDoc: Nt(Ot.printToDoc), printDocToString: Nt(Ot.printDocToString) } };
        });
        return e0();
      });
    }
  });

  // node_modules/prettier/parser-graphql.js
  var require_parser_graphql = __commonJS({
    "node_modules/prettier/parser-graphql.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.graphql = e();
        }
      })(function() {
        "use strict";
        var oe = (a, d) => () => (d || a((d = { exports: {} }).exports, d), d.exports);
        var be = oe((Ce, ae) => {
          var H = Object.getOwnPropertyNames, se = (a, d) => function() {
            return a && (d = (0, a[H(a)[0]])(a = 0)), d;
          }, L = (a, d) => function() {
            return d || (0, a[H(a)[0]])((d = { exports: {} }).exports, d), d.exports;
          }, K = se({ "<define:process>"() {
          } }), ce = L({ "src/common/parser-create-error.js"(a, d) {
            "use strict";
            K();
            function i(c, r) {
              let _ = new SyntaxError(c + " (" + r.start.line + ":" + r.start.column + ")");
              return _.loc = r, _;
            }
            d.exports = i;
          } }), ue = L({ "src/utils/try-combinations.js"(a, d) {
            "use strict";
            K();
            function i() {
              let c;
              for (var r = arguments.length, _ = new Array(r), E = 0; E < r; E++)
                _[E] = arguments[E];
              for (let [k, O] of _.entries())
                try {
                  return { result: O() };
                } catch (A) {
                  k === 0 && (c = A);
                }
              return { error: c };
            }
            d.exports = i;
          } }), le = L({ "src/language-graphql/pragma.js"(a, d) {
            "use strict";
            K();
            function i(r) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(r);
            }
            function c(r) {
              return `# @format

` + r;
            }
            d.exports = { hasPragma: i, insertPragma: c };
          } }), pe = L({ "src/language-graphql/loc.js"(a, d) {
            "use strict";
            K();
            function i(r) {
              return typeof r.start == "number" ? r.start : r.loc && r.loc.start;
            }
            function c(r) {
              return typeof r.end == "number" ? r.end : r.loc && r.loc.end;
            }
            d.exports = { locStart: i, locEnd: c };
          } }), fe = L({ "node_modules/graphql/jsutils/isObjectLike.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = i;
            function d(c) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(_) {
                return typeof _;
              } : d = function(_) {
                return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
              }, d(c);
            }
            function i(c) {
              return d(c) == "object" && c !== null;
            }
          } }), z = L({ "node_modules/graphql/polyfills/symbols.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.SYMBOL_TO_STRING_TAG = a.SYMBOL_ASYNC_ITERATOR = a.SYMBOL_ITERATOR = void 0;
            var d = typeof Symbol == "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
            a.SYMBOL_ITERATOR = d;
            var i = typeof Symbol == "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
            a.SYMBOL_ASYNC_ITERATOR = i;
            var c = typeof Symbol == "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
            a.SYMBOL_TO_STRING_TAG = c;
          } }), $ = L({ "node_modules/graphql/language/location.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.getLocation = d;
            function d(i, c) {
              for (var r = /\r\n|[\n\r]/g, _ = 1, E = c + 1, k; (k = r.exec(i.body)) && k.index < c; )
                _ += 1, E = c + 1 - (k.index + k[0].length);
              return { line: _, column: E };
            }
          } }), de = L({ "node_modules/graphql/language/printLocation.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.printLocation = i, a.printSourceLocation = c;
            var d = $();
            function i(k) {
              return c(k.source, (0, d.getLocation)(k.source, k.start));
            }
            function c(k, O) {
              var A = k.locationOffset.column - 1, N = _(A) + k.body, g = O.line - 1, D = k.locationOffset.line - 1, v = O.line + D, I = O.line === 1 ? A : 0, s = O.column + I, p = "".concat(k.name, ":").concat(v, ":").concat(s, `
`), e = N.split(/\r\n|[\n\r]/g), n = e[g];
              if (n.length > 120) {
                for (var t = Math.floor(s / 80), u = s % 80, y = [], f = 0; f < n.length; f += 80)
                  y.push(n.slice(f, f + 80));
                return p + r([["".concat(v), y[0]]].concat(y.slice(1, t + 1).map(function(m) {
                  return ["", m];
                }), [[" ", _(u - 1) + "^"], ["", y[t + 1]]]));
              }
              return p + r([["".concat(v - 1), e[g - 1]], ["".concat(v), n], ["", _(s - 1) + "^"], ["".concat(v + 1), e[g + 1]]]);
            }
            function r(k) {
              var O = k.filter(function(N) {
                var g = N[0], D = N[1];
                return D !== void 0;
              }), A = Math.max.apply(Math, O.map(function(N) {
                var g = N[0];
                return g.length;
              }));
              return O.map(function(N) {
                var g = N[0], D = N[1];
                return E(A, g) + (D ? " | " + D : " |");
              }).join(`
`);
            }
            function _(k) {
              return Array(k + 1).join(" ");
            }
            function E(k, O) {
              return _(k - O.length) + O;
            }
          } }), W = L({ "node_modules/graphql/error/GraphQLError.js"(a) {
            "use strict";
            K();
            function d(f) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(o) {
                return typeof o;
              } : d = function(o) {
                return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
              }, d(f);
            }
            Object.defineProperty(a, "__esModule", { value: true }), a.printError = y, a.GraphQLError = void 0;
            var i = E(fe()), c = z(), r = $(), _ = de();
            function E(f) {
              return f && f.__esModule ? f : { default: f };
            }
            function k(f, m) {
              if (!(f instanceof m))
                throw new TypeError("Cannot call a class as a function");
            }
            function O(f, m) {
              for (var o = 0; o < m.length; o++) {
                var h = m[o];
                h.enumerable = h.enumerable || false, h.configurable = true, "value" in h && (h.writable = true), Object.defineProperty(f, h.key, h);
              }
            }
            function A(f, m, o) {
              return m && O(f.prototype, m), o && O(f, o), f;
            }
            function N(f, m) {
              if (typeof m != "function" && m !== null)
                throw new TypeError("Super expression must either be null or a function");
              f.prototype = Object.create(m && m.prototype, { constructor: { value: f, writable: true, configurable: true } }), m && n(f, m);
            }
            function g(f) {
              var m = p();
              return function() {
                var h = t(f), l;
                if (m) {
                  var T = t(this).constructor;
                  l = Reflect.construct(h, arguments, T);
                } else
                  l = h.apply(this, arguments);
                return D(this, l);
              };
            }
            function D(f, m) {
              return m && (d(m) === "object" || typeof m == "function") ? m : v(f);
            }
            function v(f) {
              if (f === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return f;
            }
            function I(f) {
              var m = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
              return I = function(h) {
                if (h === null || !e(h))
                  return h;
                if (typeof h != "function")
                  throw new TypeError("Super expression must either be null or a function");
                if (typeof m < "u") {
                  if (m.has(h))
                    return m.get(h);
                  m.set(h, l);
                }
                function l() {
                  return s(h, arguments, t(this).constructor);
                }
                return l.prototype = Object.create(h.prototype, { constructor: { value: l, enumerable: false, writable: true, configurable: true } }), n(l, h);
              }, I(f);
            }
            function s(f, m, o) {
              return p() ? s = Reflect.construct : s = function(l, T, S) {
                var x = [null];
                x.push.apply(x, T);
                var b = Function.bind.apply(l, x), M = new b();
                return S && n(M, S.prototype), M;
              }, s.apply(null, arguments);
            }
            function p() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                return false;
              if (typeof Proxy == "function")
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch {
                return false;
              }
            }
            function e(f) {
              return Function.toString.call(f).indexOf("[native code]") !== -1;
            }
            function n(f, m) {
              return n = Object.setPrototypeOf || function(h, l) {
                return h.__proto__ = l, h;
              }, n(f, m);
            }
            function t(f) {
              return t = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
              }, t(f);
            }
            var u = function(f) {
              N(o, f);
              var m = g(o);
              function o(h, l, T, S, x, b, M) {
                var U, V, q, G, C;
                k(this, o), C = m.call(this, h);
                var R = Array.isArray(l) ? l.length !== 0 ? l : void 0 : l ? [l] : void 0, Y = T;
                if (!Y && R) {
                  var J;
                  Y = (J = R[0].loc) === null || J === void 0 ? void 0 : J.source;
                }
                var F = S;
                !F && R && (F = R.reduce(function(w, P) {
                  return P.loc && w.push(P.loc.start), w;
                }, [])), F && F.length === 0 && (F = void 0);
                var B;
                S && T ? B = S.map(function(w) {
                  return (0, r.getLocation)(T, w);
                }) : R && (B = R.reduce(function(w, P) {
                  return P.loc && w.push((0, r.getLocation)(P.loc.source, P.loc.start)), w;
                }, []));
                var j = M;
                if (j == null && b != null) {
                  var Q = b.extensions;
                  (0, i.default)(Q) && (j = Q);
                }
                return Object.defineProperties(v(C), { name: { value: "GraphQLError" }, message: { value: h, enumerable: true, writable: true }, locations: { value: (U = B) !== null && U !== void 0 ? U : void 0, enumerable: B != null }, path: { value: x != null ? x : void 0, enumerable: x != null }, nodes: { value: R != null ? R : void 0 }, source: { value: (V = Y) !== null && V !== void 0 ? V : void 0 }, positions: { value: (q = F) !== null && q !== void 0 ? q : void 0 }, originalError: { value: b }, extensions: { value: (G = j) !== null && G !== void 0 ? G : void 0, enumerable: j != null } }), b != null && b.stack ? (Object.defineProperty(v(C), "stack", { value: b.stack, writable: true, configurable: true }), D(C)) : (Error.captureStackTrace ? Error.captureStackTrace(v(C), o) : Object.defineProperty(v(C), "stack", { value: Error().stack, writable: true, configurable: true }), C);
              }
              return A(o, [{ key: "toString", value: function() {
                return y(this);
              } }, { key: c.SYMBOL_TO_STRING_TAG, get: function() {
                return "Object";
              } }]), o;
            }(I(Error));
            a.GraphQLError = u;
            function y(f) {
              var m = f.message;
              if (f.nodes)
                for (var o = 0, h = f.nodes; o < h.length; o++) {
                  var l = h[o];
                  l.loc && (m += `

` + (0, _.printLocation)(l.loc));
                }
              else if (f.source && f.locations)
                for (var T = 0, S = f.locations; T < S.length; T++) {
                  var x = S[T];
                  m += `

` + (0, _.printSourceLocation)(f.source, x);
                }
              return m;
            }
          } }), Z = L({ "node_modules/graphql/error/syntaxError.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.syntaxError = i;
            var d = W();
            function i(c, r, _) {
              return new d.GraphQLError("Syntax Error: ".concat(_), void 0, c, [r]);
            }
          } }), he = L({ "node_modules/graphql/language/kinds.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.Kind = void 0;
            var d = Object.freeze({ NAME: "Name", DOCUMENT: "Document", OPERATION_DEFINITION: "OperationDefinition", VARIABLE_DEFINITION: "VariableDefinition", SELECTION_SET: "SelectionSet", FIELD: "Field", ARGUMENT: "Argument", FRAGMENT_SPREAD: "FragmentSpread", INLINE_FRAGMENT: "InlineFragment", FRAGMENT_DEFINITION: "FragmentDefinition", VARIABLE: "Variable", INT: "IntValue", FLOAT: "FloatValue", STRING: "StringValue", BOOLEAN: "BooleanValue", NULL: "NullValue", ENUM: "EnumValue", LIST: "ListValue", OBJECT: "ObjectValue", OBJECT_FIELD: "ObjectField", DIRECTIVE: "Directive", NAMED_TYPE: "NamedType", LIST_TYPE: "ListType", NON_NULL_TYPE: "NonNullType", SCHEMA_DEFINITION: "SchemaDefinition", OPERATION_TYPE_DEFINITION: "OperationTypeDefinition", SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition", OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition", FIELD_DEFINITION: "FieldDefinition", INPUT_VALUE_DEFINITION: "InputValueDefinition", INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition", UNION_TYPE_DEFINITION: "UnionTypeDefinition", ENUM_TYPE_DEFINITION: "EnumTypeDefinition", ENUM_VALUE_DEFINITION: "EnumValueDefinition", INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition", DIRECTIVE_DEFINITION: "DirectiveDefinition", SCHEMA_EXTENSION: "SchemaExtension", SCALAR_TYPE_EXTENSION: "ScalarTypeExtension", OBJECT_TYPE_EXTENSION: "ObjectTypeExtension", INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension", UNION_TYPE_EXTENSION: "UnionTypeExtension", ENUM_TYPE_EXTENSION: "EnumTypeExtension", INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension" });
            a.Kind = d;
          } }), ve = L({ "node_modules/graphql/jsutils/invariant.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = d;
            function d(i, c) {
              var r = Boolean(i);
              if (!r)
                throw new Error(c != null ? c : "Unexpected invariant triggered.");
            }
          } }), ee = L({ "node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = void 0;
            var d = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0, i = d;
            a.default = i;
          } }), Te = L({ "node_modules/graphql/jsutils/defineInspect.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = r;
            var d = c(ve()), i = c(ee());
            function c(_) {
              return _ && _.__esModule ? _ : { default: _ };
            }
            function r(_) {
              var E = _.prototype.toJSON;
              typeof E == "function" || (0, d.default)(0), _.prototype.inspect = E, i.default && (_.prototype[i.default] = E);
            }
          } }), te = L({ "node_modules/graphql/language/ast.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isNode = _, a.Token = a.Location = void 0;
            var d = i(Te());
            function i(E) {
              return E && E.__esModule ? E : { default: E };
            }
            var c = function() {
              function E(O, A, N) {
                this.start = O.start, this.end = A.end, this.startToken = O, this.endToken = A, this.source = N;
              }
              var k = E.prototype;
              return k.toJSON = function() {
                return { start: this.start, end: this.end };
              }, E;
            }();
            a.Location = c, (0, d.default)(c);
            var r = function() {
              function E(O, A, N, g, D, v, I) {
                this.kind = O, this.start = A, this.end = N, this.line = g, this.column = D, this.value = I, this.prev = v, this.next = null;
              }
              var k = E.prototype;
              return k.toJSON = function() {
                return { kind: this.kind, value: this.value, line: this.line, column: this.column };
              }, E;
            }();
            a.Token = r, (0, d.default)(r);
            function _(E) {
              return E != null && typeof E.kind == "string";
            }
          } }), ne = L({ "node_modules/graphql/language/tokenKind.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.TokenKind = void 0;
            var d = Object.freeze({ SOF: "<SOF>", EOF: "<EOF>", BANG: "!", DOLLAR: "$", AMP: "&", PAREN_L: "(", PAREN_R: ")", SPREAD: "...", COLON: ":", EQUALS: "=", AT: "@", BRACKET_L: "[", BRACKET_R: "]", BRACE_L: "{", PIPE: "|", BRACE_R: "}", NAME: "Name", INT: "Int", FLOAT: "Float", STRING: "String", BLOCK_STRING: "BlockString", COMMENT: "Comment" });
            a.TokenKind = d;
          } }), re = L({ "node_modules/graphql/jsutils/inspect.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = E;
            var d = i(ee());
            function i(v) {
              return v && v.__esModule ? v : { default: v };
            }
            function c(v) {
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(s) {
                return typeof s;
              } : c = function(s) {
                return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
              }, c(v);
            }
            var r = 10, _ = 2;
            function E(v) {
              return k(v, []);
            }
            function k(v, I) {
              switch (c(v)) {
                case "string":
                  return JSON.stringify(v);
                case "function":
                  return v.name ? "[function ".concat(v.name, "]") : "[function]";
                case "object":
                  return v === null ? "null" : O(v, I);
                default:
                  return String(v);
              }
            }
            function O(v, I) {
              if (I.indexOf(v) !== -1)
                return "[Circular]";
              var s = [].concat(I, [v]), p = g(v);
              if (p !== void 0) {
                var e = p.call(v);
                if (e !== v)
                  return typeof e == "string" ? e : k(e, s);
              } else if (Array.isArray(v))
                return N(v, s);
              return A(v, s);
            }
            function A(v, I) {
              var s = Object.keys(v);
              if (s.length === 0)
                return "{}";
              if (I.length > _)
                return "[" + D(v) + "]";
              var p = s.map(function(e) {
                var n = k(v[e], I);
                return e + ": " + n;
              });
              return "{ " + p.join(", ") + " }";
            }
            function N(v, I) {
              if (v.length === 0)
                return "[]";
              if (I.length > _)
                return "[Array]";
              for (var s = Math.min(r, v.length), p = v.length - s, e = [], n = 0; n < s; ++n)
                e.push(k(v[n], I));
              return p === 1 ? e.push("... 1 more item") : p > 1 && e.push("... ".concat(p, " more items")), "[" + e.join(", ") + "]";
            }
            function g(v) {
              var I = v[String(d.default)];
              if (typeof I == "function")
                return I;
              if (typeof v.inspect == "function")
                return v.inspect;
            }
            function D(v) {
              var I = Object.prototype.toString.call(v).replace(/^\[object /, "").replace(/]$/, "");
              if (I === "Object" && typeof v.constructor == "function") {
                var s = v.constructor.name;
                if (typeof s == "string" && s !== "")
                  return s;
              }
              return I;
            }
          } }), _e = L({ "node_modules/graphql/jsutils/devAssert.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = d;
            function d(i, c) {
              var r = Boolean(i);
              if (!r)
                throw new Error(c);
            }
          } }), Ee = L({ "node_modules/graphql/jsutils/instanceOf.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.default = void 0;
            var d = i(re());
            function i(r) {
              return r && r.__esModule ? r : { default: r };
            }
            var c = function(_, E) {
              return _ instanceof E;
            };
            a.default = c;
          } }), me = L({ "node_modules/graphql/language/source.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isSource = A, a.Source = void 0;
            var d = z(), i = _(re()), c = _(_e()), r = _(Ee());
            function _(N) {
              return N && N.__esModule ? N : { default: N };
            }
            function E(N, g) {
              for (var D = 0; D < g.length; D++) {
                var v = g[D];
                v.enumerable = v.enumerable || false, v.configurable = true, "value" in v && (v.writable = true), Object.defineProperty(N, v.key, v);
              }
            }
            function k(N, g, D) {
              return g && E(N.prototype, g), D && E(N, D), N;
            }
            var O = function() {
              function N(g) {
                var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request", v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { line: 1, column: 1 };
                typeof g == "string" || (0, c.default)(0, "Body must be a string. Received: ".concat((0, i.default)(g), ".")), this.body = g, this.name = D, this.locationOffset = v, this.locationOffset.line > 0 || (0, c.default)(0, "line in locationOffset is 1-indexed and must be positive."), this.locationOffset.column > 0 || (0, c.default)(0, "column in locationOffset is 1-indexed and must be positive.");
              }
              return k(N, [{ key: d.SYMBOL_TO_STRING_TAG, get: function() {
                return "Source";
              } }]), N;
            }();
            a.Source = O;
            function A(N) {
              return (0, r.default)(N, O);
            }
          } }), ye = L({ "node_modules/graphql/language/directiveLocation.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.DirectiveLocation = void 0;
            var d = Object.freeze({ QUERY: "QUERY", MUTATION: "MUTATION", SUBSCRIPTION: "SUBSCRIPTION", FIELD: "FIELD", FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION", FRAGMENT_SPREAD: "FRAGMENT_SPREAD", INLINE_FRAGMENT: "INLINE_FRAGMENT", VARIABLE_DEFINITION: "VARIABLE_DEFINITION", SCHEMA: "SCHEMA", SCALAR: "SCALAR", OBJECT: "OBJECT", FIELD_DEFINITION: "FIELD_DEFINITION", ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION", INTERFACE: "INTERFACE", UNION: "UNION", ENUM: "ENUM", ENUM_VALUE: "ENUM_VALUE", INPUT_OBJECT: "INPUT_OBJECT", INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION" });
            a.DirectiveLocation = d;
          } }), ke = L({ "node_modules/graphql/language/blockString.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.dedentBlockStringValue = d, a.getBlockStringIndentation = c, a.printBlockString = r;
            function d(_) {
              var E = _.split(/\r\n|[\n\r]/g), k = c(_);
              if (k !== 0)
                for (var O = 1; O < E.length; O++)
                  E[O] = E[O].slice(k);
              for (var A = 0; A < E.length && i(E[A]); )
                ++A;
              for (var N = E.length; N > A && i(E[N - 1]); )
                --N;
              return E.slice(A, N).join(`
`);
            }
            function i(_) {
              for (var E = 0; E < _.length; ++E)
                if (_[E] !== " " && _[E] !== "	")
                  return false;
              return true;
            }
            function c(_) {
              for (var E, k = true, O = true, A = 0, N = null, g = 0; g < _.length; ++g)
                switch (_.charCodeAt(g)) {
                  case 13:
                    _.charCodeAt(g + 1) === 10 && ++g;
                  case 10:
                    k = false, O = true, A = 0;
                    break;
                  case 9:
                  case 32:
                    ++A;
                    break;
                  default:
                    O && !k && (N === null || A < N) && (N = A), O = false;
                }
              return (E = N) !== null && E !== void 0 ? E : 0;
            }
            function r(_) {
              var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", k = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, O = _.indexOf(`
`) === -1, A = _[0] === " " || _[0] === "	", N = _[_.length - 1] === '"', g = _[_.length - 1] === "\\", D = !O || N || g || k, v = "";
              return D && !(O && A) && (v += `
` + E), v += E ? _.replace(/\n/g, `
` + E) : _, D && (v += `
`), '"""' + v.replace(/"""/g, '\\"""') + '"""';
            }
          } }), Ne = L({ "node_modules/graphql/language/lexer.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.isPunctuatorTokenKind = E, a.Lexer = void 0;
            var d = Z(), i = te(), c = ne(), r = ke(), _ = function() {
              function t(y) {
                var f = new i.Token(c.TokenKind.SOF, 0, 0, 0, 0, null);
                this.source = y, this.lastToken = f, this.token = f, this.line = 1, this.lineStart = 0;
              }
              var u = t.prototype;
              return u.advance = function() {
                this.lastToken = this.token;
                var f = this.token = this.lookahead();
                return f;
              }, u.lookahead = function() {
                var f = this.token;
                if (f.kind !== c.TokenKind.EOF)
                  do {
                    var m;
                    f = (m = f.next) !== null && m !== void 0 ? m : f.next = O(this, f);
                  } while (f.kind === c.TokenKind.COMMENT);
                return f;
              }, t;
            }();
            a.Lexer = _;
            function E(t) {
              return t === c.TokenKind.BANG || t === c.TokenKind.DOLLAR || t === c.TokenKind.AMP || t === c.TokenKind.PAREN_L || t === c.TokenKind.PAREN_R || t === c.TokenKind.SPREAD || t === c.TokenKind.COLON || t === c.TokenKind.EQUALS || t === c.TokenKind.AT || t === c.TokenKind.BRACKET_L || t === c.TokenKind.BRACKET_R || t === c.TokenKind.BRACE_L || t === c.TokenKind.PIPE || t === c.TokenKind.BRACE_R;
            }
            function k(t) {
              return isNaN(t) ? c.TokenKind.EOF : t < 127 ? JSON.stringify(String.fromCharCode(t)) : '"\\u'.concat(("00" + t.toString(16).toUpperCase()).slice(-4), '"');
            }
            function O(t, u) {
              for (var y = t.source, f = y.body, m = f.length, o = u.end; o < m; ) {
                var h = f.charCodeAt(o), l = t.line, T = 1 + o - t.lineStart;
                switch (h) {
                  case 65279:
                  case 9:
                  case 32:
                  case 44:
                    ++o;
                    continue;
                  case 10:
                    ++o, ++t.line, t.lineStart = o;
                    continue;
                  case 13:
                    f.charCodeAt(o + 1) === 10 ? o += 2 : ++o, ++t.line, t.lineStart = o;
                    continue;
                  case 33:
                    return new i.Token(c.TokenKind.BANG, o, o + 1, l, T, u);
                  case 35:
                    return N(y, o, l, T, u);
                  case 36:
                    return new i.Token(c.TokenKind.DOLLAR, o, o + 1, l, T, u);
                  case 38:
                    return new i.Token(c.TokenKind.AMP, o, o + 1, l, T, u);
                  case 40:
                    return new i.Token(c.TokenKind.PAREN_L, o, o + 1, l, T, u);
                  case 41:
                    return new i.Token(c.TokenKind.PAREN_R, o, o + 1, l, T, u);
                  case 46:
                    if (f.charCodeAt(o + 1) === 46 && f.charCodeAt(o + 2) === 46)
                      return new i.Token(c.TokenKind.SPREAD, o, o + 3, l, T, u);
                    break;
                  case 58:
                    return new i.Token(c.TokenKind.COLON, o, o + 1, l, T, u);
                  case 61:
                    return new i.Token(c.TokenKind.EQUALS, o, o + 1, l, T, u);
                  case 64:
                    return new i.Token(c.TokenKind.AT, o, o + 1, l, T, u);
                  case 91:
                    return new i.Token(c.TokenKind.BRACKET_L, o, o + 1, l, T, u);
                  case 93:
                    return new i.Token(c.TokenKind.BRACKET_R, o, o + 1, l, T, u);
                  case 123:
                    return new i.Token(c.TokenKind.BRACE_L, o, o + 1, l, T, u);
                  case 124:
                    return new i.Token(c.TokenKind.PIPE, o, o + 1, l, T, u);
                  case 125:
                    return new i.Token(c.TokenKind.BRACE_R, o, o + 1, l, T, u);
                  case 34:
                    return f.charCodeAt(o + 1) === 34 && f.charCodeAt(o + 2) === 34 ? I(y, o, l, T, u, t) : v(y, o, l, T, u);
                  case 45:
                  case 48:
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    return g(y, o, h, l, T, u);
                  case 65:
                  case 66:
                  case 67:
                  case 68:
                  case 69:
                  case 70:
                  case 71:
                  case 72:
                  case 73:
                  case 74:
                  case 75:
                  case 76:
                  case 77:
                  case 78:
                  case 79:
                  case 80:
                  case 81:
                  case 82:
                  case 83:
                  case 84:
                  case 85:
                  case 86:
                  case 87:
                  case 88:
                  case 89:
                  case 90:
                  case 95:
                  case 97:
                  case 98:
                  case 99:
                  case 100:
                  case 101:
                  case 102:
                  case 103:
                  case 104:
                  case 105:
                  case 106:
                  case 107:
                  case 108:
                  case 109:
                  case 110:
                  case 111:
                  case 112:
                  case 113:
                  case 114:
                  case 115:
                  case 116:
                  case 117:
                  case 118:
                  case 119:
                  case 120:
                  case 121:
                  case 122:
                    return e(y, o, l, T, u);
                }
                throw (0, d.syntaxError)(y, o, A(h));
              }
              var S = t.line, x = 1 + o - t.lineStart;
              return new i.Token(c.TokenKind.EOF, m, m, S, x, u);
            }
            function A(t) {
              return t < 32 && t !== 9 && t !== 10 && t !== 13 ? "Cannot contain the invalid character ".concat(k(t), ".") : t === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : "Cannot parse the unexpected character ".concat(k(t), ".");
            }
            function N(t, u, y, f, m) {
              var o = t.body, h, l = u;
              do
                h = o.charCodeAt(++l);
              while (!isNaN(h) && (h > 31 || h === 9));
              return new i.Token(c.TokenKind.COMMENT, u, l, y, f, m, o.slice(u + 1, l));
            }
            function g(t, u, y, f, m, o) {
              var h = t.body, l = y, T = u, S = false;
              if (l === 45 && (l = h.charCodeAt(++T)), l === 48) {
                if (l = h.charCodeAt(++T), l >= 48 && l <= 57)
                  throw (0, d.syntaxError)(t, T, "Invalid number, unexpected digit after 0: ".concat(k(l), "."));
              } else
                T = D(t, T, l), l = h.charCodeAt(T);
              if (l === 46 && (S = true, l = h.charCodeAt(++T), T = D(t, T, l), l = h.charCodeAt(T)), (l === 69 || l === 101) && (S = true, l = h.charCodeAt(++T), (l === 43 || l === 45) && (l = h.charCodeAt(++T)), T = D(t, T, l), l = h.charCodeAt(T)), l === 46 || n(l))
                throw (0, d.syntaxError)(t, T, "Invalid number, expected digit but got: ".concat(k(l), "."));
              return new i.Token(S ? c.TokenKind.FLOAT : c.TokenKind.INT, u, T, f, m, o, h.slice(u, T));
            }
            function D(t, u, y) {
              var f = t.body, m = u, o = y;
              if (o >= 48 && o <= 57) {
                do
                  o = f.charCodeAt(++m);
                while (o >= 48 && o <= 57);
                return m;
              }
              throw (0, d.syntaxError)(t, m, "Invalid number, expected digit but got: ".concat(k(o), "."));
            }
            function v(t, u, y, f, m) {
              for (var o = t.body, h = u + 1, l = h, T = 0, S = ""; h < o.length && !isNaN(T = o.charCodeAt(h)) && T !== 10 && T !== 13; ) {
                if (T === 34)
                  return S += o.slice(l, h), new i.Token(c.TokenKind.STRING, u, h + 1, y, f, m, S);
                if (T < 32 && T !== 9)
                  throw (0, d.syntaxError)(t, h, "Invalid character within String: ".concat(k(T), "."));
                if (++h, T === 92) {
                  switch (S += o.slice(l, h - 1), T = o.charCodeAt(h), T) {
                    case 34:
                      S += '"';
                      break;
                    case 47:
                      S += "/";
                      break;
                    case 92:
                      S += "\\";
                      break;
                    case 98:
                      S += "\b";
                      break;
                    case 102:
                      S += "\f";
                      break;
                    case 110:
                      S += `
`;
                      break;
                    case 114:
                      S += "\r";
                      break;
                    case 116:
                      S += "	";
                      break;
                    case 117: {
                      var x = s(o.charCodeAt(h + 1), o.charCodeAt(h + 2), o.charCodeAt(h + 3), o.charCodeAt(h + 4));
                      if (x < 0) {
                        var b = o.slice(h + 1, h + 5);
                        throw (0, d.syntaxError)(t, h, "Invalid character escape sequence: \\u".concat(b, "."));
                      }
                      S += String.fromCharCode(x), h += 4;
                      break;
                    }
                    default:
                      throw (0, d.syntaxError)(t, h, "Invalid character escape sequence: \\".concat(String.fromCharCode(T), "."));
                  }
                  ++h, l = h;
                }
              }
              throw (0, d.syntaxError)(t, h, "Unterminated string.");
            }
            function I(t, u, y, f, m, o) {
              for (var h = t.body, l = u + 3, T = l, S = 0, x = ""; l < h.length && !isNaN(S = h.charCodeAt(l)); ) {
                if (S === 34 && h.charCodeAt(l + 1) === 34 && h.charCodeAt(l + 2) === 34)
                  return x += h.slice(T, l), new i.Token(c.TokenKind.BLOCK_STRING, u, l + 3, y, f, m, (0, r.dedentBlockStringValue)(x));
                if (S < 32 && S !== 9 && S !== 10 && S !== 13)
                  throw (0, d.syntaxError)(t, l, "Invalid character within String: ".concat(k(S), "."));
                S === 10 ? (++l, ++o.line, o.lineStart = l) : S === 13 ? (h.charCodeAt(l + 1) === 10 ? l += 2 : ++l, ++o.line, o.lineStart = l) : S === 92 && h.charCodeAt(l + 1) === 34 && h.charCodeAt(l + 2) === 34 && h.charCodeAt(l + 3) === 34 ? (x += h.slice(T, l) + '"""', l += 4, T = l) : ++l;
              }
              throw (0, d.syntaxError)(t, l, "Unterminated string.");
            }
            function s(t, u, y, f) {
              return p(t) << 12 | p(u) << 8 | p(y) << 4 | p(f);
            }
            function p(t) {
              return t >= 48 && t <= 57 ? t - 48 : t >= 65 && t <= 70 ? t - 55 : t >= 97 && t <= 102 ? t - 87 : -1;
            }
            function e(t, u, y, f, m) {
              for (var o = t.body, h = o.length, l = u + 1, T = 0; l !== h && !isNaN(T = o.charCodeAt(l)) && (T === 95 || T >= 48 && T <= 57 || T >= 65 && T <= 90 || T >= 97 && T <= 122); )
                ++l;
              return new i.Token(c.TokenKind.NAME, u, l, y, f, m, o.slice(u, l));
            }
            function n(t) {
              return t === 95 || t >= 65 && t <= 90 || t >= 97 && t <= 122;
            }
          } }), Oe = L({ "node_modules/graphql/language/parser.js"(a) {
            "use strict";
            K(), Object.defineProperty(a, "__esModule", { value: true }), a.parse = O, a.parseValue = A, a.parseType = N, a.Parser = void 0;
            var d = Z(), i = he(), c = te(), r = ne(), _ = me(), E = ye(), k = Ne();
            function O(I, s) {
              var p = new g(I, s);
              return p.parseDocument();
            }
            function A(I, s) {
              var p = new g(I, s);
              p.expectToken(r.TokenKind.SOF);
              var e = p.parseValueLiteral(false);
              return p.expectToken(r.TokenKind.EOF), e;
            }
            function N(I, s) {
              var p = new g(I, s);
              p.expectToken(r.TokenKind.SOF);
              var e = p.parseTypeReference();
              return p.expectToken(r.TokenKind.EOF), e;
            }
            var g = function() {
              function I(p, e) {
                var n = (0, _.isSource)(p) ? p : new _.Source(p);
                this._lexer = new k.Lexer(n), this._options = e;
              }
              var s = I.prototype;
              return s.parseName = function() {
                var e = this.expectToken(r.TokenKind.NAME);
                return { kind: i.Kind.NAME, value: e.value, loc: this.loc(e) };
              }, s.parseDocument = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.DOCUMENT, definitions: this.many(r.TokenKind.SOF, this.parseDefinition, r.TokenKind.EOF), loc: this.loc(e) };
              }, s.parseDefinition = function() {
                if (this.peek(r.TokenKind.NAME))
                  switch (this._lexer.token.value) {
                    case "query":
                    case "mutation":
                    case "subscription":
                      return this.parseOperationDefinition();
                    case "fragment":
                      return this.parseFragmentDefinition();
                    case "schema":
                    case "scalar":
                    case "type":
                    case "interface":
                    case "union":
                    case "enum":
                    case "input":
                    case "directive":
                      return this.parseTypeSystemDefinition();
                    case "extend":
                      return this.parseTypeSystemExtension();
                  }
                else {
                  if (this.peek(r.TokenKind.BRACE_L))
                    return this.parseOperationDefinition();
                  if (this.peekDescription())
                    return this.parseTypeSystemDefinition();
                }
                throw this.unexpected();
              }, s.parseOperationDefinition = function() {
                var e = this._lexer.token;
                if (this.peek(r.TokenKind.BRACE_L))
                  return { kind: i.Kind.OPERATION_DEFINITION, operation: "query", name: void 0, variableDefinitions: [], directives: [], selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
                var n = this.parseOperationType(), t;
                return this.peek(r.TokenKind.NAME) && (t = this.parseName()), { kind: i.Kind.OPERATION_DEFINITION, operation: n, name: t, variableDefinitions: this.parseVariableDefinitions(), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
              }, s.parseOperationType = function() {
                var e = this.expectToken(r.TokenKind.NAME);
                switch (e.value) {
                  case "query":
                    return "query";
                  case "mutation":
                    return "mutation";
                  case "subscription":
                    return "subscription";
                }
                throw this.unexpected(e);
              }, s.parseVariableDefinitions = function() {
                return this.optionalMany(r.TokenKind.PAREN_L, this.parseVariableDefinition, r.TokenKind.PAREN_R);
              }, s.parseVariableDefinition = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.VARIABLE_DEFINITION, variable: this.parseVariable(), type: (this.expectToken(r.TokenKind.COLON), this.parseTypeReference()), defaultValue: this.expectOptionalToken(r.TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0, directives: this.parseDirectives(true), loc: this.loc(e) };
              }, s.parseVariable = function() {
                var e = this._lexer.token;
                return this.expectToken(r.TokenKind.DOLLAR), { kind: i.Kind.VARIABLE, name: this.parseName(), loc: this.loc(e) };
              }, s.parseSelectionSet = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.SELECTION_SET, selections: this.many(r.TokenKind.BRACE_L, this.parseSelection, r.TokenKind.BRACE_R), loc: this.loc(e) };
              }, s.parseSelection = function() {
                return this.peek(r.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
              }, s.parseField = function() {
                var e = this._lexer.token, n = this.parseName(), t, u;
                return this.expectOptionalToken(r.TokenKind.COLON) ? (t = n, u = this.parseName()) : u = n, { kind: i.Kind.FIELD, alias: t, name: u, arguments: this.parseArguments(false), directives: this.parseDirectives(false), selectionSet: this.peek(r.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0, loc: this.loc(e) };
              }, s.parseArguments = function(e) {
                var n = e ? this.parseConstArgument : this.parseArgument;
                return this.optionalMany(r.TokenKind.PAREN_L, n, r.TokenKind.PAREN_R);
              }, s.parseArgument = function() {
                var e = this._lexer.token, n = this.parseName();
                return this.expectToken(r.TokenKind.COLON), { kind: i.Kind.ARGUMENT, name: n, value: this.parseValueLiteral(false), loc: this.loc(e) };
              }, s.parseConstArgument = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.ARGUMENT, name: this.parseName(), value: (this.expectToken(r.TokenKind.COLON), this.parseValueLiteral(true)), loc: this.loc(e) };
              }, s.parseFragment = function() {
                var e = this._lexer.token;
                this.expectToken(r.TokenKind.SPREAD);
                var n = this.expectOptionalKeyword("on");
                return !n && this.peek(r.TokenKind.NAME) ? { kind: i.Kind.FRAGMENT_SPREAD, name: this.parseFragmentName(), directives: this.parseDirectives(false), loc: this.loc(e) } : { kind: i.Kind.INLINE_FRAGMENT, typeCondition: n ? this.parseNamedType() : void 0, directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(e) };
              }, s.parseFragmentDefinition = function() {
                var e, n = this._lexer.token;
                return this.expectKeyword("fragment"), ((e = this._options) === null || e === void 0 ? void 0 : e.experimentalFragmentVariables) === true ? { kind: i.Kind.FRAGMENT_DEFINITION, name: this.parseFragmentName(), variableDefinitions: this.parseVariableDefinitions(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(n) } : { kind: i.Kind.FRAGMENT_DEFINITION, name: this.parseFragmentName(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(false), selectionSet: this.parseSelectionSet(), loc: this.loc(n) };
              }, s.parseFragmentName = function() {
                if (this._lexer.token.value === "on")
                  throw this.unexpected();
                return this.parseName();
              }, s.parseValueLiteral = function(e) {
                var n = this._lexer.token;
                switch (n.kind) {
                  case r.TokenKind.BRACKET_L:
                    return this.parseList(e);
                  case r.TokenKind.BRACE_L:
                    return this.parseObject(e);
                  case r.TokenKind.INT:
                    return this._lexer.advance(), { kind: i.Kind.INT, value: n.value, loc: this.loc(n) };
                  case r.TokenKind.FLOAT:
                    return this._lexer.advance(), { kind: i.Kind.FLOAT, value: n.value, loc: this.loc(n) };
                  case r.TokenKind.STRING:
                  case r.TokenKind.BLOCK_STRING:
                    return this.parseStringLiteral();
                  case r.TokenKind.NAME:
                    switch (this._lexer.advance(), n.value) {
                      case "true":
                        return { kind: i.Kind.BOOLEAN, value: true, loc: this.loc(n) };
                      case "false":
                        return { kind: i.Kind.BOOLEAN, value: false, loc: this.loc(n) };
                      case "null":
                        return { kind: i.Kind.NULL, loc: this.loc(n) };
                      default:
                        return { kind: i.Kind.ENUM, value: n.value, loc: this.loc(n) };
                    }
                  case r.TokenKind.DOLLAR:
                    if (!e)
                      return this.parseVariable();
                    break;
                }
                throw this.unexpected();
              }, s.parseStringLiteral = function() {
                var e = this._lexer.token;
                return this._lexer.advance(), { kind: i.Kind.STRING, value: e.value, block: e.kind === r.TokenKind.BLOCK_STRING, loc: this.loc(e) };
              }, s.parseList = function(e) {
                var n = this, t = this._lexer.token, u = function() {
                  return n.parseValueLiteral(e);
                };
                return { kind: i.Kind.LIST, values: this.any(r.TokenKind.BRACKET_L, u, r.TokenKind.BRACKET_R), loc: this.loc(t) };
              }, s.parseObject = function(e) {
                var n = this, t = this._lexer.token, u = function() {
                  return n.parseObjectField(e);
                };
                return { kind: i.Kind.OBJECT, fields: this.any(r.TokenKind.BRACE_L, u, r.TokenKind.BRACE_R), loc: this.loc(t) };
              }, s.parseObjectField = function(e) {
                var n = this._lexer.token, t = this.parseName();
                return this.expectToken(r.TokenKind.COLON), { kind: i.Kind.OBJECT_FIELD, name: t, value: this.parseValueLiteral(e), loc: this.loc(n) };
              }, s.parseDirectives = function(e) {
                for (var n = []; this.peek(r.TokenKind.AT); )
                  n.push(this.parseDirective(e));
                return n;
              }, s.parseDirective = function(e) {
                var n = this._lexer.token;
                return this.expectToken(r.TokenKind.AT), { kind: i.Kind.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(e), loc: this.loc(n) };
              }, s.parseTypeReference = function() {
                var e = this._lexer.token, n;
                return this.expectOptionalToken(r.TokenKind.BRACKET_L) ? (n = this.parseTypeReference(), this.expectToken(r.TokenKind.BRACKET_R), n = { kind: i.Kind.LIST_TYPE, type: n, loc: this.loc(e) }) : n = this.parseNamedType(), this.expectOptionalToken(r.TokenKind.BANG) ? { kind: i.Kind.NON_NULL_TYPE, type: n, loc: this.loc(e) } : n;
              }, s.parseNamedType = function() {
                var e = this._lexer.token;
                return { kind: i.Kind.NAMED_TYPE, name: this.parseName(), loc: this.loc(e) };
              }, s.parseTypeSystemDefinition = function() {
                var e = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
                if (e.kind === r.TokenKind.NAME)
                  switch (e.value) {
                    case "schema":
                      return this.parseSchemaDefinition();
                    case "scalar":
                      return this.parseScalarTypeDefinition();
                    case "type":
                      return this.parseObjectTypeDefinition();
                    case "interface":
                      return this.parseInterfaceTypeDefinition();
                    case "union":
                      return this.parseUnionTypeDefinition();
                    case "enum":
                      return this.parseEnumTypeDefinition();
                    case "input":
                      return this.parseInputObjectTypeDefinition();
                    case "directive":
                      return this.parseDirectiveDefinition();
                  }
                throw this.unexpected(e);
              }, s.peekDescription = function() {
                return this.peek(r.TokenKind.STRING) || this.peek(r.TokenKind.BLOCK_STRING);
              }, s.parseDescription = function() {
                if (this.peekDescription())
                  return this.parseStringLiteral();
              }, s.parseSchemaDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("schema");
                var t = this.parseDirectives(true), u = this.many(r.TokenKind.BRACE_L, this.parseOperationTypeDefinition, r.TokenKind.BRACE_R);
                return { kind: i.Kind.SCHEMA_DEFINITION, description: n, directives: t, operationTypes: u, loc: this.loc(e) };
              }, s.parseOperationTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseOperationType();
                this.expectToken(r.TokenKind.COLON);
                var t = this.parseNamedType();
                return { kind: i.Kind.OPERATION_TYPE_DEFINITION, operation: n, type: t, loc: this.loc(e) };
              }, s.parseScalarTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("scalar");
                var t = this.parseName(), u = this.parseDirectives(true);
                return { kind: i.Kind.SCALAR_TYPE_DEFINITION, description: n, name: t, directives: u, loc: this.loc(e) };
              }, s.parseObjectTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("type");
                var t = this.parseName(), u = this.parseImplementsInterfaces(), y = this.parseDirectives(true), f = this.parseFieldsDefinition();
                return { kind: i.Kind.OBJECT_TYPE_DEFINITION, description: n, name: t, interfaces: u, directives: y, fields: f, loc: this.loc(e) };
              }, s.parseImplementsInterfaces = function() {
                var e;
                if (!this.expectOptionalKeyword("implements"))
                  return [];
                if (((e = this._options) === null || e === void 0 ? void 0 : e.allowLegacySDLImplementsInterfaces) === true) {
                  var n = [];
                  this.expectOptionalToken(r.TokenKind.AMP);
                  do
                    n.push(this.parseNamedType());
                  while (this.expectOptionalToken(r.TokenKind.AMP) || this.peek(r.TokenKind.NAME));
                  return n;
                }
                return this.delimitedMany(r.TokenKind.AMP, this.parseNamedType);
              }, s.parseFieldsDefinition = function() {
                var e;
                return ((e = this._options) === null || e === void 0 ? void 0 : e.allowLegacySDLEmptyFields) === true && this.peek(r.TokenKind.BRACE_L) && this._lexer.lookahead().kind === r.TokenKind.BRACE_R ? (this._lexer.advance(), this._lexer.advance(), []) : this.optionalMany(r.TokenKind.BRACE_L, this.parseFieldDefinition, r.TokenKind.BRACE_R);
              }, s.parseFieldDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName(), u = this.parseArgumentDefs();
                this.expectToken(r.TokenKind.COLON);
                var y = this.parseTypeReference(), f = this.parseDirectives(true);
                return { kind: i.Kind.FIELD_DEFINITION, description: n, name: t, arguments: u, type: y, directives: f, loc: this.loc(e) };
              }, s.parseArgumentDefs = function() {
                return this.optionalMany(r.TokenKind.PAREN_L, this.parseInputValueDef, r.TokenKind.PAREN_R);
              }, s.parseInputValueDef = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName();
                this.expectToken(r.TokenKind.COLON);
                var u = this.parseTypeReference(), y;
                this.expectOptionalToken(r.TokenKind.EQUALS) && (y = this.parseValueLiteral(true));
                var f = this.parseDirectives(true);
                return { kind: i.Kind.INPUT_VALUE_DEFINITION, description: n, name: t, type: u, defaultValue: y, directives: f, loc: this.loc(e) };
              }, s.parseInterfaceTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("interface");
                var t = this.parseName(), u = this.parseImplementsInterfaces(), y = this.parseDirectives(true), f = this.parseFieldsDefinition();
                return { kind: i.Kind.INTERFACE_TYPE_DEFINITION, description: n, name: t, interfaces: u, directives: y, fields: f, loc: this.loc(e) };
              }, s.parseUnionTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("union");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseUnionMemberTypes();
                return { kind: i.Kind.UNION_TYPE_DEFINITION, description: n, name: t, directives: u, types: y, loc: this.loc(e) };
              }, s.parseUnionMemberTypes = function() {
                return this.expectOptionalToken(r.TokenKind.EQUALS) ? this.delimitedMany(r.TokenKind.PIPE, this.parseNamedType) : [];
              }, s.parseEnumTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("enum");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseEnumValuesDefinition();
                return { kind: i.Kind.ENUM_TYPE_DEFINITION, description: n, name: t, directives: u, values: y, loc: this.loc(e) };
              }, s.parseEnumValuesDefinition = function() {
                return this.optionalMany(r.TokenKind.BRACE_L, this.parseEnumValueDefinition, r.TokenKind.BRACE_R);
              }, s.parseEnumValueDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription(), t = this.parseName(), u = this.parseDirectives(true);
                return { kind: i.Kind.ENUM_VALUE_DEFINITION, description: n, name: t, directives: u, loc: this.loc(e) };
              }, s.parseInputObjectTypeDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("input");
                var t = this.parseName(), u = this.parseDirectives(true), y = this.parseInputFieldsDefinition();
                return { kind: i.Kind.INPUT_OBJECT_TYPE_DEFINITION, description: n, name: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseInputFieldsDefinition = function() {
                return this.optionalMany(r.TokenKind.BRACE_L, this.parseInputValueDef, r.TokenKind.BRACE_R);
              }, s.parseTypeSystemExtension = function() {
                var e = this._lexer.lookahead();
                if (e.kind === r.TokenKind.NAME)
                  switch (e.value) {
                    case "schema":
                      return this.parseSchemaExtension();
                    case "scalar":
                      return this.parseScalarTypeExtension();
                    case "type":
                      return this.parseObjectTypeExtension();
                    case "interface":
                      return this.parseInterfaceTypeExtension();
                    case "union":
                      return this.parseUnionTypeExtension();
                    case "enum":
                      return this.parseEnumTypeExtension();
                    case "input":
                      return this.parseInputObjectTypeExtension();
                  }
                throw this.unexpected(e);
              }, s.parseSchemaExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("schema");
                var n = this.parseDirectives(true), t = this.optionalMany(r.TokenKind.BRACE_L, this.parseOperationTypeDefinition, r.TokenKind.BRACE_R);
                if (n.length === 0 && t.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.SCHEMA_EXTENSION, directives: n, operationTypes: t, loc: this.loc(e) };
              }, s.parseScalarTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("scalar");
                var n = this.parseName(), t = this.parseDirectives(true);
                if (t.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.SCALAR_TYPE_EXTENSION, name: n, directives: t, loc: this.loc(e) };
              }, s.parseObjectTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("type");
                var n = this.parseName(), t = this.parseImplementsInterfaces(), u = this.parseDirectives(true), y = this.parseFieldsDefinition();
                if (t.length === 0 && u.length === 0 && y.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.OBJECT_TYPE_EXTENSION, name: n, interfaces: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseInterfaceTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("interface");
                var n = this.parseName(), t = this.parseImplementsInterfaces(), u = this.parseDirectives(true), y = this.parseFieldsDefinition();
                if (t.length === 0 && u.length === 0 && y.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.INTERFACE_TYPE_EXTENSION, name: n, interfaces: t, directives: u, fields: y, loc: this.loc(e) };
              }, s.parseUnionTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("union");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseUnionMemberTypes();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.UNION_TYPE_EXTENSION, name: n, directives: t, types: u, loc: this.loc(e) };
              }, s.parseEnumTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("enum");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseEnumValuesDefinition();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.ENUM_TYPE_EXTENSION, name: n, directives: t, values: u, loc: this.loc(e) };
              }, s.parseInputObjectTypeExtension = function() {
                var e = this._lexer.token;
                this.expectKeyword("extend"), this.expectKeyword("input");
                var n = this.parseName(), t = this.parseDirectives(true), u = this.parseInputFieldsDefinition();
                if (t.length === 0 && u.length === 0)
                  throw this.unexpected();
                return { kind: i.Kind.INPUT_OBJECT_TYPE_EXTENSION, name: n, directives: t, fields: u, loc: this.loc(e) };
              }, s.parseDirectiveDefinition = function() {
                var e = this._lexer.token, n = this.parseDescription();
                this.expectKeyword("directive"), this.expectToken(r.TokenKind.AT);
                var t = this.parseName(), u = this.parseArgumentDefs(), y = this.expectOptionalKeyword("repeatable");
                this.expectKeyword("on");
                var f = this.parseDirectiveLocations();
                return { kind: i.Kind.DIRECTIVE_DEFINITION, description: n, name: t, arguments: u, repeatable: y, locations: f, loc: this.loc(e) };
              }, s.parseDirectiveLocations = function() {
                return this.delimitedMany(r.TokenKind.PIPE, this.parseDirectiveLocation);
              }, s.parseDirectiveLocation = function() {
                var e = this._lexer.token, n = this.parseName();
                if (E.DirectiveLocation[n.value] !== void 0)
                  return n;
                throw this.unexpected(e);
              }, s.loc = function(e) {
                var n;
                if (((n = this._options) === null || n === void 0 ? void 0 : n.noLocation) !== true)
                  return new c.Location(e, this._lexer.lastToken, this._lexer.source);
              }, s.peek = function(e) {
                return this._lexer.token.kind === e;
              }, s.expectToken = function(e) {
                var n = this._lexer.token;
                if (n.kind === e)
                  return this._lexer.advance(), n;
                throw (0, d.syntaxError)(this._lexer.source, n.start, "Expected ".concat(v(e), ", found ").concat(D(n), "."));
              }, s.expectOptionalToken = function(e) {
                var n = this._lexer.token;
                if (n.kind === e)
                  return this._lexer.advance(), n;
              }, s.expectKeyword = function(e) {
                var n = this._lexer.token;
                if (n.kind === r.TokenKind.NAME && n.value === e)
                  this._lexer.advance();
                else
                  throw (0, d.syntaxError)(this._lexer.source, n.start, 'Expected "'.concat(e, '", found ').concat(D(n), "."));
              }, s.expectOptionalKeyword = function(e) {
                var n = this._lexer.token;
                return n.kind === r.TokenKind.NAME && n.value === e ? (this._lexer.advance(), true) : false;
              }, s.unexpected = function(e) {
                var n = e != null ? e : this._lexer.token;
                return (0, d.syntaxError)(this._lexer.source, n.start, "Unexpected ".concat(D(n), "."));
              }, s.any = function(e, n, t) {
                this.expectToken(e);
                for (var u = []; !this.expectOptionalToken(t); )
                  u.push(n.call(this));
                return u;
              }, s.optionalMany = function(e, n, t) {
                if (this.expectOptionalToken(e)) {
                  var u = [];
                  do
                    u.push(n.call(this));
                  while (!this.expectOptionalToken(t));
                  return u;
                }
                return [];
              }, s.many = function(e, n, t) {
                this.expectToken(e);
                var u = [];
                do
                  u.push(n.call(this));
                while (!this.expectOptionalToken(t));
                return u;
              }, s.delimitedMany = function(e, n) {
                this.expectOptionalToken(e);
                var t = [];
                do
                  t.push(n.call(this));
                while (this.expectOptionalToken(e));
                return t;
              }, I;
            }();
            a.Parser = g;
            function D(I) {
              var s = I.value;
              return v(I.kind) + (s != null ? ' "'.concat(s, '"') : "");
            }
            function v(I) {
              return (0, k.isPunctuatorTokenKind)(I) ? '"'.concat(I, '"') : I;
            }
          } });
          K();
          var Ie = ce(), ge = ue(), { hasPragma: Se } = le(), { locStart: Ae, locEnd: De } = pe();
          function Ke(a) {
            let d = [], { startToken: i } = a.loc, { next: c } = i;
            for (; c.kind !== "<EOF>"; )
              c.kind === "Comment" && (Object.assign(c, { column: c.column - 1 }), d.push(c)), c = c.next;
            return d;
          }
          function ie(a) {
            if (a && typeof a == "object") {
              delete a.startToken, delete a.endToken, delete a.prev, delete a.next;
              for (let d in a)
                ie(a[d]);
            }
            return a;
          }
          var X = { allowLegacySDLImplementsInterfaces: false, experimentalFragmentVariables: true };
          function Le(a) {
            let { GraphQLError: d } = W();
            if (a instanceof d) {
              let { message: i, locations: [c] } = a;
              return Ie(i, { start: c });
            }
            return a;
          }
          function xe(a) {
            let { parse: d } = Oe(), { result: i, error: c } = ge(() => d(a, Object.assign({}, X)), () => d(a, Object.assign(Object.assign({}, X), {}, { allowLegacySDLImplementsInterfaces: true })));
            if (!i)
              throw Le(c);
            return i.comments = Ke(i), ie(i), i;
          }
          ae.exports = { parsers: { graphql: { parse: xe, astFormat: "graphql", hasPragma: Se, locStart: Ae, locEnd: De } } };
        });
        return be();
      });
    }
  });

  // node_modules/monaco-graphql/dist/GraphQLWorker.js
  var require_GraphQLWorker = __commonJS({
    "node_modules/monaco-graphql/dist/GraphQLWorker.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __values = exports && exports.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.create = exports.GraphQLWorker = void 0;
      var graphql_language_service_1 = require_dist();
      var LanguageService_1 = require_LanguageService();
      var utils_1 = require_utils3();
      var GraphQLWorker = function() {
        function GraphQLWorker2(ctx, createData) {
          this._ctx = ctx;
          this._languageService = new LanguageService_1.LanguageService(createData.languageConfig);
          this._formattingOptions = createData.formattingOptions;
        }
        GraphQLWorker2.prototype.doValidation = function(uri) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_1, graphqlDiagnostics;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_1 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_1) {
                  return [2, []];
                }
                graphqlDiagnostics = this._languageService.getDiagnostics(uri, document_1);
                return [2, graphqlDiagnostics.map(utils_1.toMarkerData)];
              } catch (err) {
                console.error(err);
                return [2, []];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doComplete = function(uri, position) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_2, graphQLPosition, suggestions;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_2 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_2) {
                  return [2, []];
                }
                graphQLPosition = (0, utils_1.toGraphQLPosition)(position);
                suggestions = this._languageService.getCompletion(uri, document_2, graphQLPosition);
                return [2, suggestions.map(function(suggestion) {
                  return (0, utils_1.toCompletion)(suggestion);
                })];
              } catch (err) {
                console.error(err);
                return [2, []];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doHover = function(uri, position) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document_3, graphQLPosition, hover;
            return __generator(this, function(_a3) {
              try {
                documentModel = this._getTextModel(uri);
                document_3 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                if (!document_3) {
                  return [2, null];
                }
                graphQLPosition = (0, utils_1.toGraphQLPosition)(position);
                hover = this._languageService.getHover(uri, document_3, graphQLPosition);
                return [2, {
                  content: hover,
                  range: (0, utils_1.toMonacoRange)((0, graphql_language_service_1.getRange)({
                    column: graphQLPosition.character,
                    line: graphQLPosition.line
                  }, document_3))
                }];
              } catch (err) {
                console.error(err);
                return [2, null];
              }
              return [2];
            });
          });
        };
        GraphQLWorker2.prototype.doGetVariablesJSONSchema = function(uri) {
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document2, jsonSchema;
            return __generator(this, function(_a3) {
              documentModel = this._getTextModel(uri);
              document2 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
              if (!documentModel || !document2) {
                return [2, null];
              }
              jsonSchema = this._languageService.getVariablesJSONSchema(uri, document2, { useMarkdownDescription: true });
              if (jsonSchema) {
                jsonSchema.$id = "monaco://variables-schema.json";
                jsonSchema.title = "GraphQL Variables";
                return [2, jsonSchema];
              }
              return [2, null];
            });
          });
        };
        GraphQLWorker2.prototype.doFormat = function(uri) {
          var _a3;
          return __awaiter3(this, void 0, void 0, function() {
            var documentModel, document2, prettierStandalone, prettierGraphqlParser;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  documentModel = this._getTextModel(uri);
                  document2 = documentModel === null || documentModel === void 0 ? void 0 : documentModel.getValue();
                  if (!documentModel || !document2) {
                    return [2, null];
                  }
                  return [4, Promise.resolve().then(function() {
                    return __importStar(require_standalone());
                  })];
                case 1:
                  prettierStandalone = _b.sent();
                  return [4, Promise.resolve().then(function() {
                    return __importStar(require_parser_graphql());
                  })];
                case 2:
                  prettierGraphqlParser = _b.sent();
                  return [2, prettierStandalone.format(document2, __assign({ parser: "graphql", plugins: [prettierGraphqlParser] }, (_a3 = this._formattingOptions) === null || _a3 === void 0 ? void 0 : _a3.prettierConfig))];
              }
            });
          });
        };
        GraphQLWorker2.prototype._getTextModel = function(uri) {
          var e_1, _a3;
          var models = this._ctx.getMirrorModels();
          try {
            for (var models_1 = __values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
              var model = models_1_1.value;
              if (model.uri.toString() === uri) {
                return model;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (models_1_1 && !models_1_1.done && (_a3 = models_1.return))
                _a3.call(models_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return null;
        };
        GraphQLWorker2.prototype.doUpdateSchema = function(schema) {
          return this._languageService.updateSchema(schema);
        };
        GraphQLWorker2.prototype.doUpdateSchemas = function(schemas) {
          return this._languageService.updateSchemas(schemas);
        };
        return GraphQLWorker2;
      }();
      exports.GraphQLWorker = GraphQLWorker;
      exports.default = {
        GraphQLWorker
      };
      function create(ctx, createData) {
        return new GraphQLWorker(ctx, createData);
      }
      exports.create = create;
    }
  });

  // node_modules/monaco-graphql/dist/graphql.worker.js
  var require_graphql_worker = __commonJS({
    "node_modules/monaco-graphql/dist/graphql.worker.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      var editor_worker_1 = (init_editor_worker(), __toCommonJS(editor_worker_exports));
      var GraphQLWorker_1 = require_GraphQLWorker();
      self.onmessage = function() {
        (0, editor_worker_1.initialize)(function(ctx, createData) {
          return new GraphQLWorker_1.GraphQLWorker(ctx, createData);
        });
      };
    }
  });
  "use strict";
  require_graphql_worker();
})();
